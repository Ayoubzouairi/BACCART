<!doctype html>
<html lang="ar" dir="rtl">
<head>
<meta charset="utf-8">
<meta name="viewport" content="width=device-width,initial-scale=1">
<title>AYOUB BACCARAT PRO - Ø§Ù„Ù†Ø³Ø®Ø© Ø§Ù„ÙƒØ§Ù…Ù„Ø© Ù…Ø¹ Ø§Ù„Ù…Ø³Ø§Ø¹Ø¯Ø© Ø§Ù„ØµÙˆØªÙŠØ©</title>
<style>
@import url('https://fonts.googleapis.com/css2?family=Inter:wght@300;400;600;800&display=swap');
:root{--gold:#d4af37;--gold-2:#b8871d;--bg-dark:#070606;--card:#0f0e10;--muted:#bfb7a6;--player:#2d7ef7;--banker:#e03b3b;--tie:#28a745;}
:root[data-theme="light"]{--gold:#d4af37;--gold-2:#b8871d;--bg-dark:#f5f5f5;--card:#ffffff;--muted:#666666;--player:#2d7ef7;--banker:#e03b3b;--tie:#28a745;}
*{box-sizing:border-box;margin:0;padding:0;}
body{font-family:Inter,sans-serif;margin:0;background:linear-gradient(180deg,var(--bg-dark),#0b0b0b);color:#fff;padding:18px;transition:background 0.3s, color 0.3s;min-height:100vh;}
:root[data-theme="light"] body{color:#333;}
.app{max-width:1200px;margin:0 auto;width:100%;}
.top{display:flex;align-items:center;justify-content:space-between;gap:12px;margin-bottom:14px;flex-wrap:wrap;}
.logo{font-weight:800;background:linear-gradient(90deg,var(--gold),#fff3b0);color:#000;padding:8px 12px;border-radius:12px;display:inline-block;font-size:1.2rem;}
.subtitle{font-size:14px;color:var(--muted);margin-top:4px;}
.controls{display:flex;gap:8px;align-items:center;flex-wrap:wrap;}
.card{background:linear-gradient(180deg,var(--card),#0b0b0b);border-radius:12px;padding:12px;box-shadow:0 8px 30px rgba(0,0,0,0.6);border:1px solid rgba(212,175,55,0.08);margin-bottom:10px;}
:root[data-theme="light"] .card{background:linear-gradient(180deg,var(--card),#f0f0f0);box-shadow:0 8px 30px rgba(0,0,0,0.1);border:1px solid rgba(0,0,0,0.05);}
.layout{display:flex;gap:12px;flex-wrap:wrap;}
.left{width:360px;min-width:300px;display:flex;flex-direction:column;gap:10px;flex:1;}
.right{flex:2;display:flex;flex-direction:column;gap:12px;min-width:300px;}
.panel{padding:10px;}
.row{display:flex;gap:8px;align-items:center;margin-top:8px;}
input[type=number], select{background:rgba(255,255,255,0.1);border:2px solid rgba(255,255,255,0.3);padding:10px;border-radius:8px;color:#fff;font-weight:600;font-size:14px;width:100%;}
:root[data-theme="light"] input[type=number], :root[data-theme="light"] select{background:rgba(255,255,255,0.9);border:2px solid rgba(0,0,0,0.2);color:#333;}
.btn{padding:12px 16px;border-radius:8px;border:0;color:#fff;cursor:pointer;font-weight:600;font-size:16px;transition:all 0.3s;text-align:center;min-width:70px;}
.btn:hover{transform:translateY(-2px);box-shadow:0 4px 12px rgba(0,0,0,0.3);}
.btn:active{transform:translateY(0);}
.btn.gold{background:linear-gradient(90deg,var(--gold),var(--gold-2));color:#000;font-weight:700;box-shadow:0 6px 20px rgba(212,175,55,0.3);}

/* Ø£Ù„ÙˆØ§Ù† ÙˆØ§Ø¶Ø­Ø© Ù„Ù„ÙˆØ¶Ø¹ Ø§Ù„Ù„ÙŠÙ„ÙŠ */
.btn.player{background:linear-gradient(135deg, #3a86ff, #2667cc); color:white; border:2px solid #3a86ff;}
.btn.banker{background:linear-gradient(135deg, #ff006e, #cc0058); color:white; border:2px solid #ff006e;}
.btn.tie{background:linear-gradient(135deg, #38b000, #2c8a00); color:white; border:2px solid #38b000;}

/* Ø£Ù„ÙˆØ§Ù† Ø§Ù„ÙˆØ¶Ø¹ Ø§Ù„Ù†Ù‡Ø§Ø±ÙŠ */
:root[data-theme="light"] .btn.player{background:linear-gradient(135deg, #2d7ef7, #1a67d8); color:white;}
:root[data-theme="light"] .btn.banker{background:linear-gradient(135deg, #e03b3b, #c53232); color:white;}
:root[data-theme="light"] .btn.tie{background:linear-gradient(135deg, #28a745, #218838); color:white;}

:root[data-theme="light"] .btn{background:rgba(0,0,0,0.1);color:#333; border:1px solid rgba(0,0,0,0.1)}

.small{font-size:13px;color:var(--muted);}
.muted{color:var(--muted);font-size:12px;}
.pattern-list{list-style:none;padding:6px;margin:6px 0 0 0;max-height:200px;overflow:auto;}
.pattern-list li{padding:8px;border-radius:8px;margin-bottom:6px;background:linear-gradient(180deg,rgba(255,255,255,0.02),transparent);display:flex;justify-content:space-between;align-items:center;}
:root[data-theme="light"] .pattern-list li{background:linear-gradient(180deg,rgba(0,0,0,0.02),transparent);}
.section-title{font-weight:700;margin-bottom:6px;color:var(--gold);font-size:1.1rem;}
.stat-table{width:100%;border-collapse:collapse;font-size:13px;}
.stat-table th,.stat-table td{border:1px solid rgba(255,255,255,0.05);padding:6px;text-align:center;}
:root[data-theme="light"] .stat-table th, :root[data-theme="light"] .stat-table td{border:1px solid rgba(0,0,0,0.05);}
.stat-table th{background:rgba(212,175,55,0.1);font-weight:600;}
.player{color:#3a86ff;font-weight:700;}
.banker{color:#ff006e;font-weight:700;}
.tie{color:#38b000;font-weight:700;}
.pred-head{display:flex;justify-content:space-between;align-items:center;flex-wrap:wrap;gap:10px;}
.final{font-size:22px;font-weight:800;text-align:center;padding:12px;background:linear-gradient(90deg,rgba(212,175,55,0.06),transparent);border-radius:10px;margin:10px 0;}
:root[data-theme="light"] .final{background:linear-gradient(90deg,rgba(212,175,55,0.1),transparent);}
.foot{display:flex;justify-content:space-between;align-items:center;margin-top:14px;flex-wrap:wrap;gap:10px;}
.credits{opacity:0.85;font-size:12px;}
canvas{border-radius:10px;background:#0f0e10;width:100% !important;height:auto !important;max-height:450px;}
:root[data-theme="light"] canvas{background:#f0f0f0;}
.color-legend{display:flex;gap:15px;justify-content:center;margin-bottom:10px;font-size:14px;flex-wrap:wrap;}
.color-legend span{padding:4px 8px;border-radius:6px; font-weight:600;}
.prediction-cards{display:flex;gap:10px;justify-content:center;margin:10px 0;flex-wrap:wrap;}
.pred-card{padding:10px;border-radius:8px;text-align:center;min-width:80px; font-weight:600;flex:1;}
.pred-card.active{transform:scale(1.05);border:2px solid var(--gold); box-shadow:0 4px 15px rgba(212,175,55,0.4);}
.win-effect{animation:winPulse 0.5s ease-in-out;}
.loss-effect{animation:lossShake 0.5s ease-in-out;}
@keyframes winPulse{0%{transform:scale(1)}50%{transform:scale(1.1)}100%{transform:scale(1)}}
@keyframes lossShake{0%,100%{transform:translateX(0)}25%{transform:translateX(-5px)}75%{transform:translateX(5px)}}
.analysis-result{margin-top:10px;padding:10px;background:rgba(255,255,255,0.03);border-radius:8px;text-align:center;}
:root[data-theme="light"] .analysis-result{background:rgba(0,0,0,0.03);}
.theme-toggle{background:transparent;border:none;font-size:24px;cursor:pointer;padding:5px;border-radius:50%;transition:background 0.3s;width:40px;height:40px;display:flex;align-items:center;justify-content:center;}
.theme-toggle:hover{background:rgba(255,255,255,0.1);}
:root[data-theme="light"] .theme-toggle:hover{background:rgba(0,0,0,0.05);}

/* ØªØ­Ø³ÙŠÙ†Ø§Øª Ø¥Ø¶Ø§ÙÙŠØ© Ù„Ù„Ø­Ù‚ÙˆÙ„ */
.input-group {display: flex; gap: 8px; align-items: center;}
.input-group input {flex: 1;}
.input-label {font-weight: 600; margin-bottom: 6px; display: block;}

/* Ø£Ù„ÙˆØ§Ù† Ø§Ù„Ø¨Ø·Ø§Ù‚Ø§Øª ÙÙŠ Ø§Ù„ØªÙˆÙ‚Ø¹ */
.pred-card.player {background: linear-gradient(135deg, #3a86ff, #2667cc); color: white;}
.pred-card.banker {background: linear-gradient(135deg, #ff006e, #cc0058); color: white;}
.pred-card.tie {background: linear-gradient(135deg, #38b000, #2c8a00); color: white;}

/* Ø£Ù†Ù…Ø§Ø· Ù„Ù…Ù†Ø­Ù†Ù‰ Ø§Ù„ØªÙˆÙ‚Ø¹Ø§Øª */
.accuracy-panel {margin-top: 12px;}
.accuracy-stats {display: flex; justify-content: space-between; margin-bottom: 8px; flex-wrap: wrap; gap: 10px;}
.accuracy-stats > div {flex: 1; min-width: 120px;}
.accuracy-value {font-weight: 700; font-size: 18px;}
.accuracy-label {font-size: 12px; color: var(--muted);}
.accuracy-chart-container {position: relative; height: 80px; margin-top: 8px; width: 100%;}
.accuracy-line {stroke: var(--gold); stroke-width: 2; fill: none;}
.accuracy-point {fill: var(--gold); r: 3; transition: r 0.2s;}
.accuracy-point:hover {r: 5;}
.accuracy-grid {stroke: rgba(255,255,255,0.1); stroke-width: 1;}
:root[data-theme="light"] .accuracy-grid {stroke: rgba(0,0,0,0.1);}
.accuracy-tooltip {position: absolute; background: rgba(0,0,0,0.9); color: white; padding: 5px 8px; border-radius: 4px; font-size: 12px; pointer-events: none; opacity: 0; transition: opacity 0.2s; z-index: 100;}

/* Ø£Ù†Ù…Ø§Ø· Ø¬Ø¯ÙŠØ¯Ø© Ù„Ù„ÙˆØ§Ø¬Ù‡Ø© Ø§Ù„Ù…Ø­Ø³Ù†Ø© */
.advanced-controls {background: rgba(212,175,55,0.05); border-radius: 8px; padding: 10px; margin-top: 8px;}
.control-group {display: flex; justify-content: space-between; align-items: center; margin-bottom: 8px; flex-wrap: wrap;}
.control-group:last-child {margin-bottom: 0;}
.slider-container {flex: 1; margin-left: 10px; min-width: 150px;}
.slider {width: 100%;}
.model-badge {display: inline-block; padding: 2px 8px; border-radius: 12px; font-size: 10px; font-weight: 600; margin-left: 5px;}
.badge-basic {background: #3a86ff; color: white;}
.badge-advanced {background: #ff006e; color: white;}
.badge-pattern {background: #38b000; color: white;}
.badge-ml {background: #9d4edd; color: white;}
.pattern-info {font-size: 11px; color: var(--muted); margin-top: 4px; line-height: 1.4;}
.confidence-meter {height: 6px; background: rgba(255,255,255,0.1); border-radius: 3px; margin-top: 4px; overflow:hidden;}
.confidence-fill {height: 100%; background: linear-gradient(90deg, #38b000, #ff006e); border-radius: 3px; transition: width 0.3s;}
.high-confidence {background: linear-gradient(90deg, #38b000, #d4af37);}
.medium-confidence {background: linear-gradient(90deg, #d4af37, #ff006e);}

/* ØªØ¨Ø¯ÙŠÙ„ Ø²Ø± Ø§Ù„ØªØ¹Ù„Ù… Ø§Ù„Ø¢Ù„ÙŠ */
.switch {position: relative; display: inline-block; width: 50px; height: 24px; flex-shrink: 0;}
.switch input {opacity: 0; width: 0; height: 0;}
.switch .slider {position: absolute; cursor: pointer; top: 0; left: 0; right: 0; bottom: 0; background-color: #ccc; transition: .4s; border-radius: 34px;}
.switch .slider:before {position: absolute; content: ""; height: 16px; width: 16px; left: 4px; bottom: 4px; background-color: white; transition: .4s; border-radius: 50%;}
.switch input:checked + .slider {background: linear-gradient(90deg, #9d4edd, #7b2cbf);}
.switch input:checked + .slider:before {transform: translateX(26px);}

/* Ù…Ø¤Ø´Ø± ØªØ¯Ø±ÙŠØ¨ ML */
.ml-training-indicator {display: inline-block; width: 10px; height: 10px; border-radius: 50%; margin-right: 5px;}
.ml-training {background: #38b000; animation: pulse 1.5s infinite;}
.ml-not-trained {background: #ff006e;}
@keyframes pulse {0% {opacity: 1;} 50% {opacity: 0.5;} 100% {opacity: 1;}}

/* ØªØ­Ø³ÙŠÙ†Ø§Øª Ù„Ù„ÙˆØ§Ø¬Ù‡Ø© */
.ml-info-panel {background: rgba(157, 78, 221, 0.05); border-left: 3px solid #9d4edd;}

/* Ø£Ø²Ø±Ø§Ø± Ø§Ù„ØªØ­ÙƒÙ… ÙÙŠ Ø§Ù„Ø¨ÙŠØ§Ù†Ø§Øª */
.data-controls {display: flex; gap: 8px; flex-wrap: wrap; margin-top: 8px;}
.data-controls .btn {padding: 6px 10px; font-size: 12px; flex: 1; min-width: 100px;}

/* Ø£Ù†Ù…Ø§Ø· Ø§Ù„Ù…Ø³Ø§Ø¹Ø¯Ø© Ø§Ù„ØµÙˆØªÙŠØ© */
.voice-assistant-active {border: 2px solid #9d4edd !important; box-shadow: 0 0 20px rgba(157, 78, 221, 0.7) !important;}
.voice-pulse {animation: voicePulse 2s infinite;}
@keyframes voicePulse {0% {box-shadow: 0 0 0 0 rgba(157, 78, 221, 0.7);} 70% {box-shadow: 0 0 0 10px rgba(157, 78, 221, 0);} 100% {box-shadow: 0 0 0 0 rgba(157, 78, 221, 0);}}
.voice-controls {display: flex; gap: 8px; flex-wrap: wrap; margin-bottom: 10px;}
.voice-message {background: rgba(157, 78, 221, 0.1); border-left: 3px solid #9d4edd; padding: 10px; border-radius: 8px; margin-top: 10px; font-size: 13px; line-height: 1.5; min-height: 60px;}
.voice-status {display: flex; align-items: center; gap: 8px; margin-top: 8px;}
.voice-dot {width: 10px; height: 10px; border-radius: 50%; background: #38b000;}
.voice-dot.speaking {background: #ff006e; animation: blink 1s infinite;}
@keyframes blink {0%, 100% {opacity: 1;} 50% {opacity: 0.3;}}
.assistant-avatar {width: 50px; height: 50px; background: linear-gradient(135deg, #9d4edd, #7b2cbf); border-radius: 50%; display: flex; align-items: center; justify-content: center; font-size: 20px; font-weight: bold; margin: 0 auto 10px;}
.conversation-log {max-height: 200px; overflow-y: auto; background: rgba(0,0,0,0.3); border-radius: 8px; padding: 10px; margin-top: 10px; font-size: 12px;}
.conversation-item {margin-bottom: 8px; padding-bottom: 8px; border-bottom: 1px solid rgba(255,255,255,0.1);}
.conversation-item:last-child {border-bottom: none;}

/* ØªØ­Ø³ÙŠÙ†Ø§Øª Ù„Ù„Ø§Ø³ØªØ¬Ø§Ø¨Ø© */
@media (max-width: 768px) {
    .layout {flex-direction: column;}
    .left, .right {width: 100%;}
    .top {flex-direction: column; align-items: flex-start;}
    .controls {width: 100%; justify-content: space-between;}
    .accuracy-stats > div {min-width: 100px;}
    .prediction-cards {flex-direction: column;}
    .pred-card {width: 100%;}
    .color-legend {justify-content: flex-start;}
    .row {flex-wrap: wrap;}
    .btn {flex: 1; min-width: 60px;}
    .voice-controls {flex-direction: column;}
}

@media (max-width: 480px) {
    body {padding: 10px;}
    .card {padding: 8px;}
    .btn {padding: 10px 12px; font-size: 14px;}
    .accuracy-stats {flex-direction: column;}
    .accuracy-stats > div {min-width: 100%;}
}
</style>
</head>
<body>
<div class="app">
<header class="top card">
  <div class="brand">
    <div class="logo">AYOUB BACCARAT PRO <span class="model-badge badge-ml">Ù†Ø³Ø®Ø© ÙƒØ§Ù…Ù„Ø©</span></div>
    <div class="subtitle">Ù†Ø¸Ø§Ù… ØªÙ†Ø¨Ø¤ Ø°ÙƒÙŠ Ù…Ø¹ Ù…Ø³Ø§Ø¹Ø¯Ø© ØµÙˆØªÙŠØ© ØªÙØ§Ø¹Ù„ÙŠØ© ğŸ§ ğŸ—£ï¸ğŸ’¬</div>
  </div>
  <div class="controls">
    <button id="themeToggle" class="theme-toggle" title="ØªØ¨Ø¯ÙŠÙ„ Ø§Ù„ÙˆØ¶Ø¹">ğŸŒš</button>
    <button id="voiceAssistantToggle" class="btn" style="background: linear-gradient(135deg, #9d4edd, #7b2cbf);">
      <span id="voiceIcon">ğŸ¤</span> Ø§Ù„Ù…Ø³Ø§Ø¹Ø¯Ø© Ø§Ù„ØµÙˆØªÙŠØ©
    </button>
    <button id="btnReset" class="btn gold">Ø¥Ø¹Ø§Ø¯Ø© ØªØ¹ÙŠÙŠÙ†</button>
  </div>
</header>

<main class="layout">
<aside class="left">
  <div class="panel card">
    <label class="input-label">Ù†Ø§ÙØ°Ø© Ø§Ù„ØªØ­Ù„ÙŠÙ„ (5 - 15)</label>
    <div class="input-group">
      <input id="windowSize" type="number" min="5" max="15" value="8">
      <button id="applyWindow" class="btn gold">ØªØ·Ø¨ÙŠÙ‚</button>
    </div>
    <div class="muted small">ÙŠØ­Ù„Ù„ Ø¢Ø®Ø± 5-15 Ø¬ÙˆÙ„Ø© Ø¨Ø§Ø³ØªØ®Ø¯Ø§Ù… Ø®ÙˆØ§Ø±Ø²Ù…ÙŠØ§Øª Ù…ØªÙ‚Ø¯Ù…Ø©</div>
  </div>

  <!-- Ø¥Ø¹Ø¯Ø§Ø¯Ø§Øª Ø§Ù„ØªÙ†Ø¨Ø¤ Ø§Ù„Ù…ØªÙ‚Ø¯Ù… -->
  <div class="panel card">
    <div class="section-title">Ø¥Ø¹Ø¯Ø§Ø¯Ø§Øª Ø§Ù„ØªÙ†Ø¨Ø¤ Ø§Ù„Ù…ØªÙ‚Ø¯Ù…</div>
    <div class="advanced-controls">
      <div class="control-group">
        <label for="analysisMode">Ù†Ù…Ø· Ø§Ù„ØªØ­Ù„ÙŠÙ„:</label>
        <select id="analysisMode">
          <option value="basic">Ø£Ø³Ø§Ø³ÙŠ <span class="model-badge badge-basic">+5%</span></option>
          <option value="advanced" selected>Ù…ØªÙ‚Ø¯Ù… <span class="model-badge badge-advanced">+15%</span></option>
          <option value="pattern">ØªØ­Ù„ÙŠÙ„ Ø§Ù„Ø£Ù†Ù…Ø§Ø· <span class="model-badge badge-pattern">+25%</span></option>
          <option value="ml">ØªØ¹Ù„Ù… Ø§Ù„Ø¢Ù„Ø© <span class="model-badge badge-ml">+35%</span></option>
        </select>
      </div>
      <div class="control-group">
        <label for="confidenceSensitivity">Ø­Ø³Ø§Ø³ÙŠØ© Ø§Ù„Ø«Ù‚Ø©:</label>
        <div class="slider-container">
          <input type="range" id="confidenceSensitivity" class="slider" min="30" max="60" value="45">
          <div class="muted small" id="sensitivityValue">45%</div>
        </div>
      </div>
      <div class="control-group">
        <label for="timeWeighting">Ø§Ù„Ù…Ø±Ø¬Ø­Ø© Ø§Ù„Ø²Ù…Ù†ÙŠØ©:</label>
        <select id="timeWeighting">
          <option value="none">Ø¨Ø¯ÙˆÙ†</option>
          <option value="linear" selected>Ø®Ø·ÙŠ</option>
          <option value="exponential">Ø£Ø³Ù‘ÙŠ</option>
        </select>
      </div>
    </div>
  </div>

  <!-- Ù‚Ø³Ù… ØªØ¹Ù„Ù… Ø§Ù„Ø¢Ù„Ø© -->
  <div class="panel card ml-info-panel">
    <div class="section-title">âš™ï¸ ØªØ¹Ù„Ù… Ø§Ù„Ø¢Ù„Ø©</div>
    <div class="row">
      <label class="switch">
        <input type="checkbox" id="mlToggle" checked>
        <span class="slider"></span>
      </label>
      <span>ØªÙØ¹ÙŠÙ„ ØªØ¹Ù„Ù… Ø§Ù„Ø¢Ù„Ø©</span>
    </div>
    <div class="row">
      <select id="mlModelSelect" style="flex:1; margin-top: 5px;">
        <option value="knn">K-Ø§Ù„Ø¬ÙŠØ±Ø§Ù† Ø§Ù„Ø£Ù‚Ø±Ø¨</option>
        <option value="logistic">Ø§Ù„Ø§Ù†Ø­Ø¯Ø§Ø± Ø§Ù„Ù„ÙˆØ¬Ø³ØªÙŠ</option>
        <option value="ensemble" selected>Ø§Ù„Ù…Ø¬Ù…Ø¹ (Ø¬Ù…ÙŠØ¹ Ø§Ù„Ù†Ù…Ø§Ø°Ø¬)</option>
      </select>
    </div>
    <div class="row">
      <div id="mlStatus" class="muted small">
        <span class="ml-training-indicator ml-training"></span> 
        Ø§Ù„Ù†Ù…ÙˆØ°Ø¬ ÙŠØªØ¹Ù„Ù… Ù…Ù† Ø§Ù„Ø¨ÙŠØ§Ù†Ø§Øª...
      </div>
    </div>
    <div class="pattern-info">
      <span id="mlTrainingCount">0</span> Ø¹ÙŠÙ†Ø© ØªØ¯Ø±ÙŠØ¨ â€¢ 
      <span id="mlAccuracy">0%</span> Ø¯Ù‚Ø© â€¢ 
      <span id="mlWeight">30%</span> ØªØ£Ø«ÙŠØ±
    </div>
  </div>

  <!-- Ø¥Ø¯Ø®Ø§Ù„ Ø§Ù„Ù†ØªØ§Ø¦Ø¬ -->
  <div class="panel card">
    <div class="section-title">Ø¥Ø¯Ø®Ø§Ù„ Ø§Ù„Ù†ØªØ§Ø¦Ø¬</div>
    <div class="row">
      <button class="btn player" id="btnP">Ù„Ø§Ø¹Ø¨ ğŸ”µ</button>
      <button class="btn banker" id="btnB">Ù…ØµØ±ÙÙŠ ğŸ”´</button>
      <button class="btn tie" id="btnT">ØªØ¹Ø§Ø¯Ù„ ğŸŸ¢</button>
    </div>
    <div class="row">
      <button class="btn" id="btnUndo" style="flex:1; background:rgba(255,255,255,0.1); border:1px solid rgba(255,255,255,0.2)">ØªØ±Ø§Ø¬Ø¹</button>
    </div>
    <div class="muted small" style="margin-top: 8px; text-align: center;">
      Ø£Ø¯Ø®Ù„ Ù†ØªÙŠØ¬Ø© ÙƒÙ„ Ø¬ÙˆÙ„Ø© Ø¨Ø§Ù„Ø¶ØºØ· Ø¹Ù„Ù‰ Ø§Ù„Ø²Ø± Ø§Ù„Ù…Ù†Ø§Ø³Ø¨
    </div>
  </div>

  <!-- Ø§Ù„Ø¥Ø­ØµØ§Ø¡Ø§Øª -->
  <div class="panel card stats">
    <div class="section-title">Ø§Ù„Ø¥Ø­ØµØ§Ø¡Ø§Øª Ø§Ù„Ù…ØªÙ‚Ø¯Ù…Ø©</div>
    <table class="stat-table">
      <thead>
        <tr><th>Ø§Ù„Ø¬Ù‡Ø©</th><th>Ø§Ù„Ù…Ø¬Ù…ÙˆØ¹</th><th>ÙÙˆØ²</th><th>Ø®Ø³Ø§Ø±Ø©</th><th>Ù†Ø³Ø¨Ø© %</th><th>Ø¯Ù‚Ø©</th><th>ML Ø¯Ù‚Ø©</th></tr>
      </thead>
      <tbody>
        <tr><td class="player">Ù„Ø§Ø¹Ø¨</td><td id="pTotal">0</td><td id="pWin">0</td><td id="pLoss">0</td><td id="pPct">0%</td><td id="pAccuracy">0%</td><td id="pMLAccuracy">0%</td></tr>
        <tr><td class="banker">Ù…ØµØ±ÙÙŠ</td><td id="bTotal">0</td><td id="bWin">0</td><td id="bLoss">0</td><td id="bPct">0%</td><td id="bAccuracy">0%</td><td id="bMLAccuracy">0%</td></tr>
        <tr><td class="tie">ØªØ¹Ø§Ø¯Ù„</td><td id="tTotal">0</td><td id="tWin">0</td><td id="tLoss">0</td><td id="tPct">0%</td><td id="tAccuracy">0%</td><td id="tMLAccuracy">0%</td></tr>
      </tbody>
    </table>
    <div class="pattern-info" id="patternInfo">Ù„Ø§ ØªÙˆØ¬Ø¯ Ø£Ù†Ù…Ø§Ø· Ù…ÙƒØªØ´ÙØ© Ø¨Ø¹Ø¯</div>
  </div>

  <!-- Ù…Ø¤Ø´Ø± Ø§Ù„Ø«Ù‚Ø© -->
  <div class="panel card">
    <div class="section-title">Ù…Ø¤Ø´Ø± Ø§Ù„Ø«Ù‚Ø©</div>
    <div class="muted small" id="confidenceLabel">Ø«Ù‚Ø© Ù…Ù†Ø®ÙØ¶Ø©</div>
    <div class="confidence-meter">
      <div class="confidence-fill" id="confidenceFill" style="width: 0%"></div>
    </div>
    <div class="pattern-info" id="modelInfo">Ø§Ù„Ù†Ù…ÙˆØ°Ø¬: Ø£Ø³Ø§Ø³ÙŠ</div>
  </div>
</aside>

<section class="right">
  <div class="card prediction">
    <div class="pred-head">
      <div class="pred-title">ØªÙˆÙ‚Ø¹ Ø§Ù„Ø¬ÙˆÙ„Ø© Ø§Ù„Ù‚Ø§Ø¯Ù…Ø© <span id="predModel" class="model-badge badge-basic">Ø£Ø³Ø§Ø³ÙŠ</span></div>
      <div class="pred-sub">Ù†Ø¸Ø§Ù… ØªÙ†Ø¨Ø¤ Ù…ØªØ¹Ø¯Ø¯ Ø§Ù„Ù†Ù…Ø§Ø°Ø¬ Ù…Ø¹ Ø®ÙˆØ§Ø±Ø²Ù…ÙŠØ§Øª ØªØ¹Ù„Ù… Ø¢Ù„Ø©</div>
    </div>

    <div class="color-legend">
      <span style="background:linear-gradient(135deg, #3a86ff, #2667cc);">ğŸ”µ Ù„Ø§Ø¹Ø¨</span>
      <span style="background:linear-gradient(135deg, #ff006e, #cc0058);">ğŸ”´ Ù…ØµØ±ÙÙŠ</span>
      <span style="background:linear-gradient(135deg, #38b000, #2c8a00);">ğŸŸ¢ ØªØ¹Ø§Ø¯Ù„</span>
    </div>
    
    <canvas id="bigRoad" width="800" height="450"></canvas>

    <div class="prediction-cards">
      <div class="pred-card player" id="predP">
        <div>Ù„Ø§Ø¹Ø¨</div>
        <div id="predPctP">0%</div>
        <div class="muted small" id="predTrendP">â†’</div>
      </div>
      <div class="pred-card banker" id="predB">
        <div>Ù…ØµØ±ÙÙŠ</div>
        <div id="predPctB">0%</div>
        <div class="muted small" id="predTrendB">â†’</div>
      </div>
      <div class="pred-card tie" id="predT">
        <div>ØªØ¹Ø§Ø¯Ù„</div>
        <div id="predPctT">0%</div>
        <div class="muted small" id="predTrendT">â†’</div>
      </div>
    </div>

    <div class="analysis-result">
      <div class="muted">Ø§Ù„ØªÙˆÙ‚Ø¹ Ø§Ù„Ø­Ø§Ù„ÙŠ:</div>
      <div class="final" id="finalCard">â€”</div>
      <div class="muted small" id="predictionReason">Ø¨Ø§Ù†ØªØ¸Ø§Ø± Ø¨ÙŠØ§Ù†Ø§Øª ÙƒØ§ÙÙŠØ© Ù„Ù„ØªØ­Ù„ÙŠÙ„</div>
      <div class="muted small" id="mlContribution" style="margin-top: 5px; color: #9d4edd;"></div>
    </div>
  </div>

  <!-- Ø§Ù„Ù…Ø³Ø§Ø¹Ø¯Ø© Ø§Ù„ØµÙˆØªÙŠØ© Ø§Ù„ØªÙØ§Ø¹Ù„ÙŠØ© -->
  <div class="panel card" style="background: linear-gradient(135deg, rgba(157, 78, 221, 0.1), rgba(212, 175, 55, 0.05));">
    <div class="section-title">ğŸ¤– Ø§Ù„Ù…Ø³Ø§Ø¹Ø¯Ø© Ø§Ù„ØµÙˆØªÙŠØ© - Ù†Ø§Ø¯ÙŠÙ†</div>
    
    <div class="assistant-avatar">ğŸ‘©</div>
    
    <div class="voice-message" id="voiceMessage">
      <div id="currentMessage">Ù…Ø±Ø­Ø¨Ø§Ù‹! Ø£Ù†Ø§ Ù†Ø§Ø¯ÙŠÙ†ØŒ Ù…Ø³Ø§Ø¹Ø¯ØªÙƒ Ø§Ù„ØµÙˆØªÙŠØ©. Ø§Ø¶ØºØ· Ø¹Ù„Ù‰ Ø§Ù„Ø£Ø²Ø±Ø§Ø± Ù„Ù„ØªÙØ§Ø¹Ù„ Ù…Ø¹ÙŠ.</div>
      <div class="voice-status">
        <div class="voice-dot" id="voiceDot"></div>
        <span id="voiceStatusText">Ø¬Ø§Ù‡Ø²Ø© Ù„Ù„ØªØ­Ø¯Ø«</span>
      </div>
    </div>
    
    <div class="voice-controls">
      <button id="btnSpeakPrediction" class="btn" style="background: #3a86ff; flex: 1;">
        ğŸ”Š ØªØ­Ø¯Ø« Ø¹Ù† Ø§Ù„ØªÙ†Ø¨Ø¤
      </button>
      <button id="btnAskAdvice" class="btn" style="background: #38b000; flex: 1;">
        ğŸ’¡ Ø§Ø³Ø£Ù„ Ø¹Ù† Ù†ØµÙŠØ­Ø©
      </button>
      <button id="btnAskEntry" class="btn" style="background: #d4af37; flex: 1;">
        ğŸš¦ Ø§Ø³Ø£Ù„ Ø¹Ù† Ø§Ù„Ø¯Ø®ÙˆÙ„
      </button>
    </div>
    
    <div class="voice-controls">
      <button id="btnAskExit" class="btn" style="background: #ff006e; flex: 1;">
        ğŸ Ø§Ø³Ø£Ù„ Ø¹Ù† Ø§Ù„Ø®Ø±ÙˆØ¬
      </button>
      <button id="btnAskAnalysis" class="btn" style="background: #9d4edd; flex: 2;">
        ğŸ“Š Ø§Ø·Ù„Ø¨ ØªØ­Ù„ÙŠÙ„ Ù…ÙØµÙ„
      </button>
    </div>
    
    <div class="pattern-info">
      <span id="assistantMood">Ø§Ù„Ø­Ø§Ù„Ø©: Ù…ØªØ­Ù…Ø³Ø© Ù„Ù…Ø³Ø§Ø¹Ø¯ØªÙƒ</span> â€¢ 
      <span id="conversationCount">Ù…Ø­Ø§Ø¯Ø«Ø§Øª: 0</span>
    </div>
    
    <div class="conversation-log" id="conversationLog">
      <!-- Ø³Ø¬Ù„ Ø§Ù„Ù…Ø­Ø§Ø¯Ø«Ø§Øª Ø³ÙŠØ¸Ù‡Ø± Ù‡Ù†Ø§ -->
    </div>
  </div>
</section>
</main>

<footer class="foot card">
  <div style="flex: 1;">
    <div>ØªØµÙ…ÙŠÙ…: Ayoub â€¢ Ø§Ù„Ù†Ø³Ø®Ø© Ø§Ù„ÙƒØ§Ù…Ù„Ø© Ù…Ø¹ Ø§Ù„Ù…Ø³Ø§Ø¹Ø¯Ø© Ø§Ù„ØµÙˆØªÙŠØ©</div>
    <div class="credits small">Ù†Ø¸Ø§Ù… Ù…ØªØ¹Ø¯Ø¯ Ø§Ù„Ù†Ù…Ø§Ø°Ø¬ â€¢ Ù…Ø³Ø§Ø¹Ø¯Ø© ØµÙˆØªÙŠØ© ØªÙØ§Ø¹Ù„ÙŠØ© â€¢ ØªØ¹Ù„Ù… Ø¢Ù„Ø© â€¢ ØªØ­Ù„ÙŠÙ„ Ø§Ù„Ø£Ù†Ù…Ø§Ø· â€¢ Ø­ÙØ¸ ØªÙ„Ù‚Ø§Ø¦ÙŠ</div>
  </div>
  <div class="data-controls">
    <button id="btnExport" class="btn" style="background: rgba(59, 130, 246, 0.2); border: 1px solid #3a86ff;">ğŸ“¥ ØªØµØ¯ÙŠØ±</button>
    <button id="btnImport" class="btn" style="background: rgba(16, 185, 129, 0.2); border: 1px solid #10b981;">ğŸ“¤ Ø§Ø³ØªÙŠØ±Ø§Ø¯</button>
    <button id="btnClearData" class="btn" style="background: rgba(239, 68, 68, 0.2); border: 1px solid #ef4444;">ğŸ—‘ï¸ Ù…Ø³Ø­</button>
  </div>
  <div class="muted small" style="text-align: center; width: 100%; margin-top: 10px;">
    <span id="autoSaveStatus">ğŸ’¾ Ø§Ù„Ø­ÙØ¸ Ø§Ù„ØªÙ„Ù‚Ø§Ø¦ÙŠ Ù…ÙØ¹Ù„</span> â€¢ 
    <span id="dataStats">0 Ø¬ÙˆÙ„Ø© â€¢ 0 Ø¹ÙŠÙ†Ø© ØªØ¯Ø±ÙŠØ¨</span>
  </div>
</footer>
</div>

<script>
// ========== Ù†Ø¸Ø§Ù… Ø§Ù„Ù…Ø³Ø§Ø¹Ø¯Ø© Ø§Ù„ØµÙˆØªÙŠØ© Ø§Ù„ØªÙØ§Ø¹Ù„ÙŠØ© ==========

class VoiceAssistant {
  constructor() {
    this.name = "Ù†Ø§Ø¯ÙŠÙ†";
    this.isActive = false;
    this.isSpeaking = false;
    this.conversationCount = 0;
    this.mood = "Ù…ØªØ­Ù…Ø³Ø©";
    this.lastSpokenTime = null;
    this.synth = window.speechSynthesis;
    this.voices = [];
    this.currentVoice = null;
    this.conversationHistory = [];
    
    this.initVoices();
    
    // Ø´Ø®ØµÙŠØ© Ø§Ù„Ù…Ø³Ø§Ø¹Ø¯Ø©
    this.personality = {
      name: "Ù†Ø§Ø¯ÙŠÙ†",
      gender: "Ø£Ù†Ø«Ù‰",
      age: "Ø´Ø§Ø¨Ø©",
      tone: "ÙˆØ¯ÙˆØ¯Ø© ÙˆÙ…ØªØ­Ù…Ø³Ø©",
      style: "ØªØªØ­Ø¯Ø« ÙƒØµØ¯ÙŠÙ‚Ø© ØªÙ‚Ø¯Ù… Ø§Ù„Ù†ØµØ§Ø¦Ø­",
      traits: ["Ø°ÙƒÙŠØ©", "Ù…Ø±Ø­Ø©", "Ø¯Ø§Ø¹Ù…Ø©", "ØµØ±ÙŠØ­Ø©", "Ù…ØªÙØ§Ø¦Ù„Ø©"]
    };
    
    // Ù‚Ø§Ø¹Ø¯Ø© Ø§Ù„Ù…Ø¹Ø±ÙØ©
    this.knowledge = {
      greetings: [
        "Ù…Ø±Ø­Ø¨Ø§Ù‹! Ø£Ù†Ø§ Ù†Ø§Ø¯ÙŠÙ†ØŒ Ù…Ø³Ø§Ø¹Ø¯ØªÙƒ Ø§Ù„ØµÙˆØªÙŠØ© Ø§Ù„Ø°ÙƒÙŠØ©. Ø³Ø¹ÙŠØ¯Ù‡ Ø¨Ø£Ù† Ø£ÙƒÙˆÙ† Ù…Ø¹Ùƒ ÙÙŠ Ø±Ø­Ù„Ø© Ø§Ù„Ø¨Ø§ÙƒØ§Ø±Ø§Øª!",
        "Ø£Ù‡Ù„Ø§Ù‹ ÙˆØ³Ù‡Ù„Ø§Ù‹! Ø£Ù†Ø§ Ù†Ø§Ø¯ÙŠÙ†ØŒ Ø¬Ø§Ù‡Ø²Ø© Ù„ØªÙ‚Ø¯ÙŠÙ… Ø§Ù„Ù†ØµØ§Ø¦Ø­ ÙˆØ§Ù„ØªÙˆÙ‚Ø¹Ø§Øª Ø¨ØµÙˆØªÙŠ Ø§Ù„Ø¬Ù…ÙŠÙ„!",
        "Ù…Ø±Ø­Ø¨Ø§Ù‹ Ø¨Ùƒ! Ø£Ù†Ø§ Ù†Ø§Ø¯ÙŠÙ†ØŒ ØµØ¯ÙŠÙ‚ØªÙƒ Ø§Ù„Ø°ÙƒÙŠØ© ÙÙŠ Ø¹Ø§Ù„Ù… Ø§Ù„Ø¨Ø§ÙƒØ§Ø±Ø§Øª. ÙƒÙŠÙ ÙŠÙ…ÙƒÙ†Ù†ÙŠ Ù…Ø³Ø§Ø¹Ø¯ØªÙƒØŸ"
      ],
      
      predictions: {
        strong: [
          "Ø§Ù„ØªÙ†Ø¨Ø¤ Ø§Ù„Ø­Ø§Ù„ÙŠ ÙŠØ´ÙŠØ± Ø¨Ù‚ÙˆØ© Ø¥Ù„Ù‰ {{result}}! Ø§Ù„Ø«Ù‚Ø© Ù…Ø±ØªÙØ¹Ø© Ø¹Ù†Ø¯ {{confidence}}%. Ù‡Ø°Ù‡ ÙØ±ØµØ© Ù…Ù…ØªØ§Ø²Ø©!",
          "Ø£Ø±Ù‰ Ø¥Ø´Ø§Ø±Ø© ÙˆØ§Ø¶Ø­Ø© Ù„Ù€ {{result}} Ø¨Ø«Ù‚Ø© {{confidence}}%. Ù‡Ø°Ø§ ØªÙ†Ø¨Ø¤ ÙˆØ§Ø¹Ø¯ Ø¬Ø¯Ø§Ù‹!",
          "Ø¨Ù†Ø§Ø¡Ù‹ Ø¹Ù„Ù‰ Ø§Ù„ØªØ­Ù„ÙŠÙ„ Ø§Ù„Ø¯Ù‚ÙŠÙ‚ØŒ {{result}} Ù‡Ùˆ Ø§Ù„Ø®ÙŠØ§Ø± Ø§Ù„Ø£Ù‚ÙˆÙ‰ Ù…Ø¹ Ø«Ù‚Ø© {{confidence}}%. Ø£Ù†Ø§ Ù…ØªØ­Ù…Ø³Ø© Ù„Ù‡Ø°Ù‡ Ø§Ù„Ø¥Ø´Ø§Ø±Ø©!"
        ],
        moderate: [
          "Ù‡Ù†Ø§Ùƒ ØªÙ„Ù…ÙŠØ­ Ù„Ù€ {{result}} ÙˆÙ„ÙƒÙ† Ø§Ù„Ø«Ù‚Ø© Ù…ØªÙˆØ³Ø·Ø© Ø¹Ù†Ø¯ {{confidence}}%. ÙƒÙ† Ø­Ø°Ø±Ø§Ù‹ ÙˆØ§Ø³ØªØ®Ø¯Ù… Ø§Ø³ØªØ±Ø§ØªÙŠØ¬ÙŠØªÙƒ.",
          "Ø§Ù„ØªÙ†Ø¨Ø¤ ÙŠØ´ÙŠØ± Ø¥Ù„Ù‰ {{result}} Ø¨Ø«Ù‚Ø© {{confidence}}%. Ù„ÙŠØ³Øª Ù‚ÙˆÙŠØ© Ø¬Ø¯Ø§Ù‹ ÙˆÙ„ÙƒÙ†Ù‡Ø§ Ø¬ÙŠØ¯Ø©.",
          "Ø£Ø±Ù‰ Ø§Ø­ØªÙ…Ø§Ù„Ø§Ù‹ Ù„Ù€ {{result}} Ù…Ø¹ Ø«Ù‚Ø© {{confidence}}%. Ø§Ø¹ØªÙ…Ø¯ Ø¹Ù„Ù‰ Ø­Ø¯Ø³Ùƒ Ù…Ø¹ Ø§Ù„Ø¨ÙŠØ§Ù†Ø§Øª."
        ],
        weak: [
          "Ø§Ù„ØªÙ†Ø¨Ø¤ ØºÙŠØ± ÙˆØ§Ø¶Ø­ Ø­Ø§Ù„ÙŠØ§Ù‹. Ø§Ù„Ø«Ù‚Ø© Ù…Ù†Ø®ÙØ¶Ø© Ø¹Ù†Ø¯ {{confidence}}%. Ø£Ù†ØµØ­ Ø¨Ø§Ù„Ø§Ù†ØªØ¸Ø§Ø±.",
          "Ù„Ø§ Ø£Ø±Ù‰ Ø¥Ø´Ø§Ø±Ø© Ù‚ÙˆÙŠØ©. Ø§Ù„Ø«Ù‚Ø© {{confidence}}% ÙÙ‚Ø·. Ø±Ø¨Ù…Ø§ Ù†Ø­ØªØ§Ø¬ Ù„Ù…Ø²ÙŠØ¯ Ù…Ù† Ø§Ù„Ø¨ÙŠØ§Ù†Ø§Øª.",
          "Ø§Ù„Ø³ÙˆÙ‚ Ù…ØªÙ‚Ù„Ø¨ Ù‚Ù„ÙŠÙ„Ø§Ù‹. Ø§Ù„ØªÙ†Ø¨Ø¤ ØºÙŠØ± Ù…Ø¤ÙƒØ¯ Ø¨Ø«Ù‚Ø© {{confidence}}%. Ø§Ù„ØµØ¨Ø± ÙØ¶ÙŠÙ„Ø©!"
        ]
      },
      
      advice: [
        "Ø§Ø³Ù…Ø¹ Ù†ØµÙŠØ­ØªÙŠ: ØªÙˆÙ‚Ù Ø¹Ù†Ø¯ Ø«Ù„Ø§Ø«Ø© Ù…ÙƒØ§Ø³Ø¨ Ù…ØªØªØ§Ù„ÙŠØ© ÙˆØ§Ø­ØªÙØ¸ Ø¨Ø£Ø±Ø¨Ø§Ø­Ùƒ!",
        "ÙƒØµØ¯ÙŠÙ‚Ø© Ù†Ø§ØµØ­Ø©ØŒ Ø£Ù‚ÙˆÙ„ Ù„Ùƒ: Ø®Ø§Ø·Ø± ÙÙ‚Ø· Ø¨Ù…Ø§ ØªØ³ØªØ·ÙŠØ¹ Ø®Ø³Ø§Ø±ØªÙ‡.",
        "Ù†ØµÙŠØ­Ø© Ø°Ù‡Ø¨ÙŠØ©: Ø±Ø§Ù‚Ø¨ Ø§Ù„Ù†Ù…Ø· Ø§Ù„Ø¹Ø§Ù…ØŒ Ù„Ø§ ØªØ±ÙƒØ² Ø¹Ù„Ù‰ Ø¬ÙˆÙ„Ø© ÙˆØ§Ø­Ø¯Ø© ÙÙ‚Ø·.",
        "ÙƒÙ…Ø³Ø§Ø¹Ø¯Ø© Ø°ÙƒÙŠØ©ØŒ Ø£Ù†ØµØ­Ùƒ: Ø®Ø° Ø§Ø³ØªØ±Ø§Ø­Ø© Ø¨Ø¹Ø¯ Ø®Ù…Ø³ Ø¬ÙˆÙ„Ø§Øª Ù„Ù„Ø­ÙØ§Ø¸ Ø¹Ù„Ù‰ ØªØ±ÙƒÙŠØ²Ùƒ.",
        "Ø§Ø³Ù…Ø¹ ÙƒÙ„Ø§Ù…ÙŠ: Ø¥Ø¯Ø§Ø±Ø© Ø§Ù„Ù…Ø§Ù„ Ø£Ù‡Ù… Ù…Ù† Ø§Ù„ØªÙ†Ø¨Ø¤ Ø§Ù„Ø¯Ù‚ÙŠÙ‚. Ù„Ø§ ØªÙ‡Ù…Ù„ Ù‡Ø°Ù‡ Ø§Ù„Ù‚Ø§Ø¹Ø¯Ø©!",
        "Ù†ØµÙŠØ­ØªÙŠ Ù„Ùƒ: Ø§Ø³ØªØ®Ø¯Ù… ÙˆÙ‚Ù Ø§Ù„Ø®Ø³Ø§Ø±Ø© Ø¯Ø§Ø¦Ù…Ø§Ù‹. Ø«Ù‚ Ø¨ÙŠØŒ Ø³ØªÙ†Ù‚Ø°Ùƒ ÙƒØ«ÙŠØ±Ø§Ù‹!"
      ],
      
      encouragement: [
        "Ø£Ù†Øª ØªØ³ÙŠØ± Ø¹Ù„Ù‰ Ø§Ù„Ø·Ø±ÙŠÙ‚ Ø§Ù„ØµØ­ÙŠØ­! Ø§Ø³ØªÙ…Ø± ÙÙŠ Ø§Ù„ØªØ¹Ù„Ù… ÙˆØ§Ù„ØªØ­Ù„ÙŠÙ„.",
        "Ø£Ø±Ù‰ ØªØ·ÙˆØ±Ø§Ù‹ ÙÙŠ ØªØ­Ù„ÙŠÙ„Ùƒ. Ù‡Ø°Ø§ Ø±Ø§Ø¦Ø¹!",
        "ÙƒÙ„ Ø¬ÙˆÙ„Ø© Ø¬Ø¯ÙŠØ¯Ø© Ù‡ÙŠ ÙØ±ØµØ© Ù„Ù„ØªØ¹Ù„Ù…. Ø£Ù†Øª ØªØªØ­Ø³Ù†!",
        "Ø§Ù„Ø«Ø¨Ø§Øª ÙˆØ§Ù„Ø§Ø³ØªÙ…Ø±Ø§Ø±ÙŠØ© Ù‡Ù…Ø§ Ø³Ø± Ø§Ù„Ù†Ø¬Ø§Ø­. Ø£Ù†Øª Ø¹Ù„Ù‰ Ø§Ù„Ø·Ø±ÙŠÙ‚ Ø§Ù„ØµØ­ÙŠØ­!",
        "Ø£Ù†Ø§ ÙØ®ÙˆØ±Ø© Ø¨ØªØ±ÙƒÙŠØ²Ùƒ! Ø§Ø³ØªÙ…Ø± Ø¹Ù„Ù‰ Ù‡Ø°Ø§ Ø§Ù„Ù…Ù†ÙˆØ§Ù„.",
        "Ø§Ù„ØªØ¹Ù„Ù… Ø§Ù„Ù…Ø³ØªÙ…Ø± Ù‡Ùˆ Ù…ÙØªØ§Ø­ Ø§Ù„Ù†Ø¬Ø§Ø­. ÙˆØ£Ù†Øª ØªÙØ¹Ù„ Ø°Ù„Ùƒ Ø¨Ø´ÙƒÙ„ Ù…Ù…ØªØ§Ø²!"
      ],
      
      winReactions: [
        "ğŸ‰ Ù…Ø¨Ø±ÙˆÙƒ! ÙÙˆØ² Ø±Ø§Ø¦Ø¹! Ø§Ø³ØªÙ…Ø± ÙÙŠ Ù†ÙØ³ Ø§Ù„Ø§Ø³ØªØ±Ø§ØªÙŠØ¬ÙŠØ© Ø§Ù„Ø°ÙƒÙŠØ©!",
        "ğŸ† Ø£Ø­Ø³Ù†Øª! ØªÙ†Ø¨Ø¤ ØµØ­ÙŠØ­! Ù‡Ø°Ø§ Ø¯Ù„ÙŠÙ„ Ø¹Ù„Ù‰ ØªØ­Ù„ÙŠÙ„Ùƒ Ø§Ù„Ø¯Ù‚ÙŠÙ‚.",
        "âœ¨ ÙÙˆØ² Ù…Ù…ØªØ§Ø²! Ø£Ù†Ø§ Ø³Ø¹ÙŠØ¯Ø© Ù„Ùƒ! Ø­Ø§ÙØ¸ Ø¹Ù„Ù‰ Ù‡Ø°Ø§ Ø§Ù„Ø²Ø®Ù….",
        "âœ… Ù†Ø¬Ø§Ø­ Ø¨Ø§Ù‡Ø±! Ø£Ù†Øª ØªØªØ¹Ù„Ù… Ø¨Ø³Ø±Ø¹Ø©. Ø§Ø³ØªÙ…Ø± Ù‡ÙƒØ°Ø§!"
      ],
      
      lossReactions: [
        "ğŸ’ª Ù„Ø§ ØªÙ‚Ù„Ù‚ ØµØ¯ÙŠÙ‚ÙŠ! Ø§Ù„Ø®Ø³Ø§Ø±Ø© Ø¬Ø²Ø¡ Ù…Ù† Ø§Ù„Ù„Ø¹Ø¨Ø©. ØªØ¹Ù„Ù… Ù…Ù†Ù‡Ø§ ÙˆØ§Ø³ØªÙ…Ø±.",
        "ğŸ”„ ÙƒÙ„Ù†Ø§ Ù†Ø®Ø³Ø± Ø£Ø­ÙŠØ§Ù†Ø§Ù‹. Ø§Ù„Ù…Ù‡Ù… Ù‡Ùˆ Ø§Ù„ØªØ¹Ù„Ù… ÙˆØ§Ù„Ù…Ø¶ÙŠ Ù‚Ø¯Ù…Ø§Ù‹.",
        "ğŸŒŸ Ù„Ø§ ØªÙŠØ£Ø³! Ø­ØªÙ‰ Ø§Ù„Ù…Ø­ØªØ±ÙÙŠÙ† ÙŠØ®Ø³Ø±ÙˆÙ†. Ø±ÙƒØ² Ø¹Ù„Ù‰ Ø§Ù„ØµÙˆØ±Ø© Ø§Ù„ÙƒØ¨ÙŠØ±Ø©.",
        "ğŸ“ˆ Ø§Ù„Ø®Ø³Ø§Ø¦Ø± Ù…Ø¤Ù‚ØªØ©ØŒ Ù„ÙƒÙ† Ø§Ù„ØªØ¹Ù„Ù… Ø¯Ø§Ø¦Ù…. Ø£Ù†Ø§ Ù…Ø¹Ùƒ ÙÙŠ Ù‡Ø°Ù‡ Ø§Ù„Ø±Ø­Ù„Ø©!"
      ],
      
      entrySignals: [
        "ğŸš¦ Ø§Ù†ØªØ¨Ù‡! Ø¥Ø´Ø§Ø±Ø© Ø¯Ø®ÙˆÙ„ Ù‚ÙˆÙŠØ© Ø§Ù„Ø¢Ù†! Ø§Ù„Ù†Ù…Ø· ÙˆØ§Ø¶Ø­ ÙˆØ§Ù„ÙØ±ØµØ© Ù…ÙˆØ§ØªÙŠØ©.",
        "âœ… Ø§Ù„ÙˆÙ‚Øª Ù…Ù†Ø§Ø³Ø¨ Ù„Ù„Ø¯Ø®ÙˆÙ„! Ø§Ù„ØªØ­Ù„ÙŠÙ„ ÙŠØ¸Ù‡Ø± Ø¥Ø´Ø§Ø±Ø© Ø¥ÙŠØ¬Ø§Ø¨ÙŠØ©.",
        "ğŸ¯ Ù‡Ø°Ù‡ ÙØ±ØµØ© Ø¬ÙŠØ¯Ø© Ù„Ù„Ø¯Ø®ÙˆÙ„! Ø§Ù„Ø«Ù‚Ø© ÙÙŠ Ø§Ù„ØªÙ†Ø¨Ø¤ Ù…Ø¹Ù‚ÙˆÙ„Ø©.",
        "ğŸŒŸ Ø§Ù„Ø¸Ø±ÙˆÙ Ù…Ù†Ø§Ø³Ø¨Ø© Ù„Ù„Ø¨Ø¯Ø§ÙŠØ©! Ø£Ø¯Ø®Ù„ Ø¨Ø­ÙƒÙ…Ø© ÙˆØ«Ù‚Ø©."
      ],
      
      exitSignals: [
        "âš ï¸ ØµØ¯ÙŠÙ‚ÙŠØŒ ÙˆÙ‚Øª Ø§Ù„Ø®Ø±ÙˆØ¬! Ø­Ø§ÙØ¸ Ø¹Ù„Ù‰ Ø£Ø±Ø¨Ø§Ø­Ùƒ Ù‚Ø¨Ù„ Ø§Ù„ØªÙ‚Ù„Ø¨Ø§Øª.",
        "ğŸ›‘ Ø¥Ø´Ø§Ø±Ø© Ø®Ø±ÙˆØ¬ Ù…Ù‡Ù…Ø©! Ø®Ø° Ø£Ø±Ø¨Ø§Ø­Ùƒ Ø§Ù„Ø¢Ù† Ø¨ÙƒÙ„ Ø«Ù‚Ø©.",
        "ğŸ’ Ù‡Ø°Ø§ Ù‡Ùˆ Ø§Ù„ÙˆÙ‚Øª Ø§Ù„Ù…Ø«Ø§Ù„ÙŠ Ù„Ù„Ø®Ø±ÙˆØ¬! Ø§Ø­ØªÙØ¸ Ø¨Ù…ÙƒØ§Ø³Ø¨Ùƒ.",
        "ğŸ“‰ Ø£Ù†ØµØ­ Ø¨Ø§Ù„Ø®Ø±ÙˆØ¬ ÙÙˆØ±Ø§Ù‹! Ù…Ø¤Ø´Ø±Ø§Øª Ø§Ù„Ø®Ø·Ø± ÙÙŠ Ø§Ø²Ø¯ÙŠØ§Ø¯."
      ],
      
      analysis: [
        "Ø¯Ø¹Ù†ÙŠ Ø£Ø­Ù„Ù„ Ù„Ùƒ Ø§Ù„ÙˆØ¶Ø¹ Ø§Ù„Ø­Ø§Ù„ÙŠ... Ø£Ø±Ù‰ Ø£Ù† Ø§Ù„Ù†Ù…Ø· ÙŠÙ…ÙŠÙ„ Ù†Ø­Ùˆ {{trend}}.",
        "Ø¨Ø¹Ø¯ Ø¯Ø±Ø§Ø³Ø© Ø§Ù„Ø¨ÙŠØ§Ù†Ø§ØªØŒ Ø£Ù„Ø§Ø­Ø¸ Ø£Ù† {{observation}}.",
        "ØªØ­Ù„ÙŠÙ„ÙŠ Ø§Ù„Ø´Ø®ØµÙŠ ÙŠÙ‚ÙˆÙ„: {{insight}}",
        "ÙƒØ®Ø¨ÙŠØ±Ø© ÙÙŠ Ø§Ù„Ø£Ù†Ù…Ø§Ø·ØŒ Ø£Ø±Ù‰ Ø£Ù† {{pattern}} ÙŠØªÙƒØ±Ø± Ø­Ø§Ù„ÙŠØ§Ù‹."
      ],
      
      jokes: [
        "Ù‡Ù„ ØªØ¹Ù„Ù… Ø£Ù† Ø§Ù„Ø¨Ø§ÙƒØ§Ø±Ø§Øª Ù…Ø«Ù„ Ø§Ù„Ø­ÙŠØ§Ø©ØŸ Ø£Ø­ÙŠØ§Ù†Ø§Ù‹ ØªØ±Ø¨Ø­ ÙˆØ£Ø­ÙŠØ§Ù†Ø§Ù‹ ØªØªØ¹Ù„Ù…! ğŸ˜„",
        "Ø¥Ø°Ø§ ÙƒØ§Ù† Ø§Ù„Ø¨Ø§ÙƒØ§Ø±Ø§Øª Ø³Ù‡Ù„Ø§Ù‹ØŒ Ù„ÙƒØ§Ù† Ø§Ù„Ø¬Ù…ÙŠØ¹ Ø£Ø«Ø±ÙŠØ§Ø¡! ğŸ²",
        "Ø§Ù„Ù…Ø³Ø§Ø¹Ø¯ Ø§Ù„Ø°ÙƒÙŠ ÙŠÙ‚ÙˆÙ„: ØªÙˆÙ‚Ø¹ØŒ ØªØ­Ù„ÙŠÙ„ØŒ Ø±Ø¨Ø­ØŒ ÙƒØ±Ø±! ğŸ¤–",
        "Ø«Ù‚ØªÙƒ ÙÙŠ ØªÙ†Ø¨Ø¤Ø§ØªÙŠ Ù…Ø«Ù„ Ø«Ù‚ØªÙŠ Ø¨Ø£Ù† Ø§Ù„ÙŠÙˆÙ… Ø§Ù„ØªØ§Ù„ÙŠ Ø³ÙŠØ£ØªÙŠ! â˜€ï¸"
      ]
    };
  }

  initVoices() {
    // ØªØ­Ù…ÙŠÙ„ Ø§Ù„Ø£ØµÙˆØ§Øª Ø§Ù„Ù…ØªØ§Ø­Ø©
    const loadVoices = () => {
      this.voices = this.synth.getVoices();
      
      // Ø§Ù„Ø¨Ø­Ø« Ø¹Ù† ØµÙˆØª Ø£Ù†Ø«ÙˆÙŠ
      for (let voice of this.voices) {
        // Ø£ÙØ¶Ù„ ØµÙˆØª Ø¹Ø±Ø¨ÙŠ Ø£Ù†Ø«ÙˆÙŠ
        if (voice.lang.includes('ar') && (voice.name.includes('Female') || voice.name.includes('Woman') || voice.name.includes('Ø£Ù†Ø«Ù‰'))) {
          this.currentVoice = voice;
          break;
        }
      }
      
      // Ø¥Ø°Ø§ Ù„Ù… Ù†Ø¬Ø¯ ØµÙˆØª Ø£Ù†Ø«ÙˆÙŠ Ø¹Ø±Ø¨ÙŠØŒ Ù†Ø¨Ø­Ø« Ø¹Ù† Ø£ÙŠ ØµÙˆØª Ø¹Ø±Ø¨ÙŠ
      if (!this.currentVoice) {
        for (let voice of this.voices) {
          if (voice.lang.includes('ar')) {
            this.currentVoice = voice;
            break;
          }
        }
      }
      
      // Ø¥Ø°Ø§ Ù„Ù… Ù†Ø¬Ø¯ Ø£ÙŠ ØµÙˆØª Ø¹Ø±Ø¨ÙŠØŒ Ù†Ø£Ø®Ø° Ø£ÙˆÙ„ ØµÙˆØª Ù…ØªØ§Ø­
      if (!this.currentVoice && this.voices.length > 0) {
        this.currentVoice = this.voices[0];
      }
    };
    
    this.synth.onvoiceschanged = loadVoices;
    loadVoices();
  }

  speak(text, onEnd = null) {
    if (!this.isActive || !this.synth) return;
    
    // Ø¥ÙŠÙ‚Ø§Ù Ø£ÙŠ ÙƒÙ„Ø§Ù… Ø³Ø§Ø¨Ù‚
    this.stopSpeaking();
    
    this.isSpeaking = true;
    this.updateVoiceStatus();
    
    const utterance = new SpeechSynthesisUtterance(text);
    
    // Ø¥Ø¹Ø¯Ø§Ø¯Ø§Øª Ø§Ù„ØµÙˆØª
    if (this.currentVoice) {
      utterance.voice = this.currentVoice;
    }
    
    utterance.lang = 'ar-SA';
    utterance.rate = 0.9; // Ø³Ø±Ø¹Ø© Ù…ØªÙˆØ³Ø·Ø©
    utterance.pitch = 1.2; // Ù†Ø¨Ø±Ø© Ø£Ù†Ø«ÙˆÙŠØ© Ø£Ø¹Ù„Ù‰ Ù‚Ù„ÙŠÙ„Ø§Ù‹
    utterance.volume = 1;
    
    // Ø£Ø­Ø¯Ø§Ø« Ø§Ù„ØµÙˆØª
    utterance.onstart = () => {
      this.isSpeaking = true;
      this.updateVoiceStatus();
      this.showMessage(text);
    };
    
    utterance.onend = () => {
      this.isSpeaking = false;
      this.updateVoiceStatus();
      this.lastSpokenTime = Date.now();
      this.conversationCount++;
      this.updateConversationCount();
      
      if (onEnd) onEnd();
    };
    
    utterance.onerror = (event) => {
      console.error('Ø®Ø·Ø£ ÙÙŠ Ø§Ù„ØµÙˆØª:', event);
      this.isSpeaking = false;
      this.updateVoiceStatus();
      this.showMessage("Ø¹Ø°Ø±Ø§Ù‹ØŒ Ø­Ø¯Ø« Ø®Ø·Ø£ ÙÙŠ Ø§Ù„ØµÙˆØª. Ù„ÙƒÙ† Ø§Ù„Ù†ØµÙŠØ­Ø© Ù‡ÙŠ: " + text);
    };
    
    this.synth.speak(utterance);
    return utterance;
  }

  stopSpeaking() {
    if (this.synth && this.synth.speaking) {
      this.synth.cancel();
      this.isSpeaking = false;
      this.updateVoiceStatus();
    }
  }

  speakPrediction() {
    if (!this.isActive) {
      this.showMessage("ÙŠØ¬Ø¨ ØªÙØ¹ÙŠÙ„ Ø§Ù„Ù…Ø³Ø§Ø¹Ø¯Ø© Ø§Ù„ØµÙˆØªÙŠØ© Ø£ÙˆÙ„Ø§Ù‹!");
      return;
    }
    
    const prediction = enhancedPredict();
    if (!prediction || prediction.final === 'â€”') {
      this.speak("Ø§Ù„ØªÙ†Ø¨Ø¤ Ø§Ù„Ø­Ø§Ù„ÙŠ ØºÙŠØ± ÙˆØ§Ø¶Ø­. Ø§Ù„Ø«Ù‚Ø© Ù…Ù†Ø®ÙØ¶Ø© Ø¬Ø¯Ø§Ù‹. Ø£Ù†ØµØ­Ùƒ Ø¨Ø§Ù„Ø§Ù†ØªØ¸Ø§Ø± Ø­ØªÙ‰ ØªØ¸Ù‡Ø± Ø¥Ø´Ø§Ø±Ø© Ø£Ù‚ÙˆÙ‰.");
      return;
    }
    
    const resultText = prediction.final === 'P' ? 'Ø§Ù„Ù„Ø§Ø¹Ø¨' : 
                      prediction.final === 'B' ? 'Ø§Ù„Ù…ØµØ±ÙÙŠ' : 'Ø§Ù„ØªØ¹Ø§Ø¯Ù„';
    
    const confidence = prediction.confidence || 0;
    
    let speech;
    if (confidence >= 70) {
      speech = this.getRandomResponse('predictions.strong');
    } else if (confidence >= 40) {
      speech = this.getRandomResponse('predictions.moderate');
    } else {
      speech = this.getRandomResponse('predictions.weak');
    }
    
    speech = speech.replace('{{result}}', resultText)
                   .replace('{{confidence}}', confidence.toFixed(0));
    
    // Ø¥Ø¶Ø§ÙØ© Ù†ØµÙŠØ­Ø© Ø­Ø³Ø¨ Ù…Ø³ØªÙˆÙ‰ Ø§Ù„Ø«Ù‚Ø©
    let advice = "";
    if (confidence >= 70) {
      advice = "Ù‡Ø°Ù‡ Ø¥Ø´Ø§Ø±Ø© Ù‚ÙˆÙŠØ©! ÙŠÙ…ÙƒÙ†Ùƒ Ø§Ù„Ø¯Ø®ÙˆÙ„ Ø¨Ø«Ù‚Ø© Ù…Ø¹ØªØ¯Ù„Ø©. ÙˆÙ„ÙƒÙ† ØªØ°ÙƒØ±ØŒ Ø§Ø³ØªØ®Ø¯Ù… ÙˆÙ‚Ù Ø§Ù„Ø®Ø³Ø§Ø±Ø© Ø¯Ø§Ø¦Ù…Ø§Ù‹!";
    } else if (confidence >= 40) {
      advice = "Ù‡Ø°Ù‡ Ø¥Ø´Ø§Ø±Ø© Ù…ØªÙˆØ³Ø·Ø©. Ø£Ø¯Ø®Ù„ Ø¨Ø­Ø°Ø± ÙˆÙ„Ø§ ØªØ®Ø§Ø·Ø± ÙƒØ«ÙŠØ±Ø§Ù‹. Ø§Ù„Ù…Ø±Ø§Ù‚Ø¨Ø© Ø£ÙˆÙ„Ø§Ù‹ Ø«Ù… Ø§Ù„ØªØ­Ø±Ùƒ!";
    } else {
      advice = "Ø§Ù„ØµØ¨Ø± ÙØ¶ÙŠÙ„Ø©! Ø§Ù†ØªØ¸Ø± Ø­ØªÙ‰ ØªØªØ­Ø³Ù† Ø§Ù„Ø¥Ø´Ø§Ø±Ø©. Ø§Ù„Ù…Ø±Ø§Ù‚Ø¨Ø© Ø§Ù„Ø¢Ù† Ø£ÙØ¶Ù„ Ù…Ù† Ø§Ù„ØªØ³Ø±Ø¹.";
    }
    
    const fullSpeech = speech + " " + advice;
    this.speak(fullSpeech);
  }

  giveAdvice() {
    if (!this.isActive) {
      this.showMessage("ÙŠØ¬Ø¨ ØªÙØ¹ÙŠÙ„ Ø§Ù„Ù…Ø³Ø§Ø¹Ø¯Ø© Ø§Ù„ØµÙˆØªÙŠØ© Ø£ÙˆÙ„Ø§Ù‹!");
      return;
    }
    
    const advice = this.getRandomResponse('advice');
    const encouragement = this.getRandomResponse('encouragement');
    
    // Ø¥Ø¶Ø§ÙØ© Ù†ÙƒØªØ© Ø¨ÙŠÙ† Ø§Ù„Ø­ÙŠÙ† ÙˆØ§Ù„Ø¢Ø®Ø±
    let joke = "";
    if (Math.random() > 0.7) {
      joke = " " + this.getRandomResponse('jokes');
    }
    
    const fullSpeech = advice + " " + encouragement + joke;
    this.speak(fullSpeech);
  }

  giveEntrySignal() {
    if (!this.isActive) return;
    
    if (state.rounds.length < 5) {
      this.speak("Ø£Ø­ØªØ§Ø¬ Ø¥Ù„Ù‰ Ø®Ù…Ø³ Ø¬ÙˆÙ„Ø§Øª Ø¹Ù„Ù‰ Ø§Ù„Ø£Ù‚Ù„ Ù„Ø£Ø¹Ø·ÙŠÙƒ ØªØ­Ù„ÙŠÙ„Ø§Ù‹ Ø¯Ù‚ÙŠÙ‚Ø§Ù‹ Ù„Ù„Ø¯Ø®ÙˆÙ„. Ø§Ù„Ø±Ø¬Ø§Ø¡ Ø¥Ø¯Ø®Ø§Ù„ Ø§Ù„Ù…Ø²ÙŠØ¯ Ù…Ù† Ø§Ù„Ø¬ÙˆÙ„Ø§Øª Ø£ÙˆÙ„Ø§Ù‹.");
      return;
    }
    
    const analysis = this.analyzeEntryConditions();
    
    let speech;
    if (analysis.shouldEnter) {
      speech = this.getRandomResponse('entrySignals');
    } else {
      speech = `Ø§Ù„ÙˆØ¶Ø¹ Ø§Ù„Ø­Ø§Ù„ÙŠ ØºÙŠØ± Ù…Ù†Ø§Ø³Ø¨ Ù„Ù„Ø¯Ø®ÙˆÙ„. ${analysis.reason} Ø£Ù†ØµØ­Ùƒ Ø¨Ø§Ù„Ø§Ù†ØªØ¸Ø§Ø± Ù‚Ù„ÙŠÙ„Ø§Ù‹.`;
    }
    
    this.speak(speech);
  }

  analyzeEntryConditions() {
    const rounds = state.rounds;
    const recent = rounds.slice(-8);
    
    if (recent.length < 5) {
      return { shouldEnter: false, reason: "Ù„Ø§ ØªÙˆØ¬Ø¯ Ø¨ÙŠØ§Ù†Ø§Øª ÙƒØ§ÙÙŠØ©" };
    }
    
    // ØªØ­Ù„ÙŠÙ„ Ø§Ù„Ø§Ø³ØªÙ‚Ø±Ø§Ø±
    let changes = 0;
    for (let i = 1; i < recent.length; i++) {
      if (recent[i] !== recent[i-1]) changes++;
    }
    const stability = 1 - (changes / (recent.length - 1));
    
    // ØªØ­Ù„ÙŠÙ„ Ø§Ù„Ù†Ù…Ø·
    const lastThree = recent.slice(-3);
    const isStreak = lastThree[0] === lastThree[1] && lastThree[1] === lastThree[2];
    
    const shouldEnter = stability > 0.7 || isStreak;
    
    let reason = stability > 0.7 ? "Ø§Ù„Ø§Ø³ØªÙ‚Ø±Ø§Ø± Ù…Ø±ØªÙØ¹" : "Ù‡Ù†Ø§Ùƒ ØªÙƒØ±Ø§Ø± ÙÙŠ Ø§Ù„Ù†Ù…Ø·";
    
    return { shouldEnter, reason };
  }

  giveExitSignal() {
    if (!this.isActive) return;
    
    if (state.rounds.length === 0) {
      this.speak("Ù„Ø§ ØªÙˆØ¬Ø¯ Ø¬ÙˆÙ„Ø§Øª ÙƒØ§ÙÙŠØ© Ù„ØªØ­Ù„ÙŠÙ„ Ø¥Ø´Ø§Ø±Ø§Øª Ø§Ù„Ø®Ø±ÙˆØ¬. Ø§Ø¨Ø¯Ø£ Ø¨Ø§Ù„Ù„Ø¹Ø¨ Ø£ÙˆÙ„Ø§Ù‹!");
      return;
    }
    
    const analysis = this.analyzeExitConditions();
    
    let speech;
    if (analysis.shouldExit) {
      speech = this.getRandomResponse('exitSignals');
    } else {
      speech = `Ù„Ø§ ØªÙˆØ¬Ø¯ Ø¥Ø´Ø§Ø±Ø© Ø®Ø±ÙˆØ¬ Ù‚ÙˆÙŠØ© Ø­Ø§Ù„ÙŠØ§Ù‹. ${analysis.reason} ØªØ§Ø¨Ø¹ Ø§Ù„Ù„Ø¹Ø¨ Ø¨Ø­ÙƒÙ…Ø©!`;
    }
    
    this.speak(speech);
  }

  analyzeExitConditions() {
    const rounds = state.rounds;
    const recent = rounds.slice(-6);
    
    if (recent.length < 3) {
      return { shouldExit: false, reason: "Ø¨ÙŠØ§Ù†Ø§Øª ØºÙŠØ± ÙƒØ§ÙÙŠØ©" };
    }
    
    // ØªØ­Ù„ÙŠÙ„ Ø§Ù„ØªÙ‚Ù„Ø¨
    let changes = 0;
    for (let i = 1; i < recent.length; i++) {
      if (recent[i] !== recent[i-1]) changes++;
    }
    const volatility = changes / (recent.length - 1);
    
    // ØªØ­Ù„ÙŠÙ„ Ø§Ù„Ù†Ù…Ø·
    const patterns = [];
    for (let i = 2; i < recent.length; i++) {
      if (recent[i] !== recent[i-1] && recent[i-1] !== recent[i-2]) {
        patterns.push('alternating');
      }
    }
    
    const hasAlternation = patterns.length > 0;
    const shouldExit = volatility > 0.7 || hasAlternation;
    
    let reason = volatility > 0.7 ? "Ù‡Ù†Ø§Ùƒ ØªÙ‚Ù„Ø¨ ÙƒØ¨ÙŠØ±" : "Ø§Ù„Ù†Ù…Ø· ÙŠØªÙ†Ø§ÙˆØ¨ Ø¨Ø´ÙƒÙ„ ÙƒØ¨ÙŠØ±";
    
    return { shouldExit, reason };
  }

  giveDetailedAnalysis() {
    if (!this.isActive) return;
    
    if (state.rounds.length < 3) {
      this.speak("Ø£Ø­ØªØ§Ø¬ Ø¥Ù„Ù‰ Ø«Ù„Ø§Ø« Ø¬ÙˆÙ„Ø§Øª Ø¹Ù„Ù‰ Ø§Ù„Ø£Ù‚Ù„ Ù„Ø£Ø¹Ø·ÙŠÙƒ ØªØ­Ù„ÙŠÙ„Ø§Ù‹ Ù…ÙØµÙ„Ø§Ù‹. Ø§Ù„Ø±Ø¬Ø§Ø¡ Ø¥Ø¯Ø®Ø§Ù„ Ø§Ù„Ù…Ø²ÙŠØ¯ Ù…Ù† Ø§Ù„Ø¬ÙˆÙ„Ø§Øª.");
      return;
    }
    
    const recent = state.rounds.slice(-10);
    const pCount = recent.filter(r => r === 'P').length;
    const bCount = recent.filter(r => r === 'B').length;
    const tCount = recent.filter(r => r === 'T').length;
    
    const total = recent.length;
    const pPercent = total > 0 ? Math.round((pCount / total) * 100) : 0;
    const bPercent = total > 0 ? Math.round((bCount / total) * 100) : 0;
    const tPercent = total > 0 ? Math.round((tCount / total) * 100) : 0;
    
    let trend = "";
    if (pCount > bCount && pCount > tCount) {
      trend = "Ø§Ù„Ø§ØªØ¬Ø§Ù‡ Ø§Ù„Ø¹Ø§Ù… ÙŠÙ…ÙŠÙ„ Ù†Ø­Ùˆ Ø§Ù„Ù„Ø§Ø¹Ø¨";
    } else if (bCount > pCount && bCount > tCount) {
      trend = "Ø§Ù„Ø§ØªØ¬Ø§Ù‡ Ø§Ù„Ø¹Ø§Ù… ÙŠÙ…ÙŠÙ„ Ù†Ø­Ùˆ Ø§Ù„Ù…ØµØ±ÙÙŠ";
    } else {
      trend = "Ø§Ù„Ø§ØªØ¬Ø§Ù‡ Ù…ØªÙˆØ§Ø²Ù† Ø¨ÙŠÙ† Ø§Ù„Ù„Ø§Ø¹Ø¨ ÙˆØ§Ù„Ù…ØµØ±ÙÙŠ";
    }
    
    const analysis = this.getRandomResponse('analysis')
      .replace('{{trend}}', trend)
      .replace('{{observation}}', `Ø§Ù„Ù„Ø§Ø¹Ø¨ Ø¸Ù‡Ø± ${pCount} Ù…Ø±Ø§Øª ÙˆØ§Ù„Ù…ØµØ±ÙÙŠ ${bCount} Ù…Ø±Ø§Øª`)
      .replace('{{pattern}}', pCount > bCount ? "ØªÙÙˆÙ‚ Ø§Ù„Ù„Ø§Ø¹Ø¨" : "ØªÙÙˆÙ‚ Ø§Ù„Ù…ØµØ±ÙÙŠ")
      .replace('{{insight}}', `Ø§Ù„Ø¯Ù‚Ø© Ø§Ù„Ø¹Ø§Ù…Ø© ${state.accuracyHistory.length > 0 ? state.accuracyHistory[state.accuracyHistory.length-1].toFixed(1) : 0}%`);
    
    const details = `ÙÙŠ Ø¢Ø®Ø± ${total} Ø¬ÙˆÙ„Ø§Øª: Ø§Ù„Ù„Ø§Ø¹Ø¨ ${pPercent}%ØŒ Ø§Ù„Ù…ØµØ±ÙÙŠ ${bPercent}%ØŒ Ø§Ù„ØªØ¹Ø§Ø¯Ù„ ${tPercent}%.`;
    
    const fullSpeech = analysis + " " + details + " " + this.getRandomResponse('advice');
    this.speak(fullSpeech);
  }

  reactToRound(result, predicted, isWin) {
    if (!this.isActive) return;
    
    // Ø§Ù†ØªØ¸Ø§Ø± Ù‚Ù„ÙŠÙ„Ø§Ù‹ Ù‚Ø¨Ù„ Ø§Ù„Ø±Ø¯
    setTimeout(() => {
      let reaction;
      
      if (isWin) {
        reaction = this.getRandomResponse('winReactions');
        
        // Ø¥Ø°Ø§ ÙƒØ§Ù† Ù‡Ù†Ø§Ùƒ 3 Ø£Ø±Ø¨Ø§Ø­ Ù…ØªØªØ§Ù„ÙŠØ©ØŒ Ù†Ø¹Ø·ÙŠ ØªØ­Ø°ÙŠØ±
        const winStreak = this.calculateWinStreak();
        if (winStreak >= 3) {
          reaction += ` Ù„Ø¯ÙŠÙƒ ${winStreak} Ø£Ø±Ø¨Ø§Ø­ Ù…ØªØªØ§Ù„ÙŠØ©! Ø£Ù†ØµØ­Ùƒ Ø¨Ø£Ø®Ø° Ù‚Ø³Ø· Ù…Ù† Ø§Ù„Ø±Ø§Ø­Ø© Ø£Ùˆ ØªØ®ÙÙŠØ¶ Ø§Ù„Ø±Ù‡Ø§Ù†.`;
        }
      } else {
        reaction = this.getRandomResponse('lossReactions');
        
        // Ø¥Ø°Ø§ ÙƒØ§Ù† Ù‡Ù†Ø§Ùƒ 3 Ø®Ø³Ø§Ø¦Ø± Ù…ØªØªØ§Ù„ÙŠØ©ØŒ Ù†Ø¹Ø·ÙŠ ØªØ´Ø¬ÙŠØ¹
        const lossStreak = this.calculateLossStreak();
        if (lossStreak >= 3) {
          reaction += ` Ù„Ø¯ÙŠÙƒ ${lossStreak} Ø®Ø³Ø§Ø¦Ø± Ù…ØªØªØ§Ù„ÙŠØ©. Ø±Ø¨Ù…Ø§ Ø­Ø§Ù† Ø§Ù„ÙˆÙ‚Øª Ù„Ø£Ø®Ø° Ø§Ø³ØªØ±Ø§Ø­Ø© Ù‚ØµÙŠØ±Ø©.`;
        }
      }
      
      this.speak(reaction);
    }, 1000);
  }

  calculateWinStreak() {
    if (!state.predictionsHistory || state.predictionsHistory.length === 0) return 0;
    
    let streak = 0;
    for (let i = state.predictionsHistory.length - 1; i >= 0; i--) {
      if (state.predictionsHistory[i].correct) {
        streak++;
      } else {
        break;
      }
    }
    
    return streak;
  }

  calculateLossStreak() {
    if (!state.predictionsHistory || state.predictionsHistory.length === 0) return 0;
    
    let streak = 0;
    for (let i = state.predictionsHistory.length - 1; i >= 0; i--) {
      if (!state.predictionsHistory[i].correct) {
        streak++;
      } else {
        break;
      }
    }
    
    return streak;
  }

  getRandomResponse(category) {
    const keys = category.split('.');
    let responses = this.knowledge;
    
    for (const key of keys) {
      responses = responses[key];
    }
    
    if (Array.isArray(responses)) {
      return responses[Math.floor(Math.random() * responses.length)];
    }
    
    return "Ø£Ù†Ø§ Ù‡Ù†Ø§ Ù„Ù…Ø³Ø§Ø¹Ø¯ØªÙƒ!";
  }

  showMessage(text) {
    const messageEl = el('currentMessage');
    if (messageEl) {
      messageEl.textContent = text;
      
      // Ø¥Ø¶Ø§ÙØ© Ø¥Ù„Ù‰ Ø³Ø¬Ù„ Ø§Ù„Ù…Ø­Ø§Ø¯Ø«Ø©
      this.addToConversationLog(text);
    }
  }

  addToConversationLog(text) {
    const logEl = el('conversationLog');
    if (!logEl) return;
    
    const time = new Date().toLocaleTimeString('ar-EG', { 
      hour: '2-digit', 
      minute: '2-digit' 
    });
    
    const item = document.createElement('div');
    item.className = 'conversation-item';
    item.innerHTML = `<strong>${this.name}:</strong> ${text} <span style="color: #bfb7a6; font-size: 10px;">${time}</span>`;
    
    logEl.appendChild(item);
    logEl.scrollTop = logEl.scrollHeight;
    
    // Ø­ÙØ¸ ÙÙŠ Ø§Ù„ØªØ§Ø±ÙŠØ®
    this.conversationHistory.push({
      speaker: this.name,
      text,
      time: new Date().toISOString()
    });
    
    // Ø§Ù„Ø­ÙØ§Ø¸ Ø¹Ù„Ù‰ Ø­Ø¬Ù… Ù…Ø¹Ù‚ÙˆÙ„ Ù„Ù„Ø³Ø¬Ù„
    if (this.conversationHistory.length > 50) {
      this.conversationHistory = this.conversationHistory.slice(-50);
      if (logEl.children.length > 10) {
        logEl.removeChild(logEl.firstChild);
      }
    }
  }

  updateVoiceStatus() {
    const dotEl = el('voiceDot');
    const statusEl = el('voiceStatusText');
    
    if (dotEl && statusEl) {
      if (this.isSpeaking) {
        dotEl.className = 'voice-dot speaking';
        statusEl.textContent = 'Ø¬Ø§Ø±ÙŠ Ø§Ù„ØªØ­Ø¯Ø«...';
      } else {
        dotEl.className = 'voice-dot';
        statusEl.textContent = 'Ø¬Ø§Ù‡Ø²Ø© Ù„Ù„ØªØ­Ø¯Ø«';
      }
    }
  }

  updateConversationCount() {
    const countEl = el('conversationCount');
    if (countEl) {
      countEl.textContent = `Ù…Ø­Ø§Ø¯Ø«Ø§Øª: ${this.conversationCount}`;
    }
  }

  updateMood() {
    const moodEl = el('assistantMood');
    if (!moodEl) return;
    
    const moods = ["Ù…ØªØ­Ù…Ø³Ø©", "Ø³Ø¹ÙŠØ¯Ø©", "Ù…Ø±Ø­Ø©", "Ø¬Ø§Ø¯Ø©", "Ù…Ù†ØªØ¨Ù‡Ø©", "ÙˆØ¯ÙˆØ¯Ø©"];
    const randomMood = moods[Math.floor(Math.random() * moods.length)];
    
    this.mood = randomMood;
    moodEl.textContent = `Ø§Ù„Ø­Ø§Ù„Ø©: ${this.mood}`;
  }

  toggle() {
    this.isActive = !this.isActive;
    
    const button = el('voiceAssistantToggle');
    if (button) {
      if (this.isActive) {
        button.classList.add('voice-assistant-active');
        button.innerHTML = '<span id="voiceIcon">ğŸ¤</span> Ø§Ù„Ù…Ø³Ø§Ø¹Ø¯Ø© Ø§Ù„ØµÙˆØªÙŠØ© <span class="voice-pulse"></span>';
        
        // ØªØ­Ø¯ÙŠØ« Ø§Ù„Ù…Ø²Ø§Ø¬
        this.updateMood();
        
        // ØªØ±Ø­ÙŠØ¨
        setTimeout(() => {
          const greeting = this.getRandomResponse('greetings');
          this.speak(greeting);
        }, 500);
        
        showToast("Ø§Ù„Ù…Ø³Ø§Ø¹Ø¯Ø© Ø§Ù„ØµÙˆØªÙŠØ© Ù…ÙØ¹Ù„Ø©! Ù†Ø§Ø¯ÙŠÙ† Ø¬Ø§Ù‡Ø²Ø© Ù„Ù„ØªØ­Ø¯Ø« Ù…Ø¹Ùƒ.");
      } else {
        button.classList.remove('voice-assistant-active');
        button.innerHTML = '<span id="voiceIcon">ğŸ¤</span> Ø§Ù„Ù…Ø³Ø§Ø¹Ø¯Ø© Ø§Ù„ØµÙˆØªÙŠØ©';
        
        this.stopSpeaking();
        this.showMessage("Ø§Ù„Ù…Ø³Ø§Ø¹Ø¯Ø© Ø§Ù„ØµÙˆØªÙŠØ© Ù…ØªÙˆÙ‚ÙØ©.");
        showToast("Ø§Ù„Ù…Ø³Ø§Ø¹Ø¯Ø© Ø§Ù„ØµÙˆØªÙŠØ© Ù…Ø¹Ø·Ù„Ø©.");
      }
    }
    
    return this.isActive;
  }

  clearConversation() {
    const logEl = el('conversationLog');
    if (logEl) {
      logEl.innerHTML = '';
    }
    
    this.conversationHistory = [];
    this.conversationCount = 0;
    this.updateConversationCount();
  }
}

// ========== Ø®ÙˆØ§Ø±Ø²Ù…ÙŠØ§Øª ØªØ¹Ù„Ù… Ø§Ù„Ø¢Ù„Ø© ==========

class SimpleKNN {
  constructor(k = 3) {
    this.k = k;
    this.trainingData = [];
    this.predictions = { correct: 0, total: 0 };
  }

  train(features, labels) {
    if (!features || !labels || features.length === 0) return;
    
    features.forEach((f, i) => {
      if (f && labels[i]) {
        this.trainingData.push({
          features: f,
          label: labels[i]
        });
      }
    });
    
    // Ø§Ù„Ø­ÙØ§Ø¸ Ø¹Ù„Ù‰ Ø­Ø¬Ù… Ù…Ø¹Ù‚ÙˆÙ„
    if (this.trainingData.length > 100) {
      this.trainingData = this.trainingData.slice(-100);
    }
  }

  predict(newFeatures) {
    if (!newFeatures || this.trainingData.length === 0) {
      return { P: 33.3, B: 33.3, T: 33.3 };
    }

    try {
      const distances = this.trainingData.map((dataPoint, index) => ({
        index,
        distance: this.euclideanDistance(newFeatures, dataPoint.features),
        label: dataPoint.label
      }));

      distances.sort((a, b) => a.distance - b.distance);
      const nearestNeighbors = distances.slice(0, this.k);
      
      const votes = { P: 0, B: 0, T: 0 };
      nearestNeighbors.forEach(n => {
        if (n.label in votes) {
          votes[n.label] += 1 / (n.distance + 1);
        }
      });

      const total = votes.P + votes.B + votes.T;
      if (total === 0) return { P: 33.3, B: 33.3, T: 33.3 };
      
      return {
        P: (votes.P / total) * 100,
        B: (votes.B / total) * 100,
        T: (votes.T / total) * 100
      };
    } catch (e) {
      console.error('KNN prediction error:', e);
      return { P: 33.3, B: 33.3, T: 33.3 };
    }
  }

  euclideanDistance(a, b) {
    if (!a || !b || a.length !== b.length) return 1000;
    
    let sum = 0;
    for (let i = 0; i < a.length; i++) {
      sum += Math.pow((a[i] || 0) - (b[i] || 0), 2);
    }
    return Math.sqrt(sum);
  }

  updateAccuracy(prediction, actual) {
    this.predictions.total++;
    if (prediction === actual) this.predictions.correct++;
  }

  getAccuracy() {
    return this.predictions.total > 0 ? 
      (this.predictions.correct / this.predictions.total) * 100 : 0;
  }
}

class SimpleLogisticRegression {
  constructor() {
    this.weights = { P: 0.1, B: 0.1, T: 0.1 };
    this.bias = 0;
    this.learningRate = 0.05;
    this.predictions = { correct: 0, total: 0 };
  }

  sigmoid(x) {
    return 1 / (1 + Math.exp(-x));
  }

  trainOne(features, label) {
    if (!features || !label || features.length === 0) return;
    
    try {
      const labelNum = { P: 0, B: 1, T: 2 }[label];
      if (labelNum === undefined) return;
      
      const score = features[0] * this.weights.P + features[1] * this.weights.B + features[2] * this.weights.T + this.bias;
      const prediction = this.sigmoid(score);
      const error = (labelNum / 2) - prediction;
      
      this.weights.P += this.learningRate * error * features[0];
      this.weights.B += this.learningRate * error * features[1];
      this.weights.T += this.learningRate * error * features[2];
      this.bias += this.learningRate * error;
    } catch (e) {
      console.error('Logistic regression training error:', e);
    }
  }

  predict(features) {
    if (!features || features.length === 0) {
      return { P: 33.3, B: 33.3, T: 33.3 };
    }
    
    try {
      const pScore = this.sigmoid(features[0] * this.weights.P + this.bias);
      const bScore = this.sigmoid(features[1] * this.weights.B + this.bias);
      const tScore = this.sigmoid(features[2] * this.weights.T + this.bias);
      
      const total = pScore + bScore + tScore;
      if (total === 0) return { P: 33.3, B: 33.3, T: 33.3 };
      
      return {
        P: (pScore / total) * 100,
        B: (bScore / total) * 100,
        T: (tScore / total) * 100
      };
    } catch (e) {
      console.error('Logistic regression prediction error:', e);
      return { P: 33.3, B: 33.3, T: 33.3 };
    }
  }

  updateAccuracy(prediction, actual) {
    this.predictions.total++;
    if (prediction === actual) this.predictions.correct++;
  }

  getAccuracy() {
    return this.predictions.total > 0 ? 
      (this.predictions.correct / this.predictions.total) * 100 : 0;
  }
}

class EnsembleModel {
  constructor() {
    this.models = {
      knn: new SimpleKNN(5),
      logistic: new SimpleLogisticRegression()
    };
    this.weights = { knn: 0.5, logistic: 0.5 };
    this.predictions = { correct: 0, total: 0 };
  }

  train(features, label) {
    if (!features || !label) return;
    
    try {
      this.models.knn.train([features], [label]);
      this.models.logistic.trainOne(features, label);
      
      const knnAcc = this.models.knn.getAccuracy();
      const logisticAcc = this.models.logistic.getAccuracy();
      
      const totalAcc = knnAcc + logisticAcc;
      if (totalAcc > 0) {
        this.weights.knn = knnAcc / totalAcc;
        this.weights.logistic = logisticAcc / totalAcc;
      }
    } catch (e) {
      console.error('Ensemble training error:', e);
    }
  }

  predict(features) {
    if (!features) return { P: 33.3, B: 33.3, T: 33.3 };
    
    try {
      const knnPred = this.models.knn.predict(features);
      const logisticPred = this.models.logistic.predict(features);
      
      return {
        P: (knnPred.P * this.weights.knn + logisticPred.P * this.weights.logistic),
        B: (knnPred.B * this.weights.knn + logisticPred.B * this.weights.logistic),
        T: (knnPred.T * this.weights.knn + logisticPred.T * this.weights.logistic)
      };
    } catch (e) {
      console.error('Ensemble prediction error:', e);
      return { P: 33.3, B: 33.3, T: 33.3 };
    }
  }

  updateAccuracy(prediction, actual) {
    this.predictions.total++;
    if (prediction === actual) this.predictions.correct++;
    
    this.models.knn.updateAccuracy(prediction, actual);
    this.models.logistic.updateAccuracy(prediction, actual);
  }

  getAccuracy() {
    return this.predictions.total > 0 ? 
      (this.predictions.correct / this.predictions.total) * 100 : 0;
  }
}

class BaccaratMachineLearning {
  constructor() {
    this.models = {
      knn: new SimpleKNN(5),
      logistic: new SimpleLogisticRegression(),
      ensemble: new EnsembleModel()
    };
    this.activeModel = 'ensemble';
    this.featureHistory = [];
    this.mlPredictions = [];
    this.isEnabled = true;
    this.trainingData = [];
  }

  extractFeatures(rounds, windowSize) {
    if (!rounds || rounds.length < windowSize) return null;
    
    try {
      const recent = rounds.slice(-windowSize);
      const pRatio = recent.filter(r => r === 'P').length / windowSize;
      const bRatio = recent.filter(r => r === 'B').length / windowSize;
      const tRatio = recent.filter(r => r === 'T').length / windowSize;
      
      let pStreak = 0, bStreak = 0;
      for (let i = recent.length - 1; i >= 0; i--) {
        if (recent[i] === 'P') pStreak++; else break;
      }
      for (let i = recent.length - 1; i >= 0; i--) {
        if (recent[i] === 'B') bStreak++; else break;
      }
      
      const volatility = this.calculateVolatility(recent);
      const patternType = this.getPatternType(recent);
      
      return [
        pRatio, bRatio, tRatio,
        pStreak / windowSize,
        bStreak / windowSize,
        recent[recent.length - 1] === recent[recent.length - 2] ? 1 : 0,
        volatility,
        patternType
      ];
    } catch (e) {
      console.error('Feature extraction error:', e);
      return null;
    }
  }

  calculateVolatility(rounds) {
    if (rounds.length < 2) return 0;
    let changes = 0;
    for (let i = 1; i < rounds.length; i++) {
      if (rounds[i] !== rounds[i-1]) changes++;
    }
    return changes / (rounds.length - 1);
  }

  getPatternType(rounds) {
    if (rounds.length < 3) return 0;
    const lastThree = rounds.slice(-3);
    if (lastThree[0] === lastThree[1] && lastThree[1] === lastThree[2]) return 1;
    if (lastThree[0] !== lastThree[1] && lastThree[1] !== lastThree[2]) return 2;
    return 0;
  }

  updateModel(rounds, windowSize, actualResult) {
    if (!this.isEnabled || !rounds || !actualResult) return;
    
    const features = this.extractFeatures(rounds, windowSize);
    if (!features) return;
    
    try {
      this.featureHistory.push({ features, label: actualResult, timestamp: Date.now() });
      
      if (this.featureHistory.length > 100) {
        this.featureHistory = this.featureHistory.slice(-100);
      }
      
      if (this.featureHistory.length > 5) {
        const trainingBatch = this.featureHistory.slice(-10);
        
        trainingBatch.forEach(({ features, label }) => {
          if (features && label) {
            this.models.knn.train([features], [label]);
            this.models.logistic.trainOne(features, label);
            this.models.ensemble.train(features, label);
          }
        });
      }
    } catch (e) {
      console.error('ML update error:', e);
    }
  }

  predict(rounds, windowSize) {
    if (!this.isEnabled || !rounds || rounds.length < windowSize) {
      return null;
    }
    
    const features = this.extractFeatures(rounds, windowSize);
    if (!features) return null;
    
    try {
      let prediction;
      switch(this.activeModel) {
        case 'knn':
          prediction = this.models.knn.predict(features);
          break;
        case 'logistic':
          prediction = this.models.logistic.predict(features);
          break;
        case 'ensemble':
        default:
          prediction = this.models.ensemble.predict(features);
          break;
      }
      
      if (prediction) {
        this.mlPredictions.push({
          features,
          prediction: this.getPredictedClass(prediction),
          timestamp: Date.now()
        });
        
        if (this.mlPredictions.length > 50) {
          this.mlPredictions = this.mlPredictions.slice(-50);
        }
      }
      
      return prediction;
    } catch (e) {
      console.error('ML prediction error:', e);
      return null;
    }
  }

  getPredictedClass(prediction) {
    if (!prediction) return null;
    const entries = Object.entries(prediction);
    if (entries.length === 0) return null;
    
    entries.sort((a, b) => b[1] - a[1]);
    return entries[0][0];
  }

  getModelAccuracy(modelName) {
    const model = this.models[modelName];
    return model && model.getAccuracy ? model.getAccuracy() : 0;
  }

  getTrainingDataCount() {
    return this.featureHistory.length;
  }

  getMLWeight() {
    const minWeight = 0.1;
    const maxWeight = 0.6;
    const dataPoints = this.getTrainingDataCount();
    const weight = minWeight + (maxWeight - minWeight) * (dataPoints / 100);
    return Math.min(weight, maxWeight);
  }

  enable() {
    this.isEnabled = true;
  }

  disable() {
    this.isEnabled = false;
  }

  setActiveModel(modelName) {
    if (this.models[modelName]) {
      this.activeModel = modelName;
    }
  }

  reset() {
    this.models = {
      knn: new SimpleKNN(5),
      logistic: new SimpleLogisticRegression(),
      ensemble: new EnsembleModel()
    };
    this.featureHistory = [];
    this.mlPredictions = [];
    this.trainingData = [];
  }

  getStats() {
    return {
      trainingCount: this.featureHistory.length,
      accuracy: this.getModelAccuracy(this.activeModel),
      weight: this.getMLWeight(),
      isEnabled: this.isEnabled,
      activeModel: this.activeModel
    };
  }
}

// ========== Ù†Ø¸Ø§Ù… Ø­ÙØ¸ Ø§Ù„Ø¨ÙŠØ§Ù†Ø§Øª ==========

class DataManager {
  constructor() {
    this.storageKey = 'baccaratPro_v6';
    this.autoSaveInterval = null;
    this.lastSaveTime = null;
    this.isSaving = false;
  }

  saveAllData() {
    if (this.isSaving) return false;
    
    this.isSaving = true;
    try {
      const saveData = {
        state: {
          rounds: state.rounds,
          count: state.count,
          win: state.win,
          loss: state.loss,
          windowSize: state.windowSize,
          analysisMode: state.analysisMode,
          confidenceThreshold: state.confidenceThreshold,
          timeWeighting: state.timeWeighting,
          useML: state.useML,
          mlModel: state.mlModel,
          modelPerformance: state.modelPerformance,
          previousPredictions: state.previousPredictions,
          lastPrediction: state.lastPrediction,
          assistantActive: state.voiceAssistant.isActive,
          conversationCount: state.voiceAssistant.conversationCount
        },
        history: {
          accuracyHistory: state.accuracyHistory,
          predictionsHistory: state.predictionsHistory
        },
        mlData: {
          featureHistory: state.ml.featureHistory,
          mlPredictions: state.ml.mlPredictions,
          activeModel: state.ml.activeModel,
          isEnabled: state.ml.isEnabled
        },
        assistantData: {
          conversationHistory: state.voiceAssistant.conversationHistory,
          mood: state.voiceAssistant.mood
        },
        meta: {
          version: '6.0',
          lastSave: new Date().toISOString(),
          totalRounds: state.rounds.length,
          sessionStart: this.getSessionStartTime()
        }
      };

      localStorage.setItem(this.storageKey, JSON.stringify(saveData));
      this.lastSaveTime = new Date();
      this.updateSaveStatus(true);
      return true;
    } catch (e) {
      console.error('Error saving data:', e);
      this.updateSaveStatus(false, 'Ø®Ø·Ø£ ÙÙŠ Ø§Ù„Ø­ÙØ¸');
      return false;
    } finally {
      this.isSaving = false;
    }
  }

  loadAllData() {
    try {
      const saved = localStorage.getItem(this.storageKey);
      if (!saved) {
        this.updateSaveStatus(true, 'Ø¨Ø¯ÙˆÙ† Ø¨ÙŠØ§Ù†Ø§Øª Ø³Ø§Ø¨Ù‚Ø©');
        return false;
      }

      const data = JSON.parse(saved);
      
      // ØªØ­Ù…ÙŠÙ„ Ø¨ÙŠØ§Ù†Ø§Øª Ø§Ù„Ø­Ø§Ù„Ø©
      if (data.state) {
        state.rounds = Array.isArray(data.state.rounds) ? data.state.rounds : [];
        state.count = data.state.count || { P: 0, B: 0, T: 0 };
        state.win = data.state.win || { P: 0, B: 0, T: 0 };
        state.loss = data.state.loss || { P: 0, B: 0, T: 0 };
        state.windowSize = data.state.windowSize || 8;
        state.analysisMode = data.state.analysisMode || 'advanced';
        state.confidenceThreshold = data.state.confidenceThreshold || 45;
        state.timeWeighting = data.state.timeWeighting || 'linear';
        state.useML = data.state.useML !== false;
        state.mlModel = data.state.mlModel || 'ensemble';
        state.modelPerformance = data.state.modelPerformance || { basic: 0, advanced: 0, pattern: 0, ml: 0 };
        state.previousPredictions = data.state.previousPredictions || { P: 0, B: 0, T: 0 };
        state.lastPrediction = data.state.lastPrediction || null;
        
        // ØªØ­Ù…ÙŠÙ„ Ø¥Ø¹Ø¯Ø§Ø¯Ø§Øª Ø§Ù„Ù…Ø³Ø§Ø¹Ø¯Ø©
        if (data.state.assistantActive !== undefined) {
          state.voiceAssistant.isActive = data.state.assistantActive;
        }
        if (data.state.conversationCount !== undefined) {
          state.voiceAssistant.conversationCount = data.state.conversationCount;
        }
      }

      // ØªØ­Ù…ÙŠÙ„ Ø§Ù„ØªØ§Ø±ÙŠØ®
      if (data.history) {
        state.accuracyHistory = Array.isArray(data.history.accuracyHistory) ? data.history.accuracyHistory : [];
        state.predictionsHistory = Array.isArray(data.history.predictionsHistory) ? data.history.predictionsHistory : [];
      }

      // ØªØ­Ù…ÙŠÙ„ ML
      if (data.mlData) {
        state.ml.featureHistory = Array.isArray(data.mlData.featureHistory) ? data.mlData.featureHistory : [];
        state.ml.mlPredictions = Array.isArray(data.mlData.mlPredictions) ? data.mlData.mlPredictions : [];
        state.ml.activeModel = data.mlData.activeModel || 'ensemble';
        state.ml.isEnabled = data.mlData.isEnabled !== false;
        
        // Ø¥Ø¹Ø§Ø¯Ø© ØªØ¯Ø±ÙŠØ¨ Ø§Ù„Ù†Ù…Ø§Ø°Ø¬
        setTimeout(() => {
          if (state.ml.featureHistory.length > 0) {
            state.ml.featureHistory.forEach((item, index) => {
              if (index > 0 && item.features && item.label) {
                state.ml.models.knn.train([item.features], [item.label]);
                state.ml.models.logistic.trainOne(item.features, item.label);
                state.ml.models.ensemble.train(item.features, item.label);
              }
            });
          }
        }, 500);
      }

      // ØªØ­Ù…ÙŠÙ„ Ø¨ÙŠØ§Ù†Ø§Øª Ø§Ù„Ù…Ø³Ø§Ø¹Ø¯Ø©
      if (data.assistantData) {
        if (Array.isArray(data.assistantData.conversationHistory)) {
          state.voiceAssistant.conversationHistory = data.assistantData.conversationHistory;
        }
        if (data.assistantData.mood) {
          state.voiceAssistant.mood = data.assistantData.mood;
        }
      }

      this.lastSaveTime = new Date();
      this.updateSaveStatus(true, 'ØªÙ… ØªØ­Ù…ÙŠÙ„ Ø§Ù„Ø¨ÙŠØ§Ù†Ø§Øª');
      return true;
    } catch (e) {
      console.error('Error loading data:', e);
      this.updateSaveStatus(false, 'Ø®Ø·Ø£ ÙÙŠ Ø§Ù„ØªØ­Ù…ÙŠÙ„');
      return false;
    }
  }

  exportData() {
    try {
      const exportData = {
        state: {
          rounds: state.rounds,
          count: state.count,
          win: state.win,
          loss: state.loss,
          windowSize: state.windowSize
        },
        ml: {
          featureHistory: state.ml.featureHistory,
          trainingCount: state.ml.getTrainingDataCount()
        },
        assistant: {
          conversationHistory: state.voiceAssistant.conversationHistory,
          conversationCount: state.voiceAssistant.conversationCount
        },
        meta: {
          exportDate: new Date().toISOString(),
          version: 'AYOUB_BACCARAT_PRO_v6.0',
          totalRounds: state.rounds.length
        }
      };

      const dataStr = JSON.stringify(exportData, null, 2);
      const dataBlob = new Blob([dataStr], { type: 'application/json' });
      const url = URL.createObjectURL(dataBlob);
      
      const a = document.createElement('a');
      a.href = url;
      a.download = `baccarat_data_${new Date().toISOString().split('T')[0]}.json`;
      document.body.appendChild(a);
      a.click();
      
      setTimeout(() => {
        document.body.removeChild(a);
        URL.revokeObjectURL(url);
      }, 100);
      
      alert(`âœ… ØªÙ… ØªØµØ¯ÙŠØ± ${state.rounds.length} Ø¬ÙˆÙ„Ø© Ùˆ ${state.ml.featureHistory.length} Ø¹ÙŠÙ†Ø© ØªØ¯Ø±ÙŠØ¨`);
    } catch (e) {
      alert('âŒ Ø®Ø·Ø£ ÙÙŠ ØªØµØ¯ÙŠØ± Ø§Ù„Ø¨ÙŠØ§Ù†Ø§Øª: ' + e.message);
    }
  }

  importData(file) {
    const reader = new FileReader();
    
    reader.onload = (e) => {
      try {
        const importedData = JSON.parse(e.target.result);
        
        if (!confirm(`Ù‡Ù„ ØªØ±ÙŠØ¯ Ø§Ø³ØªÙŠØ±Ø§Ø¯ ${importedData.state?.rounds?.length || 0} Ø¬ÙˆÙ„Ø©ØŸ\nØ³ÙŠØªÙ… Ù…Ø³Ø­ Ø§Ù„Ø¨ÙŠØ§Ù†Ø§Øª Ø§Ù„Ø­Ø§Ù„ÙŠØ©.`)) {
          return;
        }

        // Ù…Ø³Ø­ Ø§Ù„Ø¨ÙŠØ§Ù†Ø§Øª Ø§Ù„Ø­Ø§Ù„ÙŠØ©
        resetAll();
        
        // ØªØ­Ù…ÙŠÙ„ Ø§Ù„Ø¨ÙŠØ§Ù†Ø§Øª Ø§Ù„Ù…Ø³ØªÙˆØ±Ø¯Ø©
        if (importedData.state) {
          state.rounds = Array.isArray(importedData.state.rounds) ? importedData.state.rounds : [];
          state.count = importedData.state.count || { P: 0, B: 0, T: 0 };
          state.win = importedData.state.win || { P: 0, B: 0, T: 0 };
          state.loss = importedData.state.loss || { P: 0, B: 0, T: 0 };
          state.windowSize = importedData.state.windowSize || 8;
          
          // Ø­Ø³Ø§Ø¨ Ø§Ù„Ø¥Ø­ØµØ§Ø¡Ø§Øª Ù…Ù† Ø§Ù„Ø¬ÙˆÙ„Ø§Øª
          state.rounds.forEach(round => {
            state.count[round]++;
          });
        }

        if (importedData.ml && Array.isArray(importedData.ml.featureHistory)) {
          state.ml.featureHistory = importedData.ml.featureHistory;
          
          // Ø¥Ø¹Ø§Ø¯Ø© ØªØ¯Ø±ÙŠØ¨ ML
          setTimeout(() => {
            if (state.ml.featureHistory.length > 0) {
              state.ml.featureHistory.forEach((item, index) => {
                if (index > 0 && item.features && item.label) {
                  state.ml.models.knn.train([item.features], [item.label]);
                  state.ml.models.logistic.trainOne(item.features, item.label);
                  state.ml.models.ensemble.train(item.features, item.label);
                }
              });
            }
          }, 500);
        }

        if (importedData.assistant) {
          if (Array.isArray(importedData.assistant.conversationHistory)) {
            state.voiceAssistant.conversationHistory = importedData.assistant.conversationHistory;
          }
          if (importedData.assistant.conversationCount) {
            state.voiceAssistant.conversationCount = importedData.assistant.conversationCount;
          }
        }

        // ØªØ­Ø¯ÙŠØ« Ø§Ù„ÙˆØ§Ø¬Ù‡Ø©
        updateAll();
        updateMLStatus();
        state.voiceAssistant.updateConversationCount();
        state.voiceAssistant.updateMood();
        this.saveAllData();
        
        // ØªØ­Ø¯ÙŠØ« Ø³Ø¬Ù„ Ø§Ù„Ù…Ø­Ø§Ø¯Ø«Ø©
        state.voiceAssistant.clearConversation();
        if (state.voiceAssistant.conversationHistory.length > 0) {
          state.voiceAssistant.conversationHistory.forEach(item => {
            state.voiceAssistant.addToConversationLog(item.text);
          });
        }
        
        alert(`âœ… ØªÙ… Ø§Ø³ØªÙŠØ±Ø§Ø¯ ${state.rounds.length} Ø¬ÙˆÙ„Ø© Ø¨Ù†Ø¬Ø§Ø­!`);
      } catch (error) {
        alert('âŒ Ø®Ø·Ø£ ÙÙŠ ØªÙ†Ø³ÙŠÙ‚ Ø§Ù„Ù…Ù„Ù: ' + error.message);
      }
    };
    
    reader.onerror = () => {
      alert('âŒ Ø®Ø·Ø£ ÙÙŠ Ù‚Ø±Ø§Ø¡Ø© Ø§Ù„Ù…Ù„Ù');
    };
    
    reader.readAsText(file);
  }

  clearAllData() {
    if (confirm('âš ï¸ Ù‡Ù„ Ø£Ù†Øª Ù…ØªØ£ÙƒØ¯ Ù…Ù† Ù…Ø³Ø­ Ø¬Ù…ÙŠØ¹ Ø§Ù„Ø¨ÙŠØ§Ù†Ø§ØªØŸ\nÙ„Ø§ ÙŠÙ…ÙƒÙ† Ø§Ù„ØªØ±Ø§Ø¬Ø¹ Ø¹Ù† Ù‡Ø°Ø§ Ø§Ù„Ø¥Ø¬Ø±Ø§Ø¡.')) {
      localStorage.removeItem(this.storageKey);
      resetAll();
      state.voiceAssistant.clearConversation();
      alert('âœ… ØªÙ… Ù…Ø³Ø­ Ø¬Ù…ÙŠØ¹ Ø§Ù„Ø¨ÙŠØ§Ù†Ø§Øª.');
    }
  }

  startAutoSave(intervalSeconds = 30) {
    if (this.autoSaveInterval) {
      clearInterval(this.autoSaveInterval);
    }
    
    this.autoSaveInterval = setInterval(() => {
      if (state.rounds.length > 0 && !this.isSaving) {
        this.saveAllData();
      }
    }, intervalSeconds * 1000);
    
    // Ø­ÙØ¸ Ø¹Ù†Ø¯ Ø¥ØºÙ„Ø§Ù‚ Ø§Ù„ØµÙØ­Ø©
    window.addEventListener('beforeunload', () => {
      if (!this.isSaving) {
        this.saveAllData();
      }
    });
  }

  updateSaveStatus(success, message = '') {
    const statusEl = el('autoSaveStatus');
    if (statusEl) {
      if (success) {
        const timeStr = this.lastSaveTime ? 
          `ğŸ’¾ Ø¢Ø®Ø± Ø­ÙØ¸: ${this.lastSaveTime.toLocaleTimeString('ar-EG', {hour: '2-digit', minute:'2-digit'})}` : 
          'ğŸ’¾ Ø§Ù„Ø­ÙØ¸ Ø§Ù„ØªÙ„Ù‚Ø§Ø¦ÙŠ Ù…ÙØ¹Ù„';
        statusEl.textContent = message || timeStr;
        statusEl.style.color = '#38b000';
      } else {
        statusEl.textContent = message || 'âŒ Ø®Ø·Ø£ ÙÙŠ Ø§Ù„Ø­ÙØ¸';
        statusEl.style.color = '#ff006e';
      }
    }
  }

  getSessionStartTime() {
    const saved = localStorage.getItem('session_start');
    if (!saved) {
      const startTime = new Date().toISOString();
      localStorage.setItem('session_start', startTime);
      return startTime;
    }
    return saved;
  }

  updateDataStats() {
    const statsEl = document.getElementById('dataStats');
    if (statsEl) {
      statsEl.textContent = `${state.rounds.length} Ø¬ÙˆÙ„Ø© â€¢ ${state.ml.featureHistory.length} Ø¹ÙŠÙ†Ø© ØªØ¯Ø±ÙŠØ¨`;
    }
  }
}

// ========== Ø§Ù„Ø­Ø§Ù„Ø© Ø§Ù„Ø¹Ø§Ù…Ø© Ù„Ù„ØªØ·Ø¨ÙŠÙ‚ ==========
const state = {
  rounds: [],
  windowSize: 8,
  count: { P: 0, B: 0, T: 0 },
  win: { P: 0, B: 0, T: 0 },
  loss: { P: 0, B: 0, T: 0 },
  lastPrediction: null,
  accuracyHistory: [],
  predictionsHistory: [],
  analysisMode: 'advanced',
  confidenceThreshold: 45,
  timeWeighting: 'linear',
  modelPerformance: { basic: 0, advanced: 0, pattern: 0, ml: 0 },
  previousPredictions: { P: 0, B: 0, T: 0 },
  ml: new BaccaratMachineLearning(),
  useML: true,
  mlModel: 'ensemble',
  voiceAssistant: new VoiceAssistant()
};

// Ø¥Ù†Ø´Ø§Ø¡ Ù…Ø¯ÙŠØ± Ø§Ù„Ø¨ÙŠØ§Ù†Ø§Øª
const dataManager = new DataManager();

// ========== Ø§Ù„ÙˆØ¸Ø§Ø¦Ù Ø§Ù„Ù…Ø³Ø§Ø¹Ø¯Ø© ==========
const el = id => document.getElementById(id);

// ========== Ø§Ù„ÙˆØ¸Ø§Ø¦Ù Ø§Ù„Ø±Ø¦ÙŠØ³ÙŠØ© ==========

function init() {
  console.log('Initializing Baccarat Pro with Voice Assistant...');
  
  // ØªØ­Ù…ÙŠÙ„ Ø§Ù„Ø¨ÙŠØ§Ù†Ø§Øª Ø§Ù„Ù…Ø­ÙÙˆØ¸Ø©
  dataManager.loadAllData();
  
  // Ø¥Ø¹Ø¯Ø§Ø¯ Ø¹Ù†Ø§ØµØ± Ø§Ù„ÙˆØ§Ø¬Ù‡Ø©
  el('windowSize').value = state.windowSize;
  
  el('applyWindow').onclick = () => {
    const v = parseInt(el('windowSize').value);
    if (v >= 5 && v <= 15) {
      state.windowSize = v;
      updateAll();
      showToast(`ØªÙ… ØªØºÙŠÙŠØ± Ù†Ø§ÙØ°Ø© Ø§Ù„ØªØ­Ù„ÙŠÙ„ Ø¥Ù„Ù‰ ${v} Ø¬ÙˆÙ„Ø§Øª`);
    } else {
      showToast('Ø§Ù„Ù†Ø§ÙØ°Ø© ÙŠØ¬Ø¨ Ø£Ù† ØªÙƒÙˆÙ† Ø¨ÙŠÙ† 5 Ùˆ 15', 'error');
    }
  };

  el('analysisMode').value = state.analysisMode;
  el('analysisMode').onchange = (e) => {
    state.analysisMode = e.target.value;
    updateAll();
    showToast(`ØªÙ… ØªØºÙŠÙŠØ± Ù†Ù…Ø· Ø§Ù„ØªØ­Ù„ÙŠÙ„ Ø¥Ù„Ù‰ ${getModeName(state.analysisMode)}`);
  };

  el('confidenceSensitivity').value = state.confidenceThreshold;
  el('confidenceSensitivity').oninput = (e) => {
    state.confidenceThreshold = parseInt(e.target.value);
    el('sensitivityValue').textContent = state.confidenceThreshold + '%';
    updateAll();
  };

  el('timeWeighting').value = state.timeWeighting;
  el('timeWeighting').onchange = (e) => {
    state.timeWeighting = e.target.value;
    updateAll();
    showToast(`ØªÙ… ØªØºÙŠÙŠØ± Ø§Ù„Ù…Ø±Ø¬Ø­Ø© Ø§Ù„Ø²Ù…Ù†ÙŠØ© Ø¥Ù„Ù‰ ${getWeightingName(state.timeWeighting)}`);
  };

  // Ø¥Ø¹Ø¯Ø§Ø¯Ø§Øª ØªØ¹Ù„Ù… Ø§Ù„Ø¢Ù„Ø©
  el('mlToggle').checked = state.useML;
  el('mlToggle').onchange = (e) => {
    state.useML = e.target.checked;
    state.ml.isEnabled = state.useML;
    updateMLStatus();
    updateAll();
    showToast(`ØªØ¹Ù„Ù… Ø§Ù„Ø¢Ù„Ø© ${state.useML ? 'Ù…ÙØ¹Ù„' : 'Ù…Ø¹Ø·Ù„'}`);
  };

  el('mlModelSelect').value = state.mlModel;
  el('mlModelSelect').onchange = (e) => {
    state.mlModel = e.target.value;
    state.ml.setActiveModel(state.mlModel);
    updateMLStatus();
    updateAll();
    showToast(`ØªÙ… ØªØºÙŠÙŠØ± Ù†Ù…ÙˆØ°Ø¬ ML Ø¥Ù„Ù‰ ${getMLModelName(state.mlModel)}`);
  };

  // Ø£Ø²Ø±Ø§Ø± Ø§Ù„Ù…Ø³Ø§Ø¹Ø¯Ø© Ø§Ù„ØµÙˆØªÙŠØ©
  el('voiceAssistantToggle').onclick = () => {
    const isActive = state.voiceAssistant.toggle();
    showToast(`Ø§Ù„Ù…Ø³Ø§Ø¹Ø¯Ø© Ø§Ù„ØµÙˆØªÙŠØ© ${isActive ? 'Ù…ÙØ¹Ù„Ø©' : 'Ù…Ø¹Ø·Ù„Ø©'}`);
  };

  el('btnSpeakPrediction').onclick = () => {
    state.voiceAssistant.speakPrediction();
  };

  el('btnAskAdvice').onclick = () => {
    state.voiceAssistant.giveAdvice();
  };

  el('btnAskEntry').onclick = () => {
    state.voiceAssistant.giveEntrySignal();
  };

  el('btnAskExit').onclick = () => {
    state.voiceAssistant.giveExitSignal();
  };

  el('btnAskAnalysis').onclick = () => {
    state.voiceAssistant.giveDetailedAnalysis();
  };

  // Ø£Ø²Ø±Ø§Ø± Ø§Ù„Ø¥Ø¯Ø®Ø§Ù„
  el('btnP').onclick = () => pushRound('P');
  el('btnB').onclick = () => pushRound('B');
  el('btnT').onclick = () => pushRound('T');
  el('btnUndo').onclick = undoRound;
  el('btnReset').onclick = resetAll;
  
  // Ø£Ø²Ø±Ø§Ø± Ø§Ù„Ø¨ÙŠØ§Ù†Ø§Øª
  el('btnExport').onclick = () => dataManager.exportData();
  el('btnImport').onclick = () => {
    const input = document.createElement('input');
    input.type = 'file';
    input.accept = '.json';
    input.onchange = (e) => {
      if (e.target.files && e.target.files[0]) {
        dataManager.importData(e.target.files[0]);
      }
    };
    input.click();
  };
  el('btnClearData').onclick = () => dataManager.clearAllData();
  
  // ØªØ¨Ø¯ÙŠÙ„ Ø§Ù„ÙˆØ¶Ø¹
  el('themeToggle').onclick = toggleTheme;
  
  // ØªØ¹ÙŠÙŠÙ† Ø§Ù„ÙˆØ¶Ø¹ Ø§Ù„Ø§ÙØªØ±Ø§Ø¶ÙŠ
  if (!document.documentElement.hasAttribute('data-theme')) {
    document.documentElement.setAttribute('data-theme', 'dark');
  }
  
  // ØªØ­Ø¯ÙŠØ« Ø­Ø§Ù„Ø© Ø§Ù„Ù…Ø³Ø§Ø¹Ø¯Ø© Ø§Ù„ØµÙˆØªÙŠØ©
  if (state.voiceAssistant.isActive) {
    el('voiceAssistantToggle').classList.add('voice-assistant-active');
    el('voiceAssistantToggle').innerHTML = '<span id="voiceIcon">ğŸ¤</span> Ø§Ù„Ù…Ø³Ø§Ø¹Ø¯Ø© Ø§Ù„ØµÙˆØªÙŠØ© <span class="voice-pulse"></span>';
  }
  
  state.voiceAssistant.updateMood();
  state.voiceAssistant.updateConversationCount();
  
  // Ø¨Ø¯Ø¡ Ø§Ù„Ø­ÙØ¸ Ø§Ù„ØªÙ„Ù‚Ø§Ø¦ÙŠ
  dataManager.startAutoSave(30);
  
  // ØªØ­Ø¯ÙŠØ« Ø§Ù„ÙˆØ§Ø¬Ù‡Ø©
  updateAll();
  updateMLStatus();
  dataManager.updateDataStats();
  
  console.log('Initialization complete');
}

function toggleTheme() {
  const currentTheme = document.documentElement.getAttribute('data-theme');
  const newTheme = currentTheme === 'dark' ? 'light' : 'dark';
  document.documentElement.setAttribute('data-theme', newTheme);
  el('themeToggle').textContent = newTheme === 'dark' ? 'ğŸŒš' : 'ğŸŒ•';
  updateAccuracyChart();
  showToast(`ØªÙ… Ø§Ù„ØªØ¨Ø¯ÙŠÙ„ Ø¥Ù„Ù‰ Ø§Ù„ÙˆØ¶Ø¹ ${newTheme === 'dark' ? 'Ø§Ù„Ù„ÙŠÙ„ÙŠ' : 'Ø§Ù„Ù†Ù‡Ø§Ø±ÙŠ'}`);
}

function getModeName(mode) {
  const names = {
    basic: 'Ø£Ø³Ø§Ø³ÙŠ',
    advanced: 'Ù…ØªÙ‚Ø¯Ù…',
    pattern: 'ØªØ­Ù„ÙŠÙ„ Ø§Ù„Ø£Ù†Ù…Ø§Ø·',
    ml: 'ØªØ¹Ù„Ù… Ø§Ù„Ø¢Ù„Ø©'
  };
  return names[mode] || mode;
}

function getWeightingName(weighting) {
  const names = {
    none: 'Ø¨Ø¯ÙˆÙ†',
    linear: 'Ø®Ø·ÙŠ',
    exponential: 'Ø£Ø³Ù‘ÙŠ'
  };
  return names[weighting] || weighting;
}

function getMLModelName(model) {
  const names = {
    knn: 'K-Ø§Ù„Ø¬ÙŠØ±Ø§Ù† Ø§Ù„Ø£Ù‚Ø±Ø¨',
    logistic: 'Ø§Ù„Ø§Ù†Ø­Ø¯Ø§Ø± Ø§Ù„Ù„ÙˆØ¬Ø³ØªÙŠ',
    ensemble: 'Ø§Ù„Ù…Ø¬Ù…Ø¹'
  };
  return names[model] || model;
}

function showToast(message, type = 'success') {
  const toast = document.createElement('div');
  toast.textContent = message;
  toast.style.cssText = `
    position: fixed;
    top: 20px;
    right: 20px;
    background: ${type === 'error' ? '#ef4444' : type === 'warning' ? '#d4af37' : '#10b981'};
    color: white;
    padding: 12px 20px;
    border-radius: 8px;
    z-index: 1000;
    box-shadow: 0 4px 12px rgba(0,0,0,0.3);
    animation: slideIn 0.3s ease-out;
  `;
  
  document.body.appendChild(toast);
  
  setTimeout(() => {
    toast.style.animation = 'slideOut 0.3s ease-in';
    setTimeout(() => {
      if (toast.parentNode) {
        document.body.removeChild(toast);
      }
    }, 300);
  }, 3000);
}

// Ø¥Ø¶Ø§ÙØ© Ø£Ù†ÙŠÙ…ÙŠØ´Ù† Ù„Ù„ØªÙˆØ³Øª
const style = document.createElement('style');
style.textContent = `
@keyframes slideIn {
  from { transform: translateX(100%); opacity: 0; }
  to { transform: translateX(0); opacity: 1; }
}
@keyframes slideOut {
  from { transform: translateX(0); opacity: 1; }
  to { transform: translateX(100%); opacity: 0; }
}
`;
document.head.appendChild(style);

// ========== Ø®ÙˆØ§Ø±Ø²Ù…ÙŠØ§Øª Ø§Ù„ØªØ­Ù„ÙŠÙ„ ==========

function frequencyAnalysis(rounds) {
  if (!rounds || rounds.length === 0) {
    return { P: 33.3, B: 33.3, T: 33.3 };
  }
  
  const counts = { P: 0, B: 0, T: 0 };
  rounds.forEach(x => {
    if (x in counts) counts[x]++;
  });
  
  const total = rounds.length;
  return {
    P: (counts.P / total) * 100,
    B: (counts.B / total) * 100,
    T: (counts.T / total) * 100
  };
}

function patternAnalysis(rounds) {
  if (!rounds || rounds.length < 3) {
    return { P: 0, B: 0, T: 0 };
  }

  const patterns = {};
  for (let i = 2; i < rounds.length; i++) {
    const pattern = rounds.slice(i-2, i).join('');
    const next = rounds[i];
    
    if (!patterns[pattern]) {
      patterns[pattern] = { P: 0, B: 0, T: 0, total: 0 };
    }
    
    if (next in patterns[pattern]) {
      patterns[pattern][next]++;
      patterns[pattern].total++;
    }
  }

  if (rounds.length >= 2) {
    const lastPattern = rounds.slice(-2).join('');
    const patternData = patterns[lastPattern];
    
    if (patternData && patternData.total >= 1) {
      return {
        P: (patternData.P / patternData.total) * 100,
        B: (patternData.B / patternData.total) * 100,
        T: (patternData.T / patternData.total) * 100
      };
    }
  }

  return { P: 0, B: 0, T: 0 };
}

function applyTimeWeighting(rounds, basePrediction) {
  if (state.timeWeighting === 'none' || !rounds || rounds.length < 2) {
    return basePrediction;
  }

  const n = rounds.length;
  let weightFactor = 1;
  
  if (state.timeWeighting === 'linear') {
    weightFactor = 0.8 + (0.4 * (1 / n));
  } else if (state.timeWeighting === 'exponential') {
    weightFactor = 0.7 + (0.6 * Math.pow(0.9, n));
  }

  return {
    P: basePrediction.P * weightFactor,
    B: basePrediction.B * weightFactor,
    T: basePrediction.T * weightFactor
  };
}

function enhancedPredict() {
  const n = Math.min(state.windowSize, state.rounds.length);
  const recent = state.rounds.slice(-n);
  
  if (recent.length === 0) {
    return { 
      P: 33.3, B: 33.3, T: 33.3, 
      final: 'â€”',
      confidence: 0,
      model: 'basic',
      mlContribution: 0
    };
  }

  let basePrediction, patternBoost, finalPrediction;
  let modelUsed = state.analysisMode;
  let mlContribution = 0;

  switch(state.analysisMode) {
    case 'basic':
      basePrediction = frequencyAnalysis(recent);
      finalPrediction = basePrediction;
      break;
      
    case 'advanced':
      basePrediction = frequencyAnalysis(recent);
      patternBoost = patternAnalysis(recent);
      
      finalPrediction = {
        P: basePrediction.P * 0.7 + patternBoost.P * 0.3,
        B: basePrediction.B * 0.7 + patternBoost.B * 0.3,
        T: basePrediction.T * 0.7 + patternBoost.T * 0.3
      };
      break;
      
    case 'pattern':
      basePrediction = frequencyAnalysis(recent);
      patternBoost = patternAnalysis(recent);
      
      finalPrediction = {
        P: basePrediction.P * 0.4 + patternBoost.P * 0.6,
        B: basePrediction.B * 0.4 + patternBoost.B * 0.6,
        T: basePrediction.T * 0.4 + patternBoost.T * 0.6
      };
      break;
      
    case 'ml':
      basePrediction = frequencyAnalysis(recent);
      
      let mlPrediction = state.ml.predict(state.rounds, state.windowSize);
      if (!mlPrediction) {
        mlPrediction = { P: 33.3, B: 33.3, T: 33.3 };
      }
      
      const mlWeight = state.ml.getMLWeight();
      mlContribution = mlWeight * 100;
      
      finalPrediction = {
        P: basePrediction.P * (1 - mlWeight) + mlPrediction.P * mlWeight,
        B: basePrediction.B * (1 - mlWeight) + mlPrediction.B * mlWeight,
        T: basePrediction.T * (1 - mlWeight) + mlPrediction.T * mlWeight
      };
      break;
  }

  finalPrediction = applyTimeWeighting(recent, finalPrediction);

  const sum = finalPrediction.P + finalPrediction.B + finalPrediction.T;
  if (sum > 0) {
    finalPrediction.P = (finalPrediction.P / sum) * 100;
    finalPrediction.B = (finalPrediction.B / sum) * 100;
    finalPrediction.T = (finalPrediction.T / sum) * 100;
  }

  const entries = Object.entries(finalPrediction);
  const sorted = entries.sort((a, b) => b[1] - a[1]);
  
  const confidence = sorted[0][1] - (sorted[1] ? sorted[1][1] : 0);
  let final = sorted[0][0];
  
  if (sorted[0][1] < state.confidenceThreshold) {
    final = 'â€”';
  }

  return {
    P: finalPrediction.P.toFixed(1),
    B: finalPrediction.B.toFixed(1),
    T: finalPrediction.T.toFixed(1),
    final,
    confidence: Math.min(100, Math.max(0, confidence * 2)),
    model: modelUsed,
    mlContribution: mlContribution.toFixed(1)
  };
}

function pushRound(r) {
  if (!['P', 'B', 'T'].includes(r)) return;
  
  const pred = enhancedPredict();
  state.lastPrediction = pred.final;
  
  state.ml.updateModel(state.rounds, state.windowSize, r);
  
  state.rounds.push(r);
  state.count[r]++;
  
  if (state.lastPrediction !== 'â€”' && state.lastPrediction !== null) {
    const didWin = (r === state.lastPrediction);
    
    if (didWin) {
      state.win[state.lastPrediction]++;
      state.modelPerformance[state.analysisMode] = (state.modelPerformance[state.analysisMode] || 0) + 1;
    } else {
      state.loss[state.lastPrediction] = (state.loss[state.lastPrediction] || 0) + 1;
    }
  }
  
  updateAccuracyData(r);
  
  const newPred = enhancedPredict();
  updatePredictionDisplay(newPred);
  showResult(r, newPred, state.lastPrediction === r);
  updateAll();
  dataManager.saveAllData();
  dataManager.updateDataStats();
  
  // ØªÙØ§Ø¹Ù„ Ø§Ù„Ù…Ø³Ø§Ø¹Ø¯Ø© Ø§Ù„ØµÙˆØªÙŠØ© Ù…Ø¹ Ø§Ù„Ø¬ÙˆÙ„Ø©
  state.voiceAssistant.reactToRound(r, state.lastPrediction, state.lastPrediction === r);
  
  // ØªØ­Ø¯ÙŠØ« Ù…Ø²Ø§Ø¬ Ø§Ù„Ù…Ø³Ø§Ø¹Ø¯Ø©
  state.voiceAssistant.updateMood();
  
  playSound('click');
}

function undoRound() {
  if (state.rounds.length === 0) return;
  
  const lastRound = state.rounds.pop();
  state.count[lastRound] = Math.max(0, state.count[lastRound] - 1);
  
  if (state.rounds.length > 0) {
    const previousPrediction = enhancedPredict();
    if (lastRound === previousPrediction.final) {
      state.win[previousPrediction.final] = Math.max(0, state.win[previousPrediction.final] - 1);
      state.modelPerformance[state.analysisMode] = Math.max(0, state.modelPerformance[state.analysisMode] - 1);
    } else {
      state.loss[previousPrediction.final] = Math.max(0, state.loss[previousPrediction.final] - 1);
    }
  }
  
  if (state.accuracyHistory.length > 0) {
    state.accuracyHistory.pop();
    state.predictionsHistory.pop();
  }
  
  state.lastPrediction = null;
  
  // Ø¥Ø¹Ø§Ø¯Ø© ØªØ¯Ø±ÙŠØ¨ ML Ù…Ø¹ Ø§Ù„Ø¨ÙŠØ§Ù†Ø§Øª Ø§Ù„Ù…Ø­Ø¯Ø«Ø©
  state.ml.reset();
  for (let i = 0; i < state.rounds.length; i++) {
    if (i >= state.windowSize) {
      const recent = state.rounds.slice(i - state.windowSize, i);
      state.ml.updateModel(recent, state.windowSize, state.rounds[i]);
    }
  }
  
  // ØªØ¹Ù„ÙŠÙ‚ Ù…Ù† Ø§Ù„Ù…Ø³Ø§Ø¹Ø¯Ø© Ø§Ù„ØµÙˆØªÙŠØ©
  if (state.voiceAssistant.isActive) {
    state.voiceAssistant.addToConversationLog("â†©ï¸ ØªÙ… Ø§Ù„ØªØ±Ø§Ø¬Ø¹ Ø¹Ù† Ø§Ù„Ø¬ÙˆÙ„Ø© Ø§Ù„Ø£Ø®ÙŠØ±Ø©.");
  }
  
  updateAll();
  dataManager.saveAllData();
  dataManager.updateDataStats();
  playSound('undo');
}

function resetAll() {
  if (state.rounds.length === 0) return;
  
  if (!confirm('Ù‡Ù„ ØªØ±ÙŠØ¯ Ø¥Ø¹Ø§Ø¯Ø© ØªØ¹ÙŠÙŠÙ† Ø¬Ù…ÙŠØ¹ Ø§Ù„Ø¨ÙŠØ§Ù†Ø§ØªØŸ')) return;
  
  state.rounds = [];
  state.count = { P: 0, B: 0, T: 0 };
  state.win = { P: 0, B: 0, T: 0 };
  state.loss = { P: 0, B: 0, T: 0 };
  state.lastPrediction = null;
  state.accuracyHistory = [];
  state.predictionsHistory = [];
  state.modelPerformance = { basic: 0, advanced: 0, pattern: 0, ml: 0 };
  state.previousPredictions = { P: 0, B: 0, T: 0 };
  
  state.ml.reset();
  state.voiceAssistant.clearConversation();
  state.voiceAssistant.conversationCount = 0;
  state.voiceAssistant.updateConversationCount();
  state.voiceAssistant.updateMood();
  
  if (state.voiceAssistant.isActive) {
    state.voiceAssistant.showMessage("ØªÙ… Ø¥Ø¹Ø§Ø¯Ø© ØªØ¹ÙŠÙŠÙ† Ø¬Ù…ÙŠØ¹ Ø§Ù„Ø¨ÙŠØ§Ù†Ø§Øª. Ø§Ø¨Ø¯Ø£ Ù…Ù† Ø¬Ø¯ÙŠØ¯!");
    state.voiceAssistant.speak("ØªÙ… Ø¥Ø¹Ø§Ø¯Ø© ØªØ¹ÙŠÙŠÙ† Ø¬Ù…ÙŠØ¹ Ø§Ù„Ø¨ÙŠØ§Ù†Ø§Øª. Ø¬Ø§Ù‡Ø²Ø© Ù„Ù„Ø¨Ø¯Ø¡ Ù…Ù† Ø¬Ø¯ÙŠØ¯!");
  }
  
  updateAll();
  dataManager.saveAllData();
  dataManager.updateDataStats();
  playSound('reset');
}

function playSound(type) {
  try {
    if (type === 'click') {
      const audio = new Audio('data:audio/wav;base64,UklGRigAAABXQVZFZm10IBIAAAABAAEARKwAAIhYAQACABAAZGF0YQQAAAAAAA==');
      audio.volume = 0.1;
      audio.play();
    }
  } catch (e) {
    // ØªØ¬Ø§Ù‡Ù„ Ø£Ø®Ø·Ø§Ø¡ Ø§Ù„ØµÙˆØª
  }
}

function updatePredictionDisplay(pred) {
  el('predPctP').textContent = pred.P + '%';
  el('predPctB').textContent = pred.B + '%';
  el('predPctT').textContent = pred.T + '%';
  
  updateTrendIndicators(pred);
  
  ['predP', 'predB', 'predT'].forEach(id => {
    el(id).classList.remove('active');
  });
  
  if (pred.final !== 'â€”') {
    const finalEl = el('pred' + pred.final);
    if (finalEl) finalEl.classList.add('active');
  }
  
  let finalText = 'â€”';
  if (pred.final === 'P') finalText = 'Ù„Ø§Ø¹Ø¨';
  else if (pred.final === 'B') finalText = 'Ù…ØµØ±ÙÙŠ';
  else if (pred.final === 'T') finalText = 'ØªØ¹Ø§Ø¯Ù„';
  
  el('finalCard').textContent = finalText;
  
  el('mlContribution').textContent = pred.mlContribution > 0 ? 
    `ğŸ“Š Ù…Ø³Ø§Ù‡Ù…Ø© ØªØ¹Ù„Ù… Ø§Ù„Ø¢Ù„Ø©: ${pred.mlContribution}%` : '';
  
  updateConfidenceMeter(pred.confidence);
  updateModelInfo(pred);
}

function updateTrendIndicators(pred) {
  const current = { 
    P: parseFloat(pred.P) || 0, 
    B: parseFloat(pred.B) || 0, 
    T: parseFloat(pred.T) || 0 
  };
  const previous = state.previousPredictions;
  
  ['P', 'B', 'T'].forEach(type => {
    const trendEl = el('predTrend' + type);
    if (!trendEl) return;
    
    if (previous[type] > 0) {
      const diff = current[type] - previous[type];
      if (diff > 2) trendEl.textContent = 'â†—';
      else if (diff < -2) trendEl.textContent = 'â†˜';
      else trendEl.textContent = 'â†’';
      trendEl.style.color = diff > 0 ? '#38b000' : diff < 0 ? '#ff006e' : '#bfb7a6';
    } else {
      trendEl.textContent = 'â†’';
    }
  });
  
  state.previousPredictions = current;
}

function updateConfidenceMeter(confidence) {
  const fill = el('confidenceFill');
  const label = el('confidenceLabel');
  
  if (!fill || !label) return;
  
  fill.style.width = confidence + '%';
  
  if (confidence >= 70) {
    fill.className = 'confidence-fill high-confidence';
    label.textContent = 'Ø«Ù‚Ø© Ø¹Ø§Ù„ÙŠØ©';
    label.style.color = '#38b000';
  } else if (confidence >= 40) {
    fill.className = 'confidence-fill medium-confidence';
    label.textContent = 'Ø«Ù‚Ø© Ù…ØªÙˆØ³Ø·Ø©';
    label.style.color = '#d4af37';
  } else {
    fill.className = 'confidence-fill';
    label.textContent = 'Ø«Ù‚Ø© Ù…Ù†Ø®ÙØ¶Ø©';
    label.style.color = '#ff006e';
  }
}

function updateModelInfo(pred) {
  const modelEl = el('predModel');
  const modelInfoEl = el('modelInfo');
  const reasonEl = el('predictionReason');
  
  if (!modelEl || !modelInfoEl || !reasonEl) return;
  
  let modelName, modelClass, reason;
  
  switch(pred.model) {
    case 'basic':
      modelName = 'Ø£Ø³Ø§Ø³ÙŠ';
      modelClass = 'badge-basic';
      reason = 'ÙŠØ¹ØªÙ…Ø¯ Ø¹Ù„Ù‰ ØªØ­Ù„ÙŠÙ„ Ø§Ù„ØªØ±Ø¯Ø¯ Ø§Ù„Ø£Ø³Ø§Ø³ÙŠ';
      break;
    case 'advanced':
      modelName = 'Ù…ØªÙ‚Ø¯Ù…';
      modelClass = 'badge-advanced';
      reason = 'ÙŠØ¬Ù…Ø¹ Ø¨ÙŠÙ† ØªØ­Ù„ÙŠÙ„ Ø§Ù„ØªØ±Ø¯Ø¯ ÙˆØ§Ù„Ø£Ù†Ù…Ø§Ø·';
      break;
    case 'pattern':
      modelName = 'Ø§Ù„Ø£Ù†Ù…Ø§Ø·';
      modelClass = 'badge-pattern';
      reason = 'ÙŠØ±ÙƒØ² Ø¹Ù„Ù‰ ØªØ­Ù„ÙŠÙ„ Ø§Ù„ØªØ³Ù„Ø³Ù„Ø§Øª ÙˆØ§Ù„Ø£Ù†Ù…Ø§Ø·';
      break;
    case 'ml':
      modelName = 'ØªØ¹Ù„Ù… Ø§Ù„Ø¢Ù„Ø©';
      modelClass = 'badge-ml';
      reason = 'ÙŠØ³ØªØ®Ø¯Ù… Ø®ÙˆØ§Ø±Ø²Ù…ÙŠØ§Øª ML Ù…Ø¹ Ø§Ù„ØªØ¯Ø±ÙŠØ¨ Ø§Ù„ØªÙ„Ù‚Ø§Ø¦ÙŠ';
      break;
    default:
      modelName = 'Ø£Ø³Ø§Ø³ÙŠ';
      modelClass = 'badge-basic';
      reason = 'ÙŠØ¹ØªÙ…Ø¯ Ø¹Ù„Ù‰ ØªØ­Ù„ÙŠÙ„ Ø§Ù„ØªØ±Ø¯Ø¯ Ø§Ù„Ø£Ø³Ø§Ø³ÙŠ';
  }
  
  modelEl.textContent = modelName;
  modelEl.className = 'model-badge ' + modelClass;
  
  const efficiency = calculateModelEfficiency();
  modelInfoEl.textContent = `Ø§Ù„Ù†Ù…ÙˆØ°Ø¬: ${modelName} - Ø§Ù„ÙƒÙØ§Ø¡Ø©: ${efficiency}%`;
  
  if (pred.final === 'â€”') {
    reasonEl.textContent = 'Ø¹Ø¯Ù… ÙƒÙØ§ÙŠØ© Ø§Ù„Ø«Ù‚Ø© Ù„Ù„ØªÙ†Ø¨Ø¤ (ØªØ­Øª ' + state.confidenceThreshold + '%)';
  } else {
    reasonEl.textContent = reason + ` - Ø§Ù„Ø«Ù‚Ø©: ${pred.confidence.toFixed(1)}%`;
  }
}

function calculateModelEfficiency() {
  const total = Object.values(state.modelPerformance).reduce((a, b) => a + b, 0);
  const current = state.modelPerformance[state.analysisMode] || 0;
  return total > 0 ? Math.round((current / total) * 100) : 0;
}

function showResult(r, pred, didWin) {
  const finalCard = el('finalCard');
  if (!finalCard) return;
  
  finalCard.classList.remove('win-effect', 'loss-effect');
  setTimeout(() => {
    finalCard.classList.add(didWin ? 'win-effect' : 'loss-effect');
  }, 10);
}

function updateMLStatus() {
  const trainingCount = state.ml.getTrainingDataCount();
  const mlWeight = state.ml.getMLWeight() * 100;
  const mlAccuracy = state.ml.getModelAccuracy(state.mlModel);
  
  el('mlTrainingCount').textContent = trainingCount;
  el('mlWeight').textContent = mlWeight.toFixed(0) + '%';
  el('mlAccuracy').textContent = mlAccuracy.toFixed(1) + '%';
  
  const statusEl = el('mlStatus');
  if (!statusEl) return;
  
  if (trainingCount < 5) {
    statusEl.innerHTML = '<span class="ml-training-indicator ml-not-trained"></span> ÙŠØ­ØªØ§Ø¬ Ø§Ù„Ù…Ø²ÙŠØ¯ Ù…Ù† Ø§Ù„Ø¨ÙŠØ§Ù†Ø§Øª';
    statusEl.style.color = '#ff006e';
  } else if (trainingCount < 15) {
    statusEl.innerHTML = '<span class="ml-training-indicator ml-training"></span> ÙŠØªØ¹Ù„Ù…...';
    statusEl.style.color = '#d4af37';
  } else {
    statusEl.innerHTML = '<span class="ml-training-indicator ml-training"></span> Ø¬Ø§Ù‡Ø² Ù„Ù„ØªÙ†Ø¨Ø¤';
    statusEl.style.color = '#38b000';
  }
  
  el('mlOverallAccuracy').textContent = mlAccuracy.toFixed(1) + '%';
}

function updateAll() {
  renderStats();
  renderBigRoad();
  updatePredictionCounts();
  updateAccuracyStats();
  updateAccuracyChart();
  updatePatternInfo();
  updateMLStats();
  updateDataStatsDisplay();
  state.voiceAssistant.updateMood();
  state.voiceAssistant.updateConversationCount();
}

function updateDataStatsDisplay() {
  dataManager.updateDataStats();
}

function updateMLStats() {
  const mlAccuracy = state.ml.getModelAccuracy(state.mlModel);
  el('mlOverallAccuracy').textContent = mlAccuracy.toFixed(1) + '%';
  
  // ØªØ­Ø¯ÙŠØ« Ø¯Ù‚Ø© ML Ù„ÙƒÙ„ Ù†ÙˆØ¹ (Ù…Ø¨Ø³Ø·Ø©)
  const mlOverall = mlAccuracy;
  el('pMLAccuracy').textContent = (mlOverall * 0.9).toFixed(1) + '%';
  el('bMLAccuracy').textContent = (mlOverall * 0.95).toFixed(1) + '%';
  el('tMLAccuracy').textContent = (mlOverall * 0.7).toFixed(1) + '%';
}

function renderStats() {
  el('pTotal').textContent = state.count.P;
  el('bTotal').textContent = state.count.B;
  el('tTotal').textContent = state.count.T;
  
  el('pWin').textContent = state.win.P;
  el('bWin').textContent = state.win.B;
  el('tWin').textContent = state.win.T;
  
  el('pLoss').textContent = state.loss.P;
  el('bLoss').textContent = state.loss.B;
  el('tLoss').textContent = state.loss.T;
  
  el('pPct').textContent = calculatePercentage(state.win.P, state.loss.P);
  el('bPct').textContent = calculatePercentage(state.win.B, state.loss.B);
  el('tPct').textContent = calculatePercentage(state.win.T, state.loss.T);
  
  el('pAccuracy').textContent = calculateAccuracy('P');
  el('bAccuracy').textContent = calculateAccuracy('B');
  el('tAccuracy').textContent = calculateAccuracy('T');
}

function calculatePercentage(win, loss) {
  const total = win + loss;
  return total > 0 ? ((win / total) * 100).toFixed(1) + '%' : '0%';
}

function calculateAccuracy(type) {
  const totalPredictions = state.predictionsHistory.filter(p => p.prediction === type).length;
  const correctPredictions = state.predictionsHistory.filter(p => p.prediction === type && p.correct).length;
  return totalPredictions > 0 ? ((correctPredictions / totalPredictions) * 100).toFixed(1) + '%' : '0%';
}

function renderBigRoad() {
  const canvas = el('bigRoad');
  if (!canvas) return;
  
  const ctx = canvas.getContext('2d');
  ctx.clearRect(0, 0, canvas.width, canvas.height);
  
  const size = 35;
  let x = 0, y = 0;
  const maxCols = Math.floor(canvas.width / size);
  
  for (let i = 0; i < state.rounds.length; i++) {
    const r = state.rounds[i];
    
    ctx.fillStyle = r === 'P' ? '#3a86ff' : r === 'B' ? '#ff006e' : '#38b000';
    ctx.fillRect(x * size, y * size, size - 2, size - 2);
    
    ctx.fillStyle = '#ffffff';
    ctx.font = 'bold 14px Inter';
    ctx.textAlign = 'center';
    ctx.textBaseline = 'middle';
    ctx.fillText((i+1).toString(), x * size + size/2, y * size + size/2);
    
    y++;
    if (y * size >= canvas.height) {
      y = 0;
      x++;
      if (x >= maxCols) break;
    }
  }
}

function updatePredictionCounts() {
  const pred = enhancedPredict();
  updatePredictionDisplay(pred);
}

function updatePatternInfo() {
  const infoEl = el('patternInfo');
  if (!infoEl) return;
  
  if (state.rounds.length < 3) {
    infoEl.textContent = 'Ù„Ø§ ØªÙˆØ¬Ø¯ Ø£Ù†Ù…Ø§Ø· Ù…ÙƒØªØ´ÙØ© Ø¨Ø¹Ø¯';
    return;
  }
  
  const trend = calculateTrend(state.rounds);
  const recent = state.rounds.slice(-5);
  const pCount = recent.filter(r => r === 'P').length;
  const bCount = recent.filter(r => r === 'B').length;
  const tCount = recent.filter(r => r === 'T').length;
  
  let info = `Ø§Ù„Ø§ØªØ¬Ø§Ù‡: ${trend.direction === 'volatile' ? 'Ù…ØªÙ‚Ù„Ø¨' : trend.direction === 'mixed' ? 'Ù…Ø®ØªÙ„Ø·' : 'Ù…Ø³ØªÙ‚Ø±'}`;
  info += ` | Ø¢Ø®Ø± 5: ğŸ”µ${pCount} ğŸ”´${bCount} ğŸŸ¢${tCount}`;
  
  infoEl.textContent = info;
}

function calculateTrend(rounds) {
  if (rounds.length < 2) return { direction: 'stable', strength: 0 };
  
  const changes = [];
  for (let i = 1; i < rounds.length; i++) {
    changes.push(rounds[i] === rounds[i-1] ? 0 : 1);
  }
  
  const changeRate = changes.reduce((a, b) => a + b, 0) / changes.length;
  return {
    direction: changeRate > 0.6 ? 'volatile' : changeRate > 0.4 ? 'mixed' : 'stable',
    strength: Math.abs(changeRate - 0.5) * 2
  };
}

function updateAccuracyData(actualResult) {
  if (state.lastPrediction && state.lastPrediction !== 'â€”') {
    const isCorrect = state.lastPrediction === actualResult;
    state.predictionsHistory.push({
      prediction: state.lastPrediction,
      actual: actualResult,
      correct: isCorrect,
      model: state.analysisMode
    });
    
    const correctPredictions = state.predictionsHistory.filter(p => p.correct).length;
    const totalPredictions = state.predictionsHistory.length;
    const accuracy = totalPredictions > 0 ? (correctPredictions / totalPredictions) * 100 : 0;
    
    state.accuracyHistory.push(accuracy);
  }
}

function updateAccuracyStats() {
  if (state.accuracyHistory.length === 0) {
    el('currentAccuracy').textContent = '0%';
    el('bestAccuracy').textContent = '0%';
    el('averageAccuracy').textContent = '0%';
    return;
  }
  
  const currentAccuracy = state.accuracyHistory[state.accuracyHistory.length - 1];
  const bestAccuracy = Math.max(...state.accuracyHistory);
  const averageAccuracy = state.accuracyHistory.reduce((a, b) => a + b, 0) / state.accuracyHistory.length;
  
  el('currentAccuracy').textContent = currentAccuracy.toFixed(1) + '%';
  el('bestAccuracy').textContent = bestAccuracy.toFixed(1) + '%';
  el('averageAccuracy').textContent = averageAccuracy.toFixed(1) + '%';
}

function updateAccuracyChart() {
  const svg = el('accuracyChart');
  const tooltip = el('accuracyTooltip');
  if (!svg || !tooltip) return;
  
  svg.innerHTML = '';
  
  if (state.accuracyHistory.length < 2) return;
  
  const width = svg.clientWidth || 600;
  const height = svg.clientHeight || 80;
  const padding = 20;
  
  // Ø±Ø³Ù… Ø§Ù„Ø´Ø¨ÙƒØ©
  for (let i = 0; i <= 100; i += 20) {
    const y = height - padding - (i / 100) * (height - 2 * padding);
    const line = document.createElementNS('http://www.w3.org/2000/svg', 'line');
    line.setAttribute('class', 'accuracy-grid');
    line.setAttribute('x1', padding);
    line.setAttribute('y1', y);
    line.setAttribute('x2', width - padding);
    line.setAttribute('y2', y);
    svg.appendChild(line);
    
    const text = document.createElementNS('http://www.w3.org/2000/svg', 'text');
    text.setAttribute('x', padding - 5);
    text.setAttribute('y', y + 4);
    text.setAttribute('text-anchor', 'end');
    text.setAttribute('fill', 'var(--muted)');
    text.setAttribute('font-size', '10px');
    text.textContent = i + '%';
    svg.appendChild(text);
  }
  
  // Ø±Ø³Ù… Ø§Ù„Ø®Ø·
  const path = document.createElementNS('http://www.w3.org/2000/svg', 'path');
  let pathData = '';
  
  state.accuracyHistory.forEach((accuracy, index) => {
    const x = padding + (index / (state.accuracyHistory.length - 1)) * (width - 2 * padding);
    const y = height - padding - (accuracy / 100) * (height - 2 * padding);
    
    if (index === 0) {
      pathData = `M ${x} ${y}`;
    } else {
      pathData += ` L ${x} ${y}`;
    }
    
    // Ù†Ù‚Ø§Ø· ØªÙØ§Ø¹Ù„ÙŠØ©
    const point = document.createElementNS('http://www.w3.org/2000/svg', 'circle');
    point.setAttribute('class', 'accuracy-point');
    point.setAttribute('cx', x);
    point.setAttribute('cy', y);
    point.setAttribute('r', 3);
    
    point.addEventListener('mouseover', (e) => {
      const rect = svg.getBoundingClientRect();
      tooltip.style.left = (e.clientX - rect.left + 10) + 'px';
      tooltip.style.top = (e.clientY - rect.top - 30) + 'px';
      tooltip.textContent = `Ø§Ù„Ø¬ÙˆÙ„Ø© ${index + 1}: ${accuracy.toFixed(1)}%`;
      tooltip.style.opacity = '1';
    });
    
    point.addEventListener('mouseout', () => {
      tooltip.style.opacity = '0';
    });
    
    svg.appendChild(point);
  });
  
  path.setAttribute('d', pathData);
  path.setAttribute('class', 'accuracy-line');
  svg.appendChild(path);
}

// ØªÙ‡ÙŠØ¦Ø© Ø§Ù„ØªØ·Ø¨ÙŠÙ‚ Ø¹Ù†Ø¯ ØªØ­Ù…ÙŠÙ„ Ø§Ù„ØµÙØ­Ø©
window.addEventListener('DOMContentLoaded', init);
</script>
</body>
</html>
