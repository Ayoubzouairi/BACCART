<!doctype html>
<html lang="ar" dir="rtl">
<head>
<meta charset="utf-8">
<meta name="viewport" content="width=device-width,initial-scale=1">
<title>AYOUB BACCARAT PRO - Ø§Ù„Ù…Ø³Ø§Ø¹Ø¯ Ø§Ù„ØµÙˆØªÙŠ Ø§Ù„Ø°ÙƒÙŠ ğŸ¤</title>
<style>
@import url('https://fonts.googleapis.com/css2?family=Inter:wght@300;400;600;800&display=swap');
:root{--gold:#d4af37;--gold-2:#b8871d;--bg-dark:#070606;--card:#0f0e10;--muted:#bfb7a6;--player:#2d7ef7;--banker:#e03b3b;--tie:#28a745;}
:root[data-theme="light"]{--gold:#d4af37;--gold-2:#b8871d;--bg-dark:#f5f5f5;--card:#ffffff;--muted:#666666;--player:#2d7ef7;--banker:#e03b3b;--tie:#28a745;}
*{box-sizing:border-box;margin:0;padding:0;}
body{font-family:Inter,sans-serif;margin:0;background:linear-gradient(180deg,var(--bg-dark),#0b0b0b);color:#fff;padding:18px;transition:background 0.3s, color 0.3s;min-height:100vh;}
:root[data-theme="light"] body{color:#333;}
.app{max-width:1200px;margin:0 auto;width:100%;}
.top{display:flex;align-items:center;justify-content:space-between;gap:12px;margin-bottom:14px;flex-wrap:wrap;}
.logo{font-weight:800;background:linear-gradient(90deg,var(--gold),#fff3b0);color:#000;padding:8px 12px;border-radius:12px;display:inline-block;font-size:1.2rem;}
.subtitle{font-size:14px;color:var(--muted);margin-top:4px;}
.controls{display:flex;gap:8px;align-items:center;flex-wrap:wrap;}
.card{background:linear-gradient(180deg,var(--card),#0b0b0b);border-radius:12px;padding:12px;box-shadow:0 8px 30px rgba(0,0,0,0.6);border:1px solid rgba(212,175,55,0.08);margin-bottom:10px;}
:root[data-theme="light"] .card{background:linear-gradient(180deg,var(--card),#f0f0f0);box-shadow:0 8px 30px rgba(0,0,0,0.1);border:1px solid rgba(0,0,0,0.05);}
.layout{display:flex;gap:12px;flex-wrap:wrap;}
.left{width:360px;min-width:300px;display:flex;flex-direction:column;gap:10px;flex:1;}
.right{flex:2;display:flex;flex-direction:column;gap:12px;min-width:300px;}
.panel{padding:10px;}
.row{display:flex;gap:8px;align-items:center;margin-top:8px;}
input[type=number], select{background:rgba(255,255,255,0.1);border:2px solid rgba(255,255,255,0.3);padding:10px;border-radius:8px;color:#fff;font-weight:600;font-size:14px;width:100%;}
:root[data-theme="light"] input[type=number], :root[data-theme="light"] select{background:rgba(255,255,255,0.9);border:2px solid rgba(0,0,0,0.2);color:#333;}
.btn{padding:12px 16px;border-radius:8px;border:0;color:#fff;cursor:pointer;font-weight:600;font-size:16px;transition:all 0.3s;text-align:center;min-width:70px;}
.btn:hover{transform:translateY(-2px);box-shadow:0 4px 12px rgba(0,0,0,0.3);}
.btn:active{transform:translateY(0);}
.btn.gold{background:linear-gradient(90deg,var(--gold),var(--gold-2));color:#000;font-weight:700;box-shadow:0 6px 20px rgba(212,175,55,0.3);}
.btn.player{background:linear-gradient(135deg, #3a86ff, #2667cc); color:white; border:2px solid #3a86ff;}
.btn.banker{background:linear-gradient(135deg, #ff006e, #cc0058); color:white; border:2px solid #ff006e;}
.btn.tie{background:linear-gradient(135deg, #38b000, #2c8a00); color:white; border:2px solid #38b000;}
:root[data-theme="light"] .btn.player{background:linear-gradient(135deg, #2d7ef7, #1a67d8); color:white;}
:root[data-theme="light"] .btn.banker{background:linear-gradient(135deg, #e03b3b, #c53232); color:white;}
:root[data-theme="light"] .btn.tie{background:linear-gradient(135deg, #28a745, #218838); color:white;}
:root[data-theme="light"] .btn{background:rgba(0,0,0,0.1);color:#333; border:1px solid rgba(0,0,0,0.1)}
.small{font-size:13px;color:var(--muted);}
.muted{color:var(--muted);font-size:12px;}
.section-title{font-weight:700;margin-bottom:6px;color:var(--gold);font-size:1.1rem;}
.stat-table{width:100%;border-collapse:collapse;font-size:13px;}
.stat-table th,.stat-table td{border:1px solid rgba(255,255,255,0.05);padding:6px;text-align:center;}
:root[data-theme="light"] .stat-table th, :root[data-theme="light"] .stat-table td{border:1px solid rgba(0,0,0,0.05);}
.stat-table th{background:rgba(212,175,55,0.1);font-weight:600;}
.player{color:#3a86ff;font-weight:700;}
.banker{color:#ff006e;font-weight:700;}
.tie{color:#38b000;font-weight:700;}
.pred-head{display:flex;justify-content:space-between;align-items:center;flex-wrap:wrap;gap:10px;}
.final{font-size:22px;font-weight:800;text-align:center;padding:12px;background:linear-gradient(90deg,rgba(212,175,55,0.06),transparent);border-radius:10px;margin:10px 0;}
:root[data-theme="light"] .final{background:linear-gradient(90deg,rgba(212,175,55,0.1),transparent);}
.foot{display:flex;justify-content:space-between;align-items:center;margin-top:14px;flex-wrap:wrap;gap:10px;}
.credits{opacity:0.85;font-size:12px;}
canvas{border-radius:10px;background:#0f0e10;width:100% !important;height:auto !important;max-height:450px;}
:root[data-theme="light"] canvas{background:#f0f0f0;}
.color-legend{display:flex;gap:15px;justify-content:center;margin-bottom:10px;font-size:14px;flex-wrap:wrap;}
.color-legend span{padding:4px 8px;border-radius:6px; font-weight:600;}
.prediction-cards{display:flex;gap:10px;justify-content:center;margin:10px 0;flex-wrap:wrap;}
.pred-card{padding:10px;border-radius:8px;text-align:center;min-width:80px; font-weight:600;flex:1;}
.pred-card.active{transform:scale(1.05);border:2px solid var(--gold); box-shadow:0 4px 15px rgba(212,175,55,0.4);}
.win-effect{animation:winPulse 0.5s ease-in-out;}
.loss-effect{animation:lossShake 0.5s ease-in-out;}
@keyframes winPulse{0%{transform:scale(1)}50%{transform:scale(1.1)}100%{transform:scale(1)}}
@keyframes lossShake{0%,100%{transform:translateX(0)}25%{transform:translateX(-5px)}75%{transform:translateX(5px)}}
.analysis-result{margin-top:10px;padding:10px;background:rgba(255,255,255,0.03);border-radius:8px;text-align:center;}
:root[data-theme="light"] .analysis-result{background:rgba(0,0,0,0.03);}
.theme-toggle{background:transparent;border:none;font-size:24px;cursor:pointer;padding:5px;border-radius:50%;transition:background 0.3s;width:40px;height:40px;display:flex;align-items:center;justify-content:center;}
.theme-toggle:hover{background:rgba(255,255,255,0.1);}
:root[data-theme="light"] .theme-toggle:hover{background:rgba(0,0,0,0.05);}
.input-group {display: flex; gap: 8px; align-items:center;}
.input-group input {flex: 1;}
.input-label {font-weight: 600; margin-bottom: 6px; display: block;}
.pred-card.player {background: linear-gradient(135deg, #3a86ff, #2667cc); color: white;}
.pred-card.banker {background: linear-gradient(135deg, #ff006e, #cc0058); color: white;}
.pred-card.tie {background: linear-gradient(135deg, #38b000, #2c8a00); color: white;}

/* Ø£Ù†Ù…Ø§Ø· Ø¬Ø¯ÙŠØ¯Ø© Ù„Ù„Ù…Ø³Ø§Ø¹Ø¯ Ø§Ù„ØµÙˆØªÙŠ */
.voice-assistant-container {
    position: fixed;
    bottom: 20px;
    left: 20px;
    z-index: 1000;
}

.voice-assistant-btn {
    width: 60px;
    height: 60px;
    border-radius: 50%;
    background: linear-gradient(135deg, #9d4edd, #7b2cbf);
    border: none;
    color: white;
    font-size: 24px;
    cursor: pointer;
    display: flex;
    align-items: center;
    justify-content: center;
    box-shadow: 0 4px 15px rgba(157, 78, 221, 0.4);
    transition: all 0.3s;
    position: relative;
}

.voice-assistant-btn:hover {
    transform: scale(1.1);
    box-shadow: 0 6px 20px rgba(157, 78, 221, 0.6);
}

.voice-assistant-btn.listening {
    background: linear-gradient(135deg, #ff006e, #cc0058);
    animation: pulse 1.5s infinite;
}

.voice-assistant-btn.responding {
    background: linear-gradient(135deg, #38b000, #2c8a00);
    animation: pulse 1s infinite;
}

.voice-assistant-panel {
    position: absolute;
    bottom: 70px;
    left: 0;
    width: 400px;
    max-width: 90vw;
    background: var(--card);
    border-radius: 12px;
    padding: 15px;
    box-shadow: 0 8px 30px rgba(0,0,0,0.6);
    border: 1px solid rgba(212,175,55,0.2);
    display: none;
}

.voice-assistant-panel.active {
    display: block;
    animation: slideUp 0.3s ease-out;
}

.voice-header {
    display: flex;
    justify-content: space-between;
    align-items: center;
    margin-bottom: 15px;
    padding-bottom: 10px;
    border-bottom: 1px solid rgba(255,255,255,0.1);
}

.voice-title {
    font-weight: 700;
    font-size: 16px;
    color: var(--gold);
}

.voice-close {
    background: none;
    border: none;
    color: var(--muted);
    font-size: 20px;
    cursor: pointer;
    padding: 5px;
    border-radius: 50%;
    transition: background 0.3s;
}

.voice-close:hover {
    background: rgba(255,255,255,0.1);
}

.voice-messages {
    height: 200px;
    overflow-y: auto;
    margin-bottom: 15px;
    padding: 10px;
    background: rgba(255,255,255,0.03);
    border-radius: 8px;
}

.voice-message {
    margin-bottom: 10px;
    padding: 8px 12px;
    border-radius: 8px;
    max-width: 80%;
    animation: fadeIn 0.3s ease-out;
}

.voice-message.user {
    background: rgba(59, 130, 246, 0.2);
    border-left: 3px solid #3a86ff;
    margin-left: auto;
    margin-right: 0;
}

.voice-message.assistant {
    background: rgba(157, 78, 221, 0.2);
    border-left: 3px solid #9d4edd;
    margin-right: auto;
    margin-left: 0;
}

.voice-message.system {
    background: rgba(255, 255, 255, 0.05);
    border-left: 3px solid var(--gold);
    font-size: 11px;
    padding: 5px 8px;
    text-align: center;
    max-width: 100%;
}

.voice-status {
    display: flex;
    align-items: center;
    gap: 10px;
    margin-bottom: 10px;
    padding: 8px;
    background: rgba(255,255,255,0.05);
    border-radius: 8px;
}

.status-indicator {
    width: 10px;
    height: 10px;
    border-radius: 50%;
    background: #ff006e;
}

.status-indicator.active {
    background: #38b000;
    animation: pulse 1s infinite;
}

.status-text {
    font-size: 12px;
    color: var(--muted);
}

.voice-controls {
    display: flex;
    gap: 10px;
}

.voice-control-btn {
    flex: 1;
    padding: 8px 12px;
    border-radius: 8px;
    border: none;
    color: white;
    cursor: pointer;
    font-weight: 600;
    font-size: 14px;
    display: flex;
    align-items: center;
    justify-content: center;
    gap: 5px;
    transition: all 0.3s;
}

.voice-control-btn.primary {
    background: linear-gradient(135deg, #9d4edd, #7b2cbf);
}

.voice-control-btn.primary:hover {
    background: linear-gradient(135deg, #8a3cc8, #6a21b3);
}

.voice-control-btn.secondary {
    background: rgba(255,255,255,0.1);
    border: 1px solid rgba(255,255,255,0.2);
}

.voice-control-btn.secondary:hover {
    background: rgba(255,255,255,0.2);
}

.voice-control-btn.danger {
    background: linear-gradient(135deg, #ff006e, #cc0058);
}

.voice-control-btn.danger:hover {
    background: linear-gradient(135deg, #e60063, #b3004d);
}

.voice-quick-commands {
    display: grid;
    grid-template-columns: repeat(2, 1fr);
    gap: 8px;
    margin-top: 10px;
}

.voice-quick-btn {
    padding: 6px 8px;
    background: rgba(157, 78, 221, 0.1);
    border: 1px solid rgba(157, 78, 221, 0.3);
    border-radius: 6px;
    color: #bfb7a6;
    font-size: 11px;
    cursor: pointer;
    transition: all 0.3s;
    text-align: center;
}

.voice-quick-btn:hover {
    background: rgba(157, 78, 221, 0.2);
    transform: translateY(-1px);
}

.voice-settings {
    margin-top: 15px;
    padding-top: 10px;
    border-top: 1px solid rgba(255,255,255,0.1);
}

.setting-group {
    display: flex;
    justify-content: space-between;
    align-items: center;
    margin-bottom: 8px;
}

.setting-label {
    font-size: 12px;
    color: var(--muted);
}

/* Ø£Ù†ÙŠÙ…ÙŠØ´Ù† */
@keyframes pulse {
    0% { transform: scale(1); }
    50% { transform: scale(1.05); }
    100% { transform: scale(1); }
}

@keyframes slideUp {
    from { transform: translateY(20px); opacity: 0; }
    to { transform: translateY(0); opacity: 1; }
}

@keyframes fadeIn {
    from { opacity: 0; transform: translateY(10px); }
    to { opacity: 1; transform: translateY(0); }
}

/* ØªØ­Ø³ÙŠÙ†Ø§Øª Ù„Ù„Ø§Ø³ØªØ¬Ø§Ø¨Ø© */
@media (max-width: 768px) {
    .layout {flex-direction: column;}
    .left, .right {width: 100%;}
    .top {flex-direction: column; align-items: flex-start;}
    .controls {width: 100%; justify-content: space-between;}
    .prediction-cards {flex-direction: column;}
    .pred-card {width: 100%;}
    .color-legend {justify-content: flex-start;}
    .voice-assistant-panel {
        width: 350px;
        left: -150px;
    }
}

@media (max-width: 480px) {
    body {padding: 10px;}
    .card {padding: 8px;}
    .btn {padding: 10px 12px; font-size: 14px;}
    .voice-assistant-panel {
        width: 320px;
        left: -130px;
    }
    .voice-quick-commands {
        grid-template-columns: 1fr;
    }
}
</style>
</head>
<body>
<div class="app">
<header class="top card">
  <div class="brand">
    <div class="logo">AYOUB BACCARAT PRO <span style="background: linear-gradient(135deg, #9d4edd, #7b2cbf); color: white; padding: 2px 8px; border-radius: 12px; font-size: 10px; margin-left: 5px;">ğŸ¤ Ø§Ù„Ù…Ø³Ø§Ø¹Ø¯ Ø§Ù„ØµÙˆØªÙŠ</span></div>
    <div class="subtitle">Ù†Ø¸Ø§Ù… ØªÙ†Ø¨Ø¤ Ø°ÙƒÙŠ Ù…Ø¹ Ù…Ø³Ø§Ø¹Ø¯ ØµÙˆØªÙŠ Ù…Ø¨Ø§Ø´Ø± Ù„Ù„Ø­ØµÙˆÙ„ Ø¹Ù„Ù‰ Ø§Ù„Ù†ØµØ§Ø¦Ø­ Ø£Ø«Ù†Ø§Ø¡ Ø§Ù„Ù„Ø¹Ø¨ ğŸ§ ğŸ¤ğŸš€</div>
  </div>
  <div class="controls">
    <button id="themeToggle" class="theme-toggle" title="ØªØ¨Ø¯ÙŠÙ„ Ø§Ù„ÙˆØ¶Ø¹">ğŸŒš</button>
    <button id="btnReset" class="btn gold">Ø¥Ø¹Ø§Ø¯Ø© ØªØ¹ÙŠÙŠÙ†</button>
  </div>
</header>

<main class="layout">
<aside class="left">
  <div class="panel card">
    <label class="input-label">Ù†Ø§ÙØ°Ø© Ø§Ù„ØªØ­Ù„ÙŠÙ„ (5 - 15)</label>
    <div class="input-group">
      <input id="windowSize" type="number" min="5" max="15" value="8">
      <button id="applyWindow" class="btn gold">ØªØ·Ø¨ÙŠÙ‚</button>
    </div>
    <div class="muted small">ÙŠØ­Ù„Ù„ Ø¢Ø®Ø± 5-15 Ø¬ÙˆÙ„Ø© Ø¨Ø§Ø³ØªØ®Ø¯Ø§Ù… Ø®ÙˆØ§Ø±Ø²Ù…ÙŠØ§Øª Ù…ØªÙ‚Ø¯Ù…Ø©</div>
  </div>

  <!-- Ø¥Ø¹Ø¯Ø§Ø¯Ø§Øª Ø§Ù„ØªÙ†Ø¨Ø¤ Ø§Ù„Ù…ØªÙ‚Ø¯Ù… -->
  <div class="panel card">
    <div class="section-title">Ø¥Ø¹Ø¯Ø§Ø¯Ø§Øª Ø§Ù„ØªÙ†Ø¨Ø¤ Ø§Ù„Ù…ØªÙ‚Ø¯Ù…</div>
    <div class="advanced-controls">
      <div class="control-group">
        <label for="analysisMode">Ù†Ù…Ø· Ø§Ù„ØªØ­Ù„ÙŠÙ„:</label>
        <select id="analysisMode">
          <option value="basic">Ø£Ø³Ø§Ø³ÙŠ <span class="model-badge badge-basic">+5%</span></option>
          <option value="advanced" selected>Ù…ØªÙ‚Ø¯Ù… <span class="model-badge badge-advanced">+15%</span></option>
          <option value="pattern">ØªØ­Ù„ÙŠÙ„ Ø§Ù„Ø£Ù†Ù…Ø§Ø· <span class="model-badge badge-pattern">+25%</span></option>
          <option value="ml">ØªØ¹Ù„Ù… Ø§Ù„Ø¢Ù„Ø© <span class="model-badge badge-ml">+35%</span></option>
        </select>
      </div>
      <div class="control-group">
        <label for="confidenceSensitivity">Ø­Ø³Ø§Ø³ÙŠØ© Ø§Ù„Ø«Ù‚Ø©:</label>
        <div class="slider-container">
          <input type="range" id="confidenceSensitivity" class="slider" min="30" max="60" value="45">
          <div class="muted small" id="sensitivityValue">45%</div>
        </div>
      </div>
      <div class="control-group">
        <label for="timeWeighting">Ø§Ù„Ù…Ø±Ø¬Ø­Ø© Ø§Ù„Ø²Ù…Ù†ÙŠØ©:</label>
        <select id="timeWeighting">
          <option value="none">Ø¨Ø¯ÙˆÙ†</option>
          <option value="linear" selected>Ø®Ø·ÙŠ</option>
          <option value="exponential">Ø£Ø³Ù‘ÙŠ</option>
        </select>
      </div>
    </div>
  </div>

  <!-- Ù‚Ø³Ù… ØªØ¹Ù„Ù… Ø§Ù„Ø¢Ù„Ø© -->
  <div class="panel card ml-info-panel">
    <div class="section-title">âš™ï¸ ØªØ¹Ù„Ù… Ø§Ù„Ø¢Ù„Ø©</div>
    <div class="row">
      <label class="switch">
        <input type="checkbox" id="mlToggle" checked>
        <span class="slider"></span>
      </label>
      <span>ØªÙØ¹ÙŠÙ„ ØªØ¹Ù„Ù… Ø§Ù„Ø¢Ù„Ø©</span>
    </div>
    <div class="row">
      <select id="mlModelSelect" style="flex:1; margin-top: 5px;">
        <option value="knn">K-Ø§Ù„Ø¬ÙŠØ±Ø§Ù† Ø§Ù„Ø£Ù‚Ø±Ø¨</option>
        <option value="logistic">Ø§Ù„Ø§Ù†Ø­Ø¯Ø§Ø± Ø§Ù„Ù„ÙˆØ¬Ø³ØªÙŠ</option>
        <option value="ensemble" selected>Ø§Ù„Ù…Ø¬Ù…Ø¹ (Ø¬Ù…ÙŠØ¹ Ø§Ù„Ù†Ù…Ø§Ø°Ø¬)</option>
      </select>
    </div>
    <div class="row">
      <div id="mlStatus" class="muted small">
        <span class="ml-training-indicator ml-training"></span> 
        Ø§Ù„Ù†Ù…ÙˆØ°Ø¬ ÙŠØªØ¹Ù„Ù… Ù…Ù† Ø§Ù„Ø¨ÙŠØ§Ù†Ø§Øª...
      </div>
    </div>
    <div class="pattern-info">
      <span id="mlTrainingCount">0</span> Ø¹ÙŠÙ†Ø© ØªØ¯Ø±ÙŠØ¨ â€¢ 
      <span id="mlAccuracy">0%</span> Ø¯Ù‚Ø© â€¢ 
      <span id="mlWeight">30%</span> ØªØ£Ø«ÙŠØ±
    </div>
  </div>

  <!-- Ø¥Ø¯Ø®Ø§Ù„ Ø§Ù„Ù†ØªØ§Ø¦Ø¬ -->
  <div class="panel card">
    <div class="section-title">Ø¥Ø¯Ø®Ø§Ù„ Ø§Ù„Ù†ØªØ§Ø¦Ø¬</div>
    <div class="row">
      <button class="btn player" id="btnP">Ù„Ø§Ø¹Ø¨ ğŸ”µ</button>
      <button class="btn banker" id="btnB">Ù…ØµØ±ÙÙŠ ğŸ”´</button>
      <button class="btn tie" id="btnT">ØªØ¹Ø§Ø¯Ù„ ğŸŸ¢</button>
    </div>
    <div class="row">
      <button class="btn" id="btnUndo" style="flex:1; background:rgba(255,255,255,0.1); border:1px solid rgba(255,255,255,0.2)">ØªØ±Ø§Ø¬Ø¹</button>
    </div>
    <div class="muted small" style="margin-top: 8px; text-align: center;">
      Ø£Ø¯Ø®Ù„ Ù†ØªÙŠØ¬Ø© ÙƒÙ„ Ø¬ÙˆÙ„Ø© Ø¨Ø§Ù„Ø¶ØºØ· Ø¹Ù„Ù‰ Ø§Ù„Ø²Ø± Ø§Ù„Ù…Ù†Ø§Ø³Ø¨
    </div>
  </div>

  <!-- Ø§Ù„Ø¥Ø­ØµØ§Ø¡Ø§Øª -->
  <div class="panel card stats">
    <div class="section-title">Ø§Ù„Ø¥Ø­ØµØ§Ø¡Ø§Øª Ø§Ù„Ù…ØªÙ‚Ø¯Ù…Ø©</div>
    <table class="stat-table">
      <thead>
        <tr><th>Ø§Ù„Ø¬Ù‡Ø©</th><th>Ø§Ù„Ù…Ø¬Ù…ÙˆØ¹</th><th>ÙÙˆØ²</th><th>Ø®Ø³Ø§Ø±Ø©</th><th>Ù†Ø³Ø¨Ø© %</th><th>Ø¯Ù‚Ø©</th><th>ML Ø¯Ù‚Ø©</th></tr>
      </thead>
      <tbody>
        <tr><td class="player">Ù„Ø§Ø¹Ø¨</td><td id="pTotal">0</td><td id="pWin">0</td><td id="pLoss">0</td><td id="pPct">0%</td><td id="pAccuracy">0%</td><td id="pMLAccuracy">0%</td></tr>
        <tr><td class="banker">Ù…ØµØ±ÙÙŠ</td><td id="bTotal">0</td><td id="bWin">0</td><td id="bLoss">0</td><td id="bPct">0%</td><td id="bAccuracy">0%</td><td id="bMLAccuracy">0%</td></tr>
        <tr><td class="tie">ØªØ¹Ø§Ø¯Ù„</td><td id="tTotal">0</td><td id="tWin">0</td><td id="tLoss">0</td><td id="tPct">0%</td><td id="tAccuracy">0%</td><td id="tMLAccuracy">0%</td></tr>
      </tbody>
    </table>
    <div class="pattern-info" id="patternInfo">Ù„Ø§ ØªÙˆØ¬Ø¯ Ø£Ù†Ù…Ø§Ø· Ù…ÙƒØªØ´ÙØ© Ø¨Ø¹Ø¯</div>
  </div>

  <!-- Ù…Ø¤Ø´Ø± Ø§Ù„Ø«Ù‚Ø© -->
  <div class="panel card">
    <div class="section-title">Ù…Ø¤Ø´Ø± Ø§Ù„Ø«Ù‚Ø©</div>
    <div class="muted small" id="confidenceLabel">Ø«Ù‚Ø© Ù…Ù†Ø®ÙØ¶Ø©</div>
    <div class="confidence-meter">
      <div class="confidence-fill" id="confidenceFill" style="width: 0%"></div>
    </div>
    <div class="pattern-info" id="modelInfo">Ø§Ù„Ù†Ù…ÙˆØ°Ø¬: Ø£Ø³Ø§Ø³ÙŠ</div>
  </div>
</aside>

<section class="right">
  <div class="card prediction">
    <div class="pred-head">
      <div class="pred-title">ØªÙˆÙ‚Ø¹ Ø§Ù„Ø¬ÙˆÙ„Ø© Ø§Ù„Ù‚Ø§Ø¯Ù…Ø© <span id="predModel" class="model-badge badge-basic">Ø£Ø³Ø§Ø³ÙŠ</span></div>
      <div class="pred-sub">Ù†Ø¸Ø§Ù… ØªÙ†Ø¨Ø¤ Ù…ØªØ¹Ø¯Ø¯ Ø§Ù„Ù†Ù…Ø§Ø°Ø¬ Ù…Ø¹ Ø®ÙˆØ§Ø±Ø²Ù…ÙŠØ§Øª ØªØ¹Ù„Ù… Ø¢Ù„Ø©</div>
    </div>

    <div class="color-legend">
      <span style="background:linear-gradient(135deg, #3a86ff, #2667cc);">ğŸ”µ Ù„Ø§Ø¹Ø¨</span>
      <span style="background:linear-gradient(135deg, #ff006e, #cc0058);">ğŸ”´ Ù…ØµØ±ÙÙŠ</span>
      <span style="background:linear-gradient(135deg, #38b000, #2c8a00);">ğŸŸ¢ ØªØ¹Ø§Ø¯Ù„</span>
    </div>
    
    <canvas id="bigRoad" width="800" height="450"></canvas>

    <div class="prediction-cards">
      <div class="pred-card player" id="predP">
        <div>Ù„Ø§Ø¹Ø¨</div>
        <div id="predPctP">0%</div>
        <div class="muted small" id="predTrendP">â†’</div>
      </div>
      <div class="pred-card banker" id="predB">
        <div>Ù…ØµØ±ÙÙŠ</div>
        <div id="predPctB">0%</div>
        <div class="muted small" id="predTrendB">â†’</div>
      </div>
      <div class="pred-card tie" id="predT">
        <div>ØªØ¹Ø§Ø¯Ù„</div>
        <div id="predPctT">0%</div>
        <div class="muted small" id="predTrendT">â†’</div>
      </div>
    </div>

    <div class="analysis-result">
      <div class="muted">Ø§Ù„ØªÙˆÙ‚Ø¹ Ø§Ù„Ø­Ø§Ù„ÙŠ:</div>
      <div class="final" id="finalCard">â€”</div>
      <div class="muted small" id="predictionReason">Ø¨Ø§Ù†ØªØ¸Ø§Ø± Ø¨ÙŠØ§Ù†Ø§Øª ÙƒØ§ÙÙŠØ© Ù„Ù„ØªØ­Ù„ÙŠÙ„</div>
      <div class="muted small" id="mlContribution" style="margin-top: 5px; color: #9d4edd;"></div>
    </div>
  </div>

  <!-- Ù…Ù†Ø­Ù†Ù‰ Ø§Ù„ØªÙˆÙ‚Ø¹Ø§Øª -->
  <div class="panel card accuracy-panel">
    <div class="section-title">Ù…Ù†Ø­Ù†Ù‰ Ø¯Ù‚Ø© Ø§Ù„ØªÙˆÙ‚Ø¹Ø§Øª Ø§Ù„Ù…ØªÙ‚Ø¯Ù…</div>
    <div class="accuracy-stats">
      <div>
        <div class="accuracy-label">Ø§Ù„Ø¯Ù‚Ø© Ø§Ù„Ø­Ø§Ù„ÙŠØ©</div>
        <div class="accuracy-value" id="currentAccuracy">0%</div>
      </div>
      <div>
        <div class="accuracy-label">Ø£ÙØ¶Ù„ Ø¯Ù‚Ø©</div>
        <div class="accuracy-value" id="bestAccuracy">0%</div>
      </div>
      <div>
        <div class="accuracy-label">Ù…ØªÙˆØ³Ø· Ø§Ù„Ø¯Ù‚Ø©</div>
        <div class="accuracy-value" id="averageAccuracy">0%</div>
      </div>
      <div>
        <div class="accuracy-label">Ø¯Ù‚Ø© ML</div>
        <div class="accuracy-value" id="mlOverallAccuracy">0%</div>
      </div>
    </div>
    <div class="accuracy-chart-container">
      <svg id="accuracyChart" width="100%" height="100%"></svg>
      <div id="accuracyTooltip" class="accuracy-tooltip"></div>
    </div>
    <div class="muted small">ØªØªØ¨Ø¹ Ø¯Ù‚Ø© ØªÙˆÙ‚Ø¹Ø§ØªÙƒ Ù…Ø¹ ØªØ­Ù„ÙŠÙ„ Ø£Ø¯Ø§Ø¡ Ø§Ù„Ù†Ù…Ø§Ø°Ø¬ Ø§Ù„Ù…Ø®ØªÙ„ÙØ©</div>
  </div>
</section>
</main>

<footer class="foot card">
  <div style="flex: 1;">
    <div>ØªØµÙ…ÙŠÙ…: Ayoub â€¢ Ø§Ù„Ù†Ø³Ø®Ø© Ø§Ù„ÙƒØ§Ù…Ù„Ø© Ù…Ø¹ Ø§Ù„Ù…Ø³Ø§Ø¹Ø¯ Ø§Ù„ØµÙˆØªÙŠ Ø§Ù„Ø°ÙƒÙŠ</div>
    <div class="credits small">Ù†Ø¸Ø§Ù… Ù…ØªØ¹Ø¯Ø¯ Ø§Ù„Ù†Ù…Ø§Ø°Ø¬ â€¢ ØªØ¹Ù„Ù… Ø¢Ù„Ø© â€¢ ØªØ­Ù„ÙŠÙ„ Ø§Ù„Ø£Ù†Ù…Ø§Ø· â€¢ Ù…Ø³Ø§Ø¹Ø¯ ØµÙˆØªÙŠ â€¢ Ù…Ø¤Ø´Ø±Ø§Øª Ù…ØªÙ‚Ø¯Ù…Ø©</div>
  </div>
  <div class="data-controls">
    <button id="btnExport" class="btn" style="background: rgba(59, 130, 246, 0.2); border: 1px solid #3a86ff;">ğŸ“¥ ØªØµØ¯ÙŠØ±</button>
    <button id="btnImport" class="btn" style="background: rgba(16, 185, 129, 0.2); border: 1px solid #10b981;">ğŸ“¤ Ø§Ø³ØªÙŠØ±Ø§Ø¯</button>
    <button id="btnClearData" class="btn" style="background: rgba(239, 68, 68, 0.2); border: 1px solid #ef4444;">ğŸ—‘ï¸ Ù…Ø³Ø­</button>
  </div>
  <div class="muted small" style="text-align: center; width: 100%; margin-top: 10px;">
    <span id="autoSaveStatus">ğŸ’¾ Ø§Ù„Ø­ÙØ¸ Ø§Ù„ØªÙ„Ù‚Ø§Ø¦ÙŠ Ù…ÙØ¹Ù„</span> â€¢ 
    <span id="dataStats">0 Ø¬ÙˆÙ„Ø© â€¢ 0 Ø¹ÙŠÙ†Ø© ØªØ¯Ø±ÙŠØ¨</span>
  </div>
</footer>
</div>

<!-- Ø§Ù„Ù…Ø³Ø§Ø¹Ø¯ Ø§Ù„ØµÙˆØªÙŠ -->
<div class="voice-assistant-container">
  <button id="voiceAssistantBtn" class="voice-assistant-btn" title="ÙØªØ­ Ø§Ù„Ù…Ø³Ø§Ø¹Ø¯ Ø§Ù„ØµÙˆØªÙŠ">
    ğŸ¤
  </button>
  
  <div id="voiceAssistantPanel" class="voice-assistant-panel">
    <div class="voice-header">
      <div class="voice-title">ğŸ¤ Ø§Ù„Ù…Ø³Ø§Ø¹Ø¯ Ø§Ù„ØµÙˆØªÙŠ Ø§Ù„Ø°ÙƒÙŠ</div>
      <button id="voiceCloseBtn" class="voice-close">Ã—</button>
    </div>
    
    <div class="voice-messages" id="voiceMessages">
      <div class="voice-message system">
        Ø£Ù‡Ù„Ø§Ù‹! Ø£Ù†Ø§ Ù…Ø³Ø§Ø¹Ø¯Ùƒ Ø§Ù„ØµÙˆØªÙŠ Ù„Ù„Ø¹Ø¨Ø© Baccarat Pro. ÙŠÙ…ÙƒÙ†Ùƒ Ø§Ù„ØªØ­Ø¯Ø« Ù…Ø¹ÙŠ Ù…Ø¨Ø§Ø´Ø±Ø© Ù„Ù„Ø­ØµÙˆÙ„ Ø¹Ù„Ù‰ Ø§Ù„Ù†ØµØ§Ø¦Ø­ ÙˆØ§Ù„ØªØ­Ù„ÙŠÙ„Ø§Øª.
      </div>
      <div class="voice-message system">
        Ù‚Ù„: "Ù…Ø§ Ù‡Ùˆ Ø§Ù„ØªÙ†Ø¨Ø¤ Ø§Ù„Ù‚Ø§Ø¯Ù…ØŸ" Ø£Ùˆ "Ù…Ø§ Ù‡ÙŠ Ù†ØµÙŠØ­ØªÙƒØŸ" Ø£Ùˆ "Ø­Ù„Ù„ Ù„ÙŠ Ø§Ù„Ù†ØªØ§Ø¦Ø¬ Ø§Ù„Ø³Ø§Ø¨Ù‚Ø©"
      </div>
    </div>
    
    <div class="voice-status">
      <div class="status-indicator" id="statusIndicator"></div>
      <div class="status-text" id="statusText">Ø¬Ø§Ù‡Ø² Ù„Ù„Ø§Ø³ØªÙ…Ø§Ø¹...</div>
    </div>
    
    <div class="voice-controls">
      <button id="startListeningBtn" class="voice-control-btn primary">
        <span id="micIcon">ğŸ¤</span> 
        <span id="listeningText">Ø§Ø¨Ø¯Ø£ Ø§Ù„ØªØ­Ø¯Ø«</span>
      </button>
      <button id="stopListeningBtn" class="voice-control-btn secondary">
        â¹ï¸ Ø¥ÙŠÙ‚Ø§Ù
      </button>
      <button id="clearChatBtn" class="voice-control-btn danger">
        ğŸ—‘ï¸ Ù…Ø³Ø­
      </button>
    </div>
    
    <div class="voice-quick-commands">
      <button class="voice-quick-btn" data-command="Ù…Ø§ Ù‡Ùˆ Ø§Ù„ØªÙ†Ø¨Ø¤ Ø§Ù„Ù‚Ø§Ø¯Ù…ØŸ">Ù…Ø§ Ù‡Ùˆ Ø§Ù„ØªÙ†Ø¨Ø¤ Ø§Ù„Ù‚Ø§Ø¯Ù…ØŸ</button>
      <button class="voice-quick-btn" data-command="Ù…Ø§ Ù‡ÙŠ Ù†ØµÙŠØ­ØªÙƒ Ù„Ù„Ø¬ÙˆÙ„Ø© Ø§Ù„Ù‚Ø§Ø¯Ù…Ø©ØŸ">Ù†ØµÙŠØ­Ø© Ù„Ù„Ø¬ÙˆÙ„Ø© Ø§Ù„Ù‚Ø§Ø¯Ù…Ø©</button>
      <button class="voice-quick-btn" data-command="Ø­Ù„Ù„ Ù„ÙŠ Ø§Ù„Ù†ØªØ§Ø¦Ø¬ Ø§Ù„Ø³Ø§Ø¨Ù‚Ø©">ØªØ­Ù„ÙŠÙ„ Ø§Ù„Ù†ØªØ§Ø¦Ø¬</button>
      <button class="voice-quick-btn" data-command="Ù…Ø§ Ù‡ÙŠ Ø§Ù„Ø¥Ø­ØµØ§Ø¡Ø§Øª Ø§Ù„Ø­Ø§Ù„ÙŠØ©ØŸ">Ø§Ù„Ø¥Ø­ØµØ§Ø¡Ø§Øª Ø§Ù„Ø­Ø§Ù„ÙŠØ©</button>
      <button class="voice-quick-btn" data-command="Ù…Ø§ Ù‡Ùˆ Ø£ÙØ¶Ù„ Ø®ÙŠØ§Ø± Ù„Ù„Ø±Ù‡Ø§Ù† Ø§Ù„Ø¢Ù†ØŸ">Ø£ÙØ¶Ù„ Ø®ÙŠØ§Ø± Ù„Ù„Ø±Ù‡Ø§Ù†</button>
      <button class="voice-quick-btn" data-command="Ù…Ø§ Ù‡Ùˆ Ù†Ù…Ø· Ø§Ù„Ù„Ø¹Ø¨ Ø§Ù„Ø­Ø§Ù„ÙŠØŸ">Ù†Ù…Ø· Ø§Ù„Ù„Ø¹Ø¨ Ø§Ù„Ø­Ø§Ù„ÙŠ</button>
    </div>
    
    <div class="voice-settings">
      <div class="setting-group">
        <span class="setting-label">ØªÙØ¹ÙŠÙ„ Ø§Ù„Ø±Ø¯ Ø§Ù„ØµÙˆØªÙŠ:</span>
        <label class="switch">
          <input type="checkbox" id="voiceResponseToggle" checked>
          <span class="slider"></span>
        </label>
      </div>
      <div class="setting-group">
        <span class="setting-label">Ø³Ø±Ø¹Ø© Ø§Ù„Ø±Ø¯:</span>
        <select id="voiceSpeedSelect" style="width: 100px; padding: 3px 5px; border-radius: 4px; background: rgba(255,255,255,0.1); color: white; border: 1px solid rgba(255,255,255,0.2);">
          <option value="0.8">Ø¨Ø·ÙŠØ¦Ø©</option>
          <option value="1" selected>Ø¹Ø§Ø¯ÙŠØ©</option>
          <option value="1.2">Ø³Ø±ÙŠØ¹Ø©</option>
        </select>
      </div>
    </div>
  </div>
</div>

<script>
// ========== Ø®ÙˆØ§Ø±Ø²Ù…ÙŠØ§Øª ØªØ¹Ù„Ù… Ø§Ù„Ø¢Ù„Ø© ==========
class SimpleKNN {
  constructor(k = 3) {
    this.k = k;
    this.trainingData = [];
    this.predictions = { correct: 0, total: 0 };
  }

  train(features, labels) {
    if (!features || !labels || features.length === 0) return;
    
    features.forEach((f, i) => {
      if (f && labels[i]) {
        this.trainingData.push({
          features: f,
          label: labels[i]
        });
      }
    });
    
    if (this.trainingData.length > 100) {
      this.trainingData = this.trainingData.slice(-100);
    }
  }

  predict(newFeatures) {
    if (!newFeatures || this.trainingData.length === 0) {
      return { P: 33.3, B: 33.3, T: 33.3 };
    }

    try {
      const distances = this.trainingData.map((dataPoint, index) => ({
        index,
        distance: this.euclideanDistance(newFeatures, dataPoint.features),
        label: dataPoint.label
      }));

      distances.sort((a, b) => a.distance - b.distance);
      const nearestNeighbors = distances.slice(0, this.k);
      
      const votes = { P: 0, B: 0, T: 0 };
      nearestNeighbors.forEach(n => {
        if (n.label in votes) {
          votes[n.label] += 1 / (n.distance + 1);
        }
      });

      const total = votes.P + votes.B + votes.T;
      if (total === 0) return { P: 33.3, B: 33.3, T: 33.3 };
      
      return {
        P: (votes.P / total) * 100,
        B: (votes.B / total) * 100,
        T: (votes.T / total) * 100
      };
    } catch (e) {
      console.error('KNN prediction error:', e);
      return { P: 33.3, B: 33.3, T: 33.3 };
    }
  }

  euclideanDistance(a, b) {
    if (!a || !b || a.length !== b.length) return 1000;
    
    let sum = 0;
    for (let i = 0; i < a.length; i++) {
      sum += Math.pow((a[i] || 0) - (b[i] || 0), 2);
    }
    return Math.sqrt(sum);
  }

  updateAccuracy(prediction, actual) {
    this.predictions.total++;
    if (prediction === actual) this.predictions.correct++;
  }

  getAccuracy() {
    return this.predictions.total > 0 ? 
      (this.predictions.correct / this.predictions.total) * 100 : 0;
  }
}

class SimpleLogisticRegression {
  constructor() {
    this.weights = { P: 0.1, B: 0.1, T: 0.1 };
    this.bias = 0;
    this.learningRate = 0.05;
    this.predictions = { correct: 0, total: 0 };
  }

  sigmoid(x) {
    return 1 / (1 + Math.exp(-x));
  }

  trainOne(features, label) {
    if (!features || !label || features.length === 0) return;
    
    try {
      const labelNum = { P: 0, B: 1, T: 2 }[label];
      if (labelNum === undefined) return;
      
      const score = features[0] * this.weights.P + features[1] * this.weights.B + features[2] * this.weights.T + this.bias;
      const prediction = this.sigmoid(score);
      const error = (labelNum / 2) - prediction;
      
      this.weights.P += this.learningRate * error * features[0];
      this.weights.B += this.learningRate * error * features[1];
      this.weights.T += this.learningRate * error * features[2];
      this.bias += this.learningRate * error;
    } catch (e) {
      console.error('Logistic regression training error:', e);
    }
  }

  predict(features) {
    if (!features || features.length === 0) {
      return { P: 33.3, B: 33.3, T: 33.3 };
    }
    
    try {
      const pScore = this.sigmoid(features[0] * this.weights.P + this.bias);
      const bScore = this.sigmoid(features[1] * this.weights.B + this.bias);
      const tScore = this.sigmoid(features[2] * this.weights.T + this.bias);
      
      const total = pScore + bScore + tScore;
      if (total === 0) return { P: 33.3, B: 33.3, T: 33.3 };
      
      return {
        P: (pScore / total) * 100,
        B: (bScore / total) * 100,
        T: (tScore / total) * 100
      };
    } catch (e) {
      console.error('Logistic regression prediction error:', e);
      return { P: 33.3, B: 33.3, T: 33.3 };
    }
  }

  updateAccuracy(prediction, actual) {
    this.predictions.total++;
    if (prediction === actual) this.predictions.correct++;
  }

  getAccuracy() {
    return this.predictions.total > 0 ? 
      (this.predictions.correct / this.predictions.total) * 100 : 0;
  }
}

class EnsembleModel {
  constructor() {
    this.models = {
      knn: new SimpleKNN(5),
      logistic: new SimpleLogisticRegression()
    };
    this.weights = { knn: 0.5, logistic: 0.5 };
    this.predictions = { correct: 0, total: 0 };
  }

  train(features, label) {
    if (!features || !label) return;
    
    try {
      this.models.knn.train([features], [label]);
      this.models.logistic.trainOne(features, label);
      
      const knnAcc = this.models.knn.getAccuracy();
      const logisticAcc = this.models.logistic.getAccuracy();
      
      const totalAcc = knnAcc + logisticAcc;
      if (totalAcc > 0) {
        this.weights.knn = knnAcc / totalAcc;
        this.weights.logistic = logisticAcc / totalAcc;
      }
    } catch (e) {
      console.error('Ensemble training error:', e);
    }
  }

  predict(features) {
    if (!features) return { P: 33.3, B: 33.3, T: 33.3 };
    
    try {
      const knnPred = this.models.knn.predict(features);
      const logisticPred = this.models.logistic.predict(features);
      
      return {
        P: (knnPred.P * this.weights.knn + logisticPred.P * this.weights.logistic),
        B: (knnPred.B * this.weights.knn + logisticPred.B * this.weights.logistic),
        T: (knnPred.T * this.weights.knn + logisticPred.T * this.weights.logistic)
      };
    } catch (e) {
      console.error('Ensemble prediction error:', e);
      return { P: 33.3, B: 33.3, T: 33.3 };
    }
  }

  updateAccuracy(prediction, actual) {
    this.predictions.total++;
    if (prediction === actual) this.predictions.correct++;
    
    this.models.knn.updateAccuracy(prediction, actual);
    this.models.logistic.updateAccuracy(prediction, actual);
  }

  getAccuracy() {
    return this.predictions.total > 0 ? 
      (this.predictions.correct / this.predictions.total) * 100 : 0;
  }
}

class BaccaratMachineLearning {
  constructor() {
    this.models = {
      knn: new SimpleKNN(5),
      logistic: new SimpleLogisticRegression(),
      ensemble: new EnsembleModel()
    };
    this.activeModel = 'ensemble';
    this.featureHistory = [];
    this.mlPredictions = [];
    this.isEnabled = true;
    this.trainingData = [];
  }

  extractFeatures(rounds, windowSize) {
    if (!rounds || rounds.length < windowSize) return null;
    
    try {
      const recent = rounds.slice(-windowSize);
      const pRatio = recent.filter(r => r === 'P').length / windowSize;
      const bRatio = recent.filter(r => r === 'B').length / windowSize;
      const tRatio = recent.filter(r => r === 'T').length / windowSize;
      
      let pStreak = 0, bStreak = 0;
      for (let i = recent.length - 1; i >= 0; i--) {
        if (recent[i] === 'P') pStreak++; else break;
      }
      for (let i = recent.length - 1; i >= 0; i--) {
        if (recent[i] === 'B') bStreak++; else break;
      }
      
      const volatility = this.calculateVolatility(recent);
      const patternType = this.getPatternType(recent);
      
      return [
        pRatio, bRatio, tRatio,
        pStreak / windowSize,
        bStreak / windowSize,
        recent[recent.length - 1] === recent[recent.length - 2] ? 1 : 0,
        volatility,
        patternType
      ];
    } catch (e) {
      console.error('Feature extraction error:', e);
      return null;
    }
  }

  calculateVolatility(rounds) {
    if (rounds.length < 2) return 0;
    let changes = 0;
    for (let i = 1; i < rounds.length; i++) {
      if (rounds[i] !== rounds[i-1]) changes++;
    }
    return changes / (rounds.length - 1);
  }

  getPatternType(rounds) {
    if (rounds.length < 3) return 0;
    const lastThree = rounds.slice(-3);
    if (lastThree[0] === lastThree[1] && lastThree[1] === lastThree[2]) return 1;
    if (lastThree[0] !== lastThree[1] && lastThree[1] !== lastThree[2]) return 2;
    return 0;
  }

  updateModel(rounds, windowSize, actualResult) {
    if (!this.isEnabled || !rounds || !actualResult) return;
    
    const features = this.extractFeatures(rounds, windowSize);
    if (!features) return;
    
    try {
      this.featureHistory.push({ features, label: actualResult, timestamp: Date.now() });
      
      if (this.featureHistory.length > 100) {
        this.featureHistory = this.featureHistory.slice(-100);
      }
      
      if (this.featureHistory.length > 5) {
        const trainingBatch = this.featureHistory.slice(-10);
        
        trainingBatch.forEach(({ features, label }) => {
          if (features && label) {
            this.models.knn.train([features], [label]);
            this.models.logistic.trainOne(features, label);
            this.models.ensemble.train(features, label);
          }
        });
      }
    } catch (e) {
      console.error('ML update error:', e);
    }
  }

  predict(rounds, windowSize) {
    if (!this.isEnabled || !rounds || rounds.length < windowSize) {
      return null;
    }
    
    const features = this.extractFeatures(rounds, windowSize);
    if (!features) return null;
    
    try {
      let prediction;
      switch(this.activeModel) {
        case 'knn':
          prediction = this.models.knn.predict(features);
          break;
        case 'logistic':
          prediction = this.models.logistic.predict(features);
          break;
        case 'ensemble':
        default:
          prediction = this.models.ensemble.predict(features);
          break;
      }
      
      if (prediction) {
        this.mlPredictions.push({
          features,
          prediction: this.getPredictedClass(prediction),
          timestamp: Date.now()
        });
        
        if (this.mlPredictions.length > 50) {
          this.mlPredictions = this.mlPredictions.slice(-50);
        }
      }
      
      return prediction;
    } catch (e) {
      console.error('ML prediction error:', e);
      return null;
    }
  }

  getPredictedClass(prediction) {
    if (!prediction) return null;
    const entries = Object.entries(prediction);
    if (entries.length === 0) return null;
    
    entries.sort((a, b) => b[1] - a[1]);
    return entries[0][0];
  }

  getModelAccuracy(modelName) {
    const model = this.models[modelName];
    return model && model.getAccuracy ? model.getAccuracy() : 0;
  }

  getTrainingDataCount() {
    return this.featureHistory.length;
  }

  getMLWeight() {
    const minWeight = 0.1;
    const maxWeight = 0.6;
    const dataPoints = this.getTrainingDataCount();
    const weight = minWeight + (maxWeight - minWeight) * (dataPoints / 100);
    return Math.min(weight, maxWeight);
  }

  enable() {
    this.isEnabled = true;
  }

  disable() {
    this.isEnabled = false;
  }

  setActiveModel(modelName) {
    if (this.models[modelName]) {
      this.activeModel = modelName;
    }
  }

  reset() {
    this.models = {
      knn: new SimpleKNN(5),
      logistic: new SimpleLogisticRegression(),
      ensemble: new EnsembleModel()
    };
    this.featureHistory = [];
    this.mlPredictions = [];
    this.trainingData = [];
  }

  getStats() {
    return {
      trainingCount: this.featureHistory.length,
      accuracy: this.getModelAccuracy(this.activeModel),
      weight: this.getMLWeight(),
      isEnabled: this.isEnabled,
      activeModel: this.activeModel
    };
  }
}

// ========== Ù†Ø¸Ø§Ù… Ø§Ù„Ø­ÙØ¸ ==========
class DataManager {
  constructor() {
    this.storageKey = 'baccaratPro_v4_voice';
    this.autoSaveInterval = null;
    this.lastSaveTime = null;
    this.isSaving = false;
  }

  saveAllData() {
    if (this.isSaving) return false;
    
    this.isSaving = true;
    try {
      const saveData = {
        state: {
          rounds: state.rounds,
          count: state.count,
          win: state.win,
          loss: state.loss,
          windowSize: state.windowSize
        },
        voiceSettings: {
          voiceEnabled: voiceAssistant.voiceEnabled,
          voiceSpeed: voiceAssistant.voiceSpeed,
          chatHistory: voiceAssistant.getChatHistory()
        },
        meta: {
          version: '4.0_voice',
          lastSave: new Date().toISOString(),
          totalRounds: state.rounds.length
        }
      };

      localStorage.setItem(this.storageKey, JSON.stringify(saveData));
      this.lastSaveTime = new Date();
      this.updateSaveStatus(true);
      return true;
    } catch (e) {
      console.error('Error saving data:', e);
      this.updateSaveStatus(false, 'Ø®Ø·Ø£ ÙÙŠ Ø§Ù„Ø­ÙØ¸');
      return false;
    } finally {
      this.isSaving = false;
    }
  }

  loadAllData() {
    try {
      const saved = localStorage.getItem(this.storageKey);
      if (!saved) {
        this.updateSaveStatus(true, 'Ø¨Ø¯ÙˆÙ† Ø¨ÙŠØ§Ù†Ø§Øª Ø³Ø§Ø¨Ù‚Ø©');
        return false;
      }

      const data = JSON.parse(saved);
      
      if (data.state) {
        state.rounds = Array.isArray(data.state.rounds) ? data.state.rounds : [];
        state.count = data.state.count || { P: 0, B: 0, T: 0 };
        state.win = data.state.win || { P: 0, B: 0, T: 0 };
        state.loss = data.state.loss || { P: 0, B: 0, T: 0 };
        state.windowSize = data.state.windowSize || 8;
      }

      if (data.voiceSettings) {
        voiceAssistant.voiceEnabled = data.voiceSettings.voiceEnabled !== false;
        voiceAssistant.voiceSpeed = data.voiceSettings.voiceSpeed || 1;
        if (data.voiceSettings.chatHistory) {
          voiceAssistant.loadChatHistory(data.voiceSettings.chatHistory);
        }
      }

      this.lastSaveTime = new Date();
      this.updateSaveStatus(true, 'ØªÙ… ØªØ­Ù…ÙŠÙ„ Ø§Ù„Ø¨ÙŠØ§Ù†Ø§Øª');
      return true;
    } catch (e) {
      console.error('Error loading data:', e);
      this.updateSaveStatus(false, 'Ø®Ø·Ø£ ÙÙŠ Ø§Ù„ØªØ­Ù…ÙŠÙ„');
      return false;
    }
  }

  exportData() {
    try {
      const exportData = {
        state: {
          rounds: state.rounds,
          count: state.count,
          win: state.win,
          loss: state.loss,
          windowSize: state.windowSize
        },
        meta: {
          exportDate: new Date().toISOString(),
          version: 'AYOUB_BACCARAT_PRO_v4.0_VOICE',
          totalRounds: state.rounds.length
        }
      };

      const dataStr = JSON.stringify(exportData, null, 2);
      const dataBlob = new Blob([dataStr], { type: 'application/json' });
      const url = URL.createObjectURL(dataBlob);
      
      const a = document.createElement('a');
      a.href = url;
      a.download = `baccarat_data_${new Date().toISOString().split('T')[0]}.json`;
      document.body.appendChild(a);
      a.click();
      
      setTimeout(() => {
        document.body.removeChild(a);
        URL.revokeObjectURL(url);
      }, 100);
      
      alert(`âœ… ØªÙ… ØªØµØ¯ÙŠØ± ${state.rounds.length} Ø¬ÙˆÙ„Ø©`);
    } catch (e) {
      alert('âŒ Ø®Ø·Ø£ ÙÙŠ ØªØµØ¯ÙŠØ± Ø§Ù„Ø¨ÙŠØ§Ù†Ø§Øª: ' + e.message);
    }
  }

  importData(file) {
    const reader = new FileReader();
    
    reader.onload = (e) => {
      try {
        const importedData = JSON.parse(e.target.result);
        
        if (!confirm(`Ù‡Ù„ ØªØ±ÙŠØ¯ Ø§Ø³ØªÙŠØ±Ø§Ø¯ ${importedData.state?.rounds?.length || 0} Ø¬ÙˆÙ„Ø©ØŸ\nØ³ÙŠØªÙ… Ù…Ø³Ø­ Ø§Ù„Ø¨ÙŠØ§Ù†Ø§Øª Ø§Ù„Ø­Ø§Ù„ÙŠØ©.`)) {
          return;
        }

        resetAll();
        
        if (importedData.state) {
          state.rounds = Array.isArray(importedData.state.rounds) ? importedData.state.rounds : [];
          state.count = importedData.state.count || { P: 0, B: 0, T: 0 };
          state.win = importedData.state.win || { P: 0, B: 0, T: 0 };
          state.loss = importedData.state.loss || { P: 0, B: 0, T: 0 };
          state.windowSize = importedData.state.windowSize || 8;
          
          state.rounds.forEach(round => {
            state.count[round]++;
          });
        }

        updateAll();
        this.saveAllData();
        
        alert(`âœ… ØªÙ… Ø§Ø³ØªÙŠØ±Ø§Ø¯ ${state.rounds.length} Ø¬ÙˆÙ„Ø© Ø¨Ù†Ø¬Ø§Ø­!`);
      } catch (error) {
        alert('âŒ Ø®Ø·Ø£ ÙÙŠ ØªÙ†Ø³ÙŠÙ‚ Ø§Ù„Ù…Ù„Ù: ' + error.message);
      }
    };
    
    reader.onerror = () => {
      alert('âŒ Ø®Ø·Ø£ ÙÙŠ Ù‚Ø±Ø§Ø¡Ø© Ø§Ù„Ù…Ù„Ù');
    };
    
    reader.readAsText(file);
  }

  clearAllData() {
    if (confirm('âš ï¸ Ù‡Ù„ Ø£Ù†Øª Ù…ØªØ£ÙƒØ¯ Ù…Ù† Ù…Ø³Ø­ Ø¬Ù…ÙŠØ¹ Ø§Ù„Ø¨ÙŠØ§Ù†Ø§ØªØŸ\nÙ„Ø§ ÙŠÙ…ÙƒÙ† Ø§Ù„ØªØ±Ø§Ø¬Ø¹ Ø¹Ù† Ù‡Ø°Ø§ Ø§Ù„Ø¥Ø¬Ø±Ø§Ø¡.')) {
      localStorage.removeItem(this.storageKey);
      resetAll();
      alert('âœ… ØªÙ… Ù…Ø³Ø­ Ø¬Ù…ÙŠØ¹ Ø§Ù„Ø¨ÙŠØ§Ù†Ø§Øª.');
    }
  }

  startAutoSave(intervalSeconds = 30) {
    if (this.autoSaveInterval) {
      clearInterval(this.autoSaveInterval);
    }
    
    this.autoSaveInterval = setInterval(() => {
      if (state.rounds.length > 0 && !this.isSaving) {
        this.saveAllData();
      }
    }, intervalSeconds * 1000);
    
    window.addEventListener('beforeunload', () => {
      if (!this.isSaving) {
        this.saveAllData();
      }
    });
  }

  updateSaveStatus(success, message = '') {
    const statusEl = document.getElementById('autoSaveStatus');
    if (statusEl) {
      if (success) {
        const timeStr = this.lastSaveTime ? 
          `ğŸ’¾ Ø¢Ø®Ø± Ø­ÙØ¸: ${this.lastSaveTime.toLocaleTimeString('ar-EG', {hour: '2-digit', minute:'2-digit'})}` : 
          'ğŸ’¾ Ø§Ù„Ø­ÙØ¸ Ø§Ù„ØªÙ„Ù‚Ø§Ø¦ÙŠ Ù…ÙØ¹Ù„';
        statusEl.textContent = message || timeStr;
        statusEl.style.color = '#38b000';
      } else {
        statusEl.textContent = message || 'âŒ Ø®Ø·Ø£ ÙÙŠ Ø§Ù„Ø­ÙØ¸';
        statusEl.style.color = '#ff006e';
      }
    }
  }

  updateDataStats() {
    const statsEl = document.getElementById('dataStats');
    if (statsEl) {
      statsEl.textContent = `${state.rounds.length} Ø¬ÙˆÙ„Ø© â€¢ ${state.ml.featureHistory.length} Ø¹ÙŠÙ†Ø© ØªØ¯Ø±ÙŠØ¨`;
    }
  }
}

// ========== Ø§Ù„Ù…Ø³Ø§Ø¹Ø¯ Ø§Ù„ØµÙˆØªÙŠ Ø§Ù„Ø°ÙƒÙŠ ==========
class VoiceAssistant {
  constructor() {
    this.recognition = null;
    this.isListening = false;
    this.voiceEnabled = true;
    this.voiceSpeed = 1;
    this.chatHistory = [];
    this.synth = window.speechSynthesis;
    this.isSpeaking = false;
    this.setupSpeechRecognition();
    this.loadSettings();
  }

  setupSpeechRecognition() {
    if ('webkitSpeechRecognition' in window) {
      this.recognition = new webkitSpeechRecognition();
    } else if ('SpeechRecognition' in window) {
      this.recognition = new SpeechRecognition();
    } else {
      console.error('API Ø§Ù„ØªØ¹Ø±Ù Ø¹Ù„Ù‰ Ø§Ù„ØµÙˆØª ØºÙŠØ± Ù…Ø¯Ø¹ÙˆÙ… ÙÙŠ Ù‡Ø°Ø§ Ø§Ù„Ù…ØªØµÙØ­');
      return;
    }

    this.recognition.continuous = false;
    this.recognition.interimResults = false;
    this.recognition.lang = 'ar-SA'; // Ø§Ù„Ø¹Ø±Ø¨ÙŠØ© Ø§Ù„Ø³Ø¹ÙˆØ¯ÙŠØ©

    this.recognition.onstart = () => {
      this.isListening = true;
      this.updateUIStatus('ÙŠØ³ØªÙ…Ø¹ Ø§Ù„Ø¢Ù†...', 'listening');
    };

    this.recognition.onresult = (event) => {
      const transcript = event.results[0][0].transcript;
      this.processVoiceCommand(transcript);
    };

    this.recognition.onerror = (event) => {
      console.error('Ø®Ø·Ø£ ÙÙŠ Ø§Ù„ØªØ¹Ø±Ù Ø¹Ù„Ù‰ Ø§Ù„ØµÙˆØª:', event.error);
      this.isListening = false;
      this.updateUIStatus('Ø®Ø·Ø£ ÙÙŠ Ø§Ù„Ø§Ø³ØªÙ…Ø§Ø¹', 'error');
    };

    this.recognition.onend = () => {
      this.isListening = false;
      this.updateUIStatus('Ø¬Ø§Ù‡Ø² Ù„Ù„Ø§Ø³ØªÙ…Ø§Ø¹...', 'ready');
    };
  }

  startListening() {
    if (!this.recognition) {
      this.showMessage('Ø§Ù„Ù…Ø³Ø§Ø¹Ø¯ Ø§Ù„ØµÙˆØªÙŠ ØºÙŠØ± Ù…Ø¯Ø¹ÙˆÙ… ÙÙŠ Ù…ØªØµÙØ­Ùƒ. Ø§Ø³ØªØ®Ø¯Ù… Ø§Ù„Ù…ØªØµÙØ­Ø§Øª Ø§Ù„Ø­Ø¯ÙŠØ«Ø©.', 'system');
      return;
    }

    try {
      this.recognition.start();
    } catch (error) {
      console.error('Ø®Ø·Ø£ ÙÙŠ Ø¨Ø¯Ø¡ Ø§Ù„Ø§Ø³ØªÙ…Ø§Ø¹:', error);
    }
  }

  stopListening() {
    if (this.recognition && this.isListening) {
      this.recognition.stop();
    }
  }

  processVoiceCommand(transcript) {
    this.showMessage(transcript, 'user');
    
    const command = transcript.toLowerCase();
    let response = '';

    if (command.includes('Ù…Ø§ Ù‡Ùˆ Ø§Ù„ØªÙ†Ø¨Ø¤') || command.includes('Ø§Ù„ØªÙ†Ø¨Ø¤ Ø§Ù„Ù‚Ø§Ø¯Ù…') || command.includes('ØªÙˆÙ‚Ø¹')) {
      response = this.getPredictionAnalysis();
    } 
    else if (command.includes('Ù†ØµÙŠØ­Ø©') || command.includes('Ù†ØµÙŠØ­ØªÙƒ') || command.includes('Ù…Ø§Ø°Ø§ Ø£ÙØ¹Ù„')) {
      response = this.getAdvice();
    }
    else if (command.includes('ØªØ­Ù„ÙŠÙ„') || command.includes('Ø§Ù„Ù†ØªØ§Ø¦Ø¬ Ø§Ù„Ø³Ø§Ø¨Ù‚Ø©')) {
      response = this.getResultsAnalysis();
    }
    else if (command.includes('Ø¥Ø­ØµØ§Ø¡Ø§Øª') || command.includes('Ø£Ø±Ù‚Ø§Ù…') || command.includes('Ø¥Ø­ØµØ§Ø¦ÙŠØ§Øª')) {
      response = this.getStatistics();
    }
    else if (command.includes('Ø£ÙØ¶Ù„ Ø®ÙŠØ§Ø±') || command.includes('Ø§Ù„Ø±Ù‡Ø§Ù†') || command.includes('Ø£ÙŠÙ† Ø£Ø±Ø§Ù‡Ù†')) {
      response = this.getBettingAdvice();
    }
    else if (command.includes('Ù†Ù…Ø·') || command.includes('Ø§ØªØ¬Ø§Ù‡') || command.includes('ØªØ³Ù„Ø³Ù„')) {
      response = this.getPatternAnalysis();
    }
    else if (command.includes('Ù…Ø³Ø§Ø¹Ø¯Ø©') || command.includes('Ù…Ø§Ø°Ø§ ÙŠÙ…ÙƒÙ†Ù†ÙŠ Ø£Ù† Ø£Ù‚ÙˆÙ„')) {
      response = this.getHelp();
    }
    else if (command.includes('Ø´ÙƒØ±') || command.includes('Ù…Ù…ØªØ§Ø²') || command.includes('Ø¬ÙŠØ¯')) {
      response = 'Ø´ÙƒØ±Ø§Ù‹ Ù„Ùƒ! Ø£Ù†Ø§ Ù‡Ù†Ø§ Ù„Ù…Ø³Ø§Ø¹Ø¯ØªÙƒ Ø¯Ø§Ø¦Ù…Ø§Ù‹. Ù‡Ù„ Ù„Ø¯ÙŠÙƒ Ø£ÙŠ Ø§Ø³ØªÙØ³Ø§Ø± Ø¢Ø®Ø±ØŸ';
    }
    else {
      response = 'Ù„Ù… Ø£ÙÙ‡Ù… Ø³Ø¤Ø§Ù„Ùƒ Ø¨Ø´ÙƒÙ„ ÙƒØ§Ù…Ù„. ÙŠÙ…ÙƒÙ†Ùƒ Ø³Ø¤Ø§Ù„ÙŠ Ø¹Ù†: Ø§Ù„ØªÙ†Ø¨Ø¤ Ø§Ù„Ù‚Ø§Ø¯Ù…ØŒ Ù†ØµÙŠØ­Ø© Ù„Ù„Ø¬ÙˆÙ„Ø©ØŒ ØªØ­Ù„ÙŠÙ„ Ø§Ù„Ù†ØªØ§Ø¦Ø¬ØŒ Ø£Ùˆ Ø§Ù„Ø¥Ø­ØµØ§Ø¡Ø§Øª Ø§Ù„Ø­Ø§Ù„ÙŠØ©.';
    }

    this.showMessage(response, 'assistant');
    
    if (this.voiceEnabled) {
      this.speak(response);
    }
  }

  getPredictionAnalysis() {
    const pred = enhancedPredict();
    let response = '';
    
    if (pred.final === 'â€”') {
      response = 'Ø§Ù„ØªÙ†Ø¨Ø¤ Ø§Ù„Ø­Ø§Ù„ÙŠ ØºÙŠØ± Ù…Ø¤ÙƒØ¯ Ø¨Ù…Ø§ ÙÙŠÙ‡ Ø§Ù„ÙƒÙØ§ÙŠØ©. Ø§Ù„Ø«Ù‚Ø© Ø­Ø§Ù„ÙŠØ§Ù‹ ' + pred.confidence.toFixed(1) + '% ÙÙ‚Ø·ØŒ ÙˆÙ‡ÙŠ Ø£Ù‚Ù„ Ù…Ù† Ø§Ù„Ø­Ø¯ Ø§Ù„Ù…Ø·Ù„ÙˆØ¨.';
    } else {
      const finalText = pred.final === 'P' ? 'Ù„Ø§Ø¹Ø¨' : pred.final === 'B' ? 'Ù…ØµØ±ÙÙŠ' : 'ØªØ¹Ø§Ø¯Ù„';
      response = `Ø§Ù„ØªÙ†Ø¨Ø¤ Ø§Ù„Ù‚Ø§Ø¯Ù… ÙŠØ´ÙŠØ± Ø¥Ù„Ù‰ ${finalText} Ø¨Ø«Ù‚Ø© ${pred.confidence.toFixed(1)}%. Ø§Ù„Ù†Ø³Ø¨ Ø§Ù„Ø­Ø§Ù„ÙŠØ©: ğŸ”µÙ„Ø§Ø¹Ø¨ ${pred.P}% ğŸ”´Ù…ØµØ±ÙÙŠ ${pred.B}% ğŸŸ¢ØªØ¹Ø§Ø¯Ù„ ${pred.T}%`;
      
      if (pred.confidence >= 70) {
        response += ' Ù‡Ø°Ù‡ Ø«Ù‚Ø© Ø¹Ø§Ù„ÙŠØ© Ø¬Ø¯Ø§Ù‹ØŒ ÙŠÙ…ÙƒÙ†Ùƒ Ø§Ù„Ø§Ø¹ØªÙ…Ø§Ø¯ Ø¹Ù„Ù‰ Ù‡Ø°Ø§ Ø§Ù„ØªÙ†Ø¨Ø¤.';
      } else if (pred.confidence >= 50) {
        response += ' Ø§Ù„Ø«Ù‚Ø© Ù…ØªÙˆØ³Ø·Ø©ØŒ Ù‚Ø¯ ØªØ­ØªØ§Ø¬ Ø¥Ù„Ù‰ Ø§Ù„Ø­Ø°Ø±.';
      } else {
        response += ' Ø§Ù„Ø«Ù‚Ø© Ù…Ù†Ø®ÙØ¶Ø©ØŒ Ø£Ù†ØµØ­ Ø¨Ø§Ù„Ø§Ù†ØªØ¸Ø§Ø± Ù„Ø¬ÙˆÙ„Ø© Ø£Ø®Ø±Ù‰.';
      }
    }
    
    return response;
  }

  getAdvice() {
    const pred = enhancedPredict();
    const recent = state.rounds.slice(-Math.min(5, state.rounds.length));
    
    if (state.rounds.length < 3) {
      return 'Ø£Ù†ØªØ¸Ø± Ø§Ù„Ù…Ø²ÙŠØ¯ Ù…Ù† Ø§Ù„Ø¬ÙˆÙ„Ø§Øª Ù„Ø£Ø¹Ø·ÙŠÙƒ Ù†ØµÙŠØ­Ø© Ø¯Ù‚ÙŠÙ‚Ø©. Ø£Ø¯Ø®Ù„ 3 Ø¬ÙˆÙ„Ø§Øª Ø¹Ù„Ù‰ Ø§Ù„Ø£Ù‚Ù„.';
    }

    const pCount = recent.filter(r => r === 'P').length;
    const bCount = recent.filter(r => r === 'B').length;
    const tCount = recent.filter(r => r === 'T').length;

    let advice = 'Ø¨Ù†Ø§Ø¡Ù‹ Ø¹Ù„Ù‰ Ø¢Ø®Ø± ' + recent.length + ' Ø¬ÙˆÙ„Ø©:\n';
    
    if (pred.final !== 'â€”') {
      const finalText = pred.final === 'P' ? 'Ù„Ø§Ø¹Ø¨' : pred.final === 'B' ? 'Ù…ØµØ±ÙÙŠ' : 'ØªØ¹Ø§Ø¯Ù„';
      advice += `- Ø§Ù„ØªÙ†Ø¨Ø¤ ÙŠØ´ÙŠØ± Ø¥Ù„Ù‰ ${finalText} (${pred.confidence.toFixed(1)}% Ø«Ù‚Ø©)\n`;
    }
    
    if (pCount > bCount && pCount > tCount) {
      advice += '- Ù‡Ù†Ø§Ùƒ ØªÙˆØ¬Ù‘Ù‡ Ù†Ø­Ùˆ Ø§Ù„Ù„Ø§Ø¹Ø¨ ÙÙŠ Ø§Ù„Ø¬ÙˆÙ„Ø§Øª Ø§Ù„Ø£Ø®ÙŠØ±Ø©\n';
    } else if (bCount > pCount && bCount > tCount) {
      advice += '- Ù‡Ù†Ø§Ùƒ ØªÙˆØ¬Ù‘Ù‡ Ù†Ø­Ùˆ Ø§Ù„Ù…ØµØ±ÙÙŠ ÙÙŠ Ø§Ù„Ø¬ÙˆÙ„Ø§Øª Ø§Ù„Ø£Ø®ÙŠØ±Ø©\n';
    }
    
    if (tCount > 0) {
      advice += '- Ø¸Ù‡Ø± Ø§Ù„ØªØ¹Ø§Ø¯Ù„ ' + tCount + ' Ù…Ø±Ø© Ù…Ø¤Ø®Ø±Ø§Ù‹ØŒ ÙƒÙ† Ø­Ø°Ø±Ø§Ù‹\n';
    }
    
    if (pred.confidence < 40) {
      advice += '\nÙ†ØµÙŠØ­ØªÙŠ: Ø§Ù†ØªØ¸Ø± Ø¬ÙˆÙ„Ø© Ø£Ø®Ø±Ù‰ Ù„Ø²ÙŠØ§Ø¯Ø© Ø§Ù„Ø«Ù‚Ø© Ù‚Ø¨Ù„ Ø§Ù„Ø±Ù‡Ø§Ù† Ø§Ù„ÙƒØ¨ÙŠØ±.';
    } else if (pred.confidence >= 60) {
      advice += '\nÙ†ØµÙŠØ­ØªÙŠ: ÙŠÙ…ÙƒÙ†Ùƒ Ø§Ù„Ø±Ù‡Ø§Ù† Ø¨Ø­Ø°Ø± Ù…ØªÙˆØ³Ø· Ø¹Ù„Ù‰ Ø§Ù„ØªÙ†Ø¨Ø¤ Ø§Ù„Ø­Ø§Ù„ÙŠ.';
    } else {
      advice += '\nÙ†ØµÙŠØ­ØªÙŠ: Ø±Ù‡Ø§Ù† ØµØºÙŠØ± Ø£Ùˆ Ù…Ø±Ø§Ù‚Ø¨Ø© ÙÙ‚Ø· Ù„Ù„Ø¬ÙˆÙ„Ø© Ø§Ù„Ù‚Ø§Ø¯Ù…Ø©.';
    }
    
    return advice;
  }

  getResultsAnalysis() {
    if (state.rounds.length === 0) {
      return 'Ù„Ø§ ØªÙˆØ¬Ø¯ Ù†ØªØ§Ø¦Ø¬ Ø³Ø§Ø¨Ù‚Ø© Ù„Ù„ØªØ­Ù„ÙŠÙ„. Ø§Ø¨Ø¯Ø£ Ø¨Ø¥Ø¯Ø®Ø§Ù„ Ø¨Ø¹Ø¶ Ø§Ù„Ø¬ÙˆÙ„Ø§Øª.';
    }

    const total = state.rounds.length;
    const pPercent = ((state.count.P / total) * 100).toFixed(1);
    const bPercent = ((state.count.B / total) * 100).toFixed(1);
    const tPercent = ((state.count.T / total) * 100).toFixed(1);

    let analysis = `ØªØ­Ù„ÙŠÙ„ ${total} Ø¬ÙˆÙ„Ø© Ø³Ø§Ø¨Ù‚Ø©:\n`;
    analysis += `ğŸ”µ Ù„Ø§Ø¹Ø¨: ${state.count.P} Ø¬ÙˆÙ„Ø© (${pPercent}%)\n`;
    analysis += `ğŸ”´ Ù…ØµØ±ÙÙŠ: ${state.count.B} Ø¬ÙˆÙ„Ø© (${bPercent}%)\n`;
    analysis += `ğŸŸ¢ ØªØ¹Ø§Ø¯Ù„: ${state.count.T} Ø¬ÙˆÙ„Ø© (${tPercent}%)\n\n`;

    const lastTen = state.rounds.slice(-Math.min(10, total));
    if (lastTen.length >= 3) {
      const pStreak = this.calculateStreak(lastTen, 'P');
      const bStreak = this.calculateStreak(lastTen, 'B');
      
      if (pStreak >= 3) {
        analysis += `âš ï¸ Ù‡Ù†Ø§Ùƒ ØªØ³Ù„Ø³Ù„ Ù„Ù€ ${pStreak} Ø¬ÙˆÙ„Ø§Øª Ù„Ù„Ø§Ø¹Ø¨!`;
      } else if (bStreak >= 3) {
        analysis += `âš ï¸ Ù‡Ù†Ø§Ùƒ ØªØ³Ù„Ø³Ù„ Ù„Ù€ ${bStreak} Ø¬ÙˆÙ„Ø§Øª Ù„Ù„Ù…ØµØ±ÙÙŠ!`;
      } else {
        analysis += 'Ù„Ø§ ØªÙˆØ¬Ø¯ ØªØ³Ù„Ø³Ù„Ø§Øª Ø·ÙˆÙŠÙ„Ø© Ù…Ø¤Ø®Ø±Ø§Ù‹ØŒ Ø§Ù„Ù„Ø¹Ø¨ Ù…ØªÙˆØ§Ø²Ù†.';
      }
    }

    return analysis;
  }

  getStatistics() {
    const pred = enhancedPredict();
    
    let stats = `Ø¥Ø­ØµØ§Ø¡Ø§Øª Ø§Ù„Ù„Ø¹Ø¨Ø©:\n`;
    stats += `- Ø¥Ø¬Ù…Ø§Ù„ÙŠ Ø§Ù„Ø¬ÙˆÙ„Ø§Øª: ${state.rounds.length}\n`;
    stats += `- Ø§Ù„Ù„Ø§Ø¹Ø¨: ${state.count.P} ÙÙˆØ² (${((state.count.P / state.rounds.length) * 100).toFixed(1)}%)\n`;
    stats += `- Ø§Ù„Ù…ØµØ±ÙÙŠ: ${state.count.B} ÙÙˆØ² (${((state.count.B / state.rounds.length) * 100).toFixed(1)}%)\n`;
    stats += `- Ø§Ù„ØªØ¹Ø§Ø¯Ù„: ${state.count.T} ÙÙˆØ² (${((state.count.T / state.rounds.length) * 100).toFixed(1)}%)\n`;
    
    if (state.win.P + state.win.B + state.win.T > 0) {
      const totalPredictions = state.win.P + state.win.B + state.win.T + state.loss.P + state.loss.B + state.loss.T;
      const accuracy = totalPredictions > 0 ? 
        ((state.win.P + state.win.B + state.win.T) / totalPredictions * 100).toFixed(1) : '0';
      stats += `- Ø¯Ù‚Ø© Ø§Ù„ØªÙ†Ø¨Ø¤Ø§Øª: ${accuracy}%\n`;
    }
    
    stats += `- Ø§Ù„Ø«Ù‚Ø© Ø§Ù„Ø­Ø§Ù„ÙŠØ©: ${pred.confidence.toFixed(1)}%\n`;
    stats += `- Ø§Ù„Ù†Ù…ÙˆØ°Ø¬ Ø§Ù„Ù…Ø³ØªØ®Ø¯Ù…: ${getModeName(state.analysisMode)}`;
    
    return stats;
  }

  getBettingAdvice() {
    const pred = enhancedPredict();
    const recent = state.rounds.slice(-Math.min(8, state.rounds.length));
    
    if (recent.length < 3) {
      return 'Ø£Ù†ØªØ¸Ø± Ø§Ù„Ù…Ø²ÙŠØ¯ Ù…Ù† Ø§Ù„Ø¬ÙˆÙ„Ø§Øª Ù„Ø£Ø¹Ø·ÙŠÙƒ Ù†ØµÙŠØ­Ø© Ø±Ù‡Ø§Ù† Ø¯Ù‚ÙŠÙ‚Ø©.';
    }

    const pCount = recent.filter(r => r === 'P').length;
    const bCount = recent.filter(r => r === 'B').length;
    
    let advice = 'Ù†ØµÙŠØ­Ø© Ø§Ù„Ø±Ù‡Ø§Ù†:\n';
    
    if (pred.final === 'â€”') {
      advice += 'Ø§Ù„ØªÙ†Ø¨Ø¤ ØºÙŠØ± Ù…Ø¤ÙƒØ¯ Ø­Ø§Ù„ÙŠØ§Ù‹. Ø£ÙØ¶Ù„ Ø®ÙŠØ§Ø± Ù‡Ùˆ:\n';
      advice += '- Ù„Ø§ ØªØ±Ø§Ù‡Ù† ÙÙŠ Ù‡Ø°Ù‡ Ø§Ù„Ø¬ÙˆÙ„Ø©\n';
      advice += '- Ø£Ùˆ Ø±Ù‡Ø§Ù† Ø±Ù…Ø²ÙŠ ØµØºÙŠØ± Ø¬Ø¯Ø§Ù‹\n';
      advice += '- Ø±Ø§Ù‚Ø¨ Ø§ØªØ¬Ø§Ù‡ Ø§Ù„Ø¬ÙˆÙ„Ø© Ø§Ù„Ù‚Ø§Ø¯Ù…Ø©';
    } else {
      const finalText = pred.final === 'P' ? 'Ù„Ø§Ø¹Ø¨' : pred.final === 'B' ? 'Ù…ØµØ±ÙÙŠ' : 'ØªØ¹Ø§Ø¯Ù„';
      
      if (pred.confidence >= 70) {
        advice += `âœ… ${finalText} Ù‡Ùˆ Ø§Ù„Ø®ÙŠØ§Ø± Ø§Ù„Ø£ÙØ¶Ù„ Ø§Ù„Ø¢Ù† Ø¨Ø«Ù‚Ø© Ø¹Ø§Ù„ÙŠØ© (${pred.confidence.toFixed(1)}%)\n`;
        advice += 'ÙŠÙ…ÙƒÙ†Ùƒ Ø±Ù‡Ø§Ù† Ù…ØªÙˆØ³Ø· Ø¥Ù„Ù‰ ÙƒØ¨ÙŠØ±\n';
        advice += 'Ù†Ø³Ø¨Ø© Ø§Ù„Ù…Ø®Ø§Ø·Ø±Ø©: Ù…Ù†Ø®ÙØ¶Ø©';
      } else if (pred.confidence >= 50) {
        advice += `âš ï¸ ${finalText} Ù‡Ùˆ Ø§Ù„Ù…Ø±Ø´Ø­ Ù„ÙƒÙ† Ø§Ù„Ø«Ù‚Ø© Ù…ØªÙˆØ³Ø·Ø© (${pred.confidence.toFixed(1)}%)\n`;
        advice += 'Ø±Ù‡Ø§Ù† ØµØºÙŠØ± Ø¥Ù„Ù‰ Ù…ØªÙˆØ³Ø· ÙÙ‚Ø·\n';
        advice += 'Ù†Ø³Ø¨Ø© Ø§Ù„Ù…Ø®Ø§Ø·Ø±Ø©: Ù…ØªÙˆØ³Ø·Ø©';
      } else {
        advice += `âŒ ${finalText} Ù…Ø±Ø´Ø­ Ù„ÙƒÙ† Ø§Ù„Ø«Ù‚Ø© Ù…Ù†Ø®ÙØ¶Ø© (${pred.confidence.toFixed(1)}%)\n`;
        advice += 'Ù„Ø§ Ø£Ù†ØµØ­ Ø¨Ø§Ù„Ø±Ù‡Ø§Ù† Ø£Ùˆ Ø±Ù‡Ø§Ù† Ø±Ù…Ø²ÙŠ Ø¬Ø¯Ø§Ù‹\n';
        advice += 'Ù†Ø³Ø¨Ø© Ø§Ù„Ù…Ø®Ø§Ø·Ø±Ø©: Ø¹Ø§Ù„ÙŠØ©';
      }
      
      if (finalText === 'T') {
        advice += '\nâš ï¸ ØªØ­Ø°ÙŠØ±: Ø±Ù‡Ø§Ù† Ø§Ù„ØªØ¹Ø§Ø¯Ù„ Ø¹Ø§Ù„ÙŠ Ø§Ù„Ù…Ø®Ø§Ø·Ø±Ø© Ø¹Ø§Ø¯Ø©!';
      }
    }
    
    return advice;
  }

  getPatternAnalysis() {
    if (state.rounds.length < 5) {
      return 'Ù†Ø­ØªØ§Ø¬ 5 Ø¬ÙˆÙ„Ø§Øª Ø¹Ù„Ù‰ Ø§Ù„Ø£Ù‚Ù„ Ù„ØªØ­Ù„ÙŠÙ„ Ø§Ù„Ø£Ù†Ù…Ø§Ø·.';
    }

    const recent = state.rounds.slice(-Math.min(10, state.rounds.length));
    let pattern = '';
    
    const changes = [];
    for (let i = 1; i < recent.length; i++) {
      changes.push(recent[i] === recent[i-1] ? 'Ù…Ø³ØªÙ…Ø±' : 'Ù…ØªØºÙŠØ±');
    }
    
    const consistentChanges = changes.filter(c => c === 'Ù…Ø³ØªÙ…Ø±').length;
    const changeRate = consistentChanges / changes.length;
    
    if (changeRate > 0.7) {
      pattern = 'Ø§Ù„Ù†Ù…Ø·: ØªØ³Ù„Ø³Ù„Ø§Øª Ø·ÙˆÙŠÙ„Ø© (Ù…Ø³ØªÙ‚Ø±) - ØºØ§Ù„Ø¨Ø§Ù‹ Ù…Ø§ ØªØ³ØªÙ…Ø± Ù†ÙØ³ Ø§Ù„Ù†ØªÙŠØ¬Ø©';
    } else if (changeRate > 0.4) {
      pattern = 'Ø§Ù„Ù†Ù…Ø·: Ù…Ø®ØªÙ„Ø· - ÙŠØªØºÙŠØ± Ø¨ÙŠÙ† Ø§Ù„Ø­ÙŠÙ† ÙˆØ§Ù„Ø¢Ø®Ø±';
    } else {
      pattern = 'Ø§Ù„Ù†Ù…Ø·: Ù…ØªÙ‚Ù„Ø¨ - ÙŠØªØºÙŠØ± Ø¨Ø´ÙƒÙ„ Ù…Ø³ØªÙ…Ø±';
    }
    
    const lastThree = recent.slice(-3);
    if (lastThree[0] === lastThree[1] && lastThree[1] === lastThree[2]) {
      pattern += '\nâš ï¸ ØªØ­Ø°ÙŠØ±: ØªØ³Ù„Ø³Ù„ Ù…Ù† 3 Ø¬ÙˆÙ„Ø§Øª Ù…ØªØªØ§Ù„ÙŠØ© Ø¨Ù†ÙØ³ Ø§Ù„Ù†ØªÙŠØ¬Ø©!';
    }
    
    return pattern;
  }

  getHelp() {
    return `ÙŠÙ…ÙƒÙ†Ùƒ Ø³Ø¤Ø§Ù„ÙŠ Ø¹Ù†:
1. "Ù…Ø§ Ù‡Ùˆ Ø§Ù„ØªÙ†Ø¨Ø¤ Ø§Ù„Ù‚Ø§Ø¯Ù…ØŸ" - Ù„Ù„Ø­ØµÙˆÙ„ Ø¹Ù„Ù‰ ØªÙˆÙ‚Ø¹ Ø§Ù„Ø¬ÙˆÙ„Ø© Ø§Ù„ØªØ§Ù„ÙŠØ©
2. "Ù…Ø§ Ù‡ÙŠ Ù†ØµÙŠØ­ØªÙƒØŸ" - Ù„Ù„Ø­ØµÙˆÙ„ Ø¹Ù„Ù‰ Ù†ØµÙŠØ­Ø© Ø§Ù„Ù„Ø¹Ø¨
3. "Ø­Ù„Ù„ Ù„ÙŠ Ø§Ù„Ù†ØªØ§Ø¦Ø¬" - Ù„ØªØ­Ù„ÙŠÙ„ Ø§Ù„Ø¬ÙˆÙ„Ø§Øª Ø§Ù„Ø³Ø§Ø¨Ù‚Ø©
4. "Ù…Ø§ Ù‡ÙŠ Ø§Ù„Ø¥Ø­ØµØ§Ø¡Ø§ØªØŸ" - Ù„Ø¹Ø±Ø¶ Ø§Ù„Ø£Ø±Ù‚Ø§Ù… ÙˆØ§Ù„Ø¥Ø­ØµØ§Ø¦ÙŠØ§Øª
5. "Ù…Ø§ Ù‡Ùˆ Ø£ÙØ¶Ù„ Ø®ÙŠØ§Ø± Ù„Ù„Ø±Ù‡Ø§Ù†ØŸ" - Ù„Ù†ØµÙŠØ­Ø© Ø§Ù„Ø±Ù‡Ø§Ù†
6. "Ù…Ø§ Ù‡Ùˆ Ù†Ù…Ø· Ø§Ù„Ù„Ø¹Ø¨ØŸ" - Ù„ØªØ­Ù„ÙŠÙ„ Ø§Ù„Ø£Ù†Ù…Ø§Ø· ÙˆØ§Ù„ØªØ³Ù„Ø³Ù„Ø§Øª

ÙŠÙ…ÙƒÙ†Ùƒ Ø£ÙŠØ¶Ø§Ù‹ Ø§Ù„ØªØ­Ø¯Ø« Ø¨Ø´ÙƒÙ„ Ø·Ø¨ÙŠØ¹ÙŠ ÙˆØ³Ø£Ø­Ø§ÙˆÙ„ ÙÙ‡Ù…Ùƒ!`;
  }

  calculateStreak(rounds, type) {
    let streak = 0;
    for (let i = rounds.length - 1; i >= 0; i--) {
      if (rounds[i] === type) {
        streak++;
      } else {
        break;
      }
    }
    return streak;
  }

  speak(text) {
    if (!this.voiceEnabled || this.isSpeaking) return;
    
    this.isSpeaking = true;
    
    // Ø¥Ù„ØºØ§Ø¡ Ø£ÙŠ ÙƒÙ„Ø§Ù… Ø³Ø§Ø¨Ù‚
    this.synth.cancel();
    
    // ØªØ£Ø®ÙŠØ± Ø¨Ø³ÙŠØ· Ù„Ù„Ø³Ù…Ø§Ø­ Ø¨Ø§Ù„ØªØ­Ø¶ÙŠØ±
    setTimeout(() => {
      try {
        const utterance = new SpeechSynthesisUtterance(text);
        utterance.lang = 'ar-SA';
        utterance.rate = this.voiceSpeed;
        utterance.pitch = 1;
        utterance.volume = 1;
        
        utterance.onend = () => {
          this.isSpeaking = false;
        };
        
        utterance.onerror = (error) => {
          console.error('Ø®Ø·Ø£ ÙÙŠ Ø§Ù„ØªØ­Ø¯Ø«:', error);
          this.isSpeaking = false;
        };
        
        this.synth.speak(utterance);
      } catch (error) {
        console.error('Ø®Ø·Ø£ ÙÙŠ ØªÙ‡ÙŠØ¦Ø© Ø§Ù„ÙƒÙ„Ø§Ù…:', error);
        this.isSpeaking = false;
      }
    }, 300);
  }

  showMessage(text, type = 'assistant') {
    const messagesEl = document.getElementById('voiceMessages');
    if (!messagesEl) return;
    
    const messageDiv = document.createElement('div');
    messageDiv.className = `voice-message ${type}`;
    messageDiv.textContent = text;
    
    messagesEl.appendChild(messageDiv);
    messagesEl.scrollTop = messagesEl.scrollHeight;
    
    // Ø­ÙØ¸ ÙÙŠ Ø§Ù„Ø³Ø¬Ù„
    this.chatHistory.push({
      text,
      type,
      timestamp: new Date().toISOString()
    });
    
    // Ø­ÙØ¸ Ø§Ù„Ø¥Ø¹Ø¯Ø§Ø¯Ø§Øª
    this.saveSettings();
  }

  updateUIStatus(text, status = 'ready') {
    const statusText = document.getElementById('statusText');
    const statusIndicator = document.getElementById('statusIndicator');
    const voiceBtn = document.getElementById('voiceAssistantBtn');
    const micIcon = document.getElementById('micIcon');
    const listeningText = document.getElementById('listeningText');
    
    if (statusText) statusText.textContent = text;
    if (statusIndicator) {
      statusIndicator.className = 'status-indicator';
      if (status === 'listening') {
        statusIndicator.classList.add('active');
        if (voiceBtn) voiceBtn.classList.add('listening');
        if (micIcon) micIcon.textContent = 'ğŸ”´';
        if (listeningText) listeningText.textContent = 'ÙŠØ³ØªÙ…Ø¹...';
      } else if (status === 'speaking') {
        if (voiceBtn) voiceBtn.classList.add('responding');
        if (micIcon) micIcon.textContent = 'ğŸ—£ï¸';
        if (listeningText) listeningText.textContent = 'ÙŠØªØ­Ø¯Ø«...';
      } else {
        if (voiceBtn) {
          voiceBtn.classList.remove('listening', 'responding');
        }
        if (micIcon) micIcon.textContent = 'ğŸ¤';
        if (listeningText) listeningText.textContent = 'Ø§Ø¨Ø¯Ø£ Ø§Ù„ØªØ­Ø¯Ø«';
      }
    }
  }

  clearChat() {
    const messagesEl = document.getElementById('voiceMessages');
    if (messagesEl) {
      messagesEl.innerHTML = `
        <div class="voice-message system">
          Ø£Ù‡Ù„Ø§Ù‹! Ø£Ù†Ø§ Ù…Ø³Ø§Ø¹Ø¯Ùƒ Ø§Ù„ØµÙˆØªÙŠ Ù„Ù„Ø¹Ø¨Ø© Baccarat Pro. ÙŠÙ…ÙƒÙ†Ùƒ Ø§Ù„ØªØ­Ø¯Ø« Ù…Ø¹ÙŠ Ù…Ø¨Ø§Ø´Ø±Ø© Ù„Ù„Ø­ØµÙˆÙ„ Ø¹Ù„Ù‰ Ø§Ù„Ù†ØµØ§Ø¦Ø­ ÙˆØ§Ù„ØªØ­Ù„ÙŠÙ„Ø§Øª.
        </div>
        <div class="voice-message system">
          Ù‚Ù„: "Ù…Ø§ Ù‡Ùˆ Ø§Ù„ØªÙ†Ø¨Ø¤ Ø§Ù„Ù‚Ø§Ø¯Ù…ØŸ" Ø£Ùˆ "Ù…Ø§ Ù‡ÙŠ Ù†ØµÙŠØ­ØªÙƒØŸ" Ø£Ùˆ "Ø­Ù„Ù„ Ù„ÙŠ Ø§Ù„Ù†ØªØ§Ø¦Ø¬ Ø§Ù„Ø³Ø§Ø¨Ù‚Ø©"
        </div>
      `;
    }
    this.chatHistory = [];
    this.saveSettings();
  }

  loadSettings() {
    try {
      const saved = localStorage.getItem('voiceAssistantSettings');
      if (saved) {
        const settings = JSON.parse(saved);
        this.voiceEnabled = settings.voiceEnabled !== false;
        this.voiceSpeed = settings.voiceSpeed || 1;
        this.chatHistory = settings.chatHistory || [];
        
        // ØªØ­Ø¯ÙŠØ« Ø¹Ù†Ø§ØµØ± Ø§Ù„ØªØ­ÙƒÙ…
        const voiceToggle = document.getElementById('voiceResponseToggle');
        const speedSelect = document.getElementById('voiceSpeedSelect');
        
        if (voiceToggle) voiceToggle.checked = this.voiceEnabled;
        if (speedSelect) speedSelect.value = this.voiceSpeed.toString();
        
        // Ø¥Ø¹Ø§Ø¯Ø© ØªØ­Ù…ÙŠÙ„ Ø³Ø¬Ù„ Ø§Ù„Ù…Ø­Ø§Ø¯Ø«Ø©
        this.restoreChatHistory();
      }
    } catch (error) {
      console.error('Ø®Ø·Ø£ ÙÙŠ ØªØ­Ù…ÙŠÙ„ Ø¥Ø¹Ø¯Ø§Ø¯Ø§Øª Ø§Ù„Ù…Ø³Ø§Ø¹Ø¯ Ø§Ù„ØµÙˆØªÙŠ:', error);
    }
  }

  saveSettings() {
    try {
      const settings = {
        voiceEnabled: this.voiceEnabled,
        voiceSpeed: this.voiceSpeed,
        chatHistory: this.chatHistory.slice(-50) // Ø­ÙØ¸ Ø¢Ø®Ø± 50 Ø±Ø³Ø§Ù„Ø© ÙÙ‚Ø·
      };
      localStorage.setItem('voiceAssistantSettings', JSON.stringify(settings));
    } catch (error) {
      console.error('Ø®Ø·Ø£ ÙÙŠ Ø­ÙØ¸ Ø¥Ø¹Ø¯Ø§Ø¯Ø§Øª Ø§Ù„Ù…Ø³Ø§Ø¹Ø¯ Ø§Ù„ØµÙˆØªÙŠ:', error);
    }
  }

  restoreChatHistory() {
    const messagesEl = document.getElementById('voiceMessages');
    if (!messagesEl || this.chatHistory.length === 0) return;
    
    messagesEl.innerHTML = '';
    
    this.chatHistory.forEach(msg => {
      const messageDiv = document.createElement('div');
      messageDiv.className = `voice-message ${msg.type}`;
      messageDiv.textContent = msg.text;
      messagesEl.appendChild(messageDiv);
    });
    
    messagesEl.scrollTop = messagesEl.scrollHeight;
  }

  getChatHistory() {
    return this.chatHistory.slice(-50); // Ø¥Ø±Ø¬Ø§Ø¹ Ø¢Ø®Ø± 50 Ø±Ø³Ø§Ù„Ø© ÙÙ‚Ø·
  }

  loadChatHistory(history) {
    if (Array.isArray(history)) {
      this.chatHistory = history;
      this.restoreChatHistory();
    }
  }
}

// ========== Ø§Ù„Ø­Ø§Ù„Ø© Ø§Ù„Ø¹Ø§Ù…Ø© Ù„Ù„ØªØ·Ø¨ÙŠÙ‚ ==========
const state = {
  rounds: [],
  windowSize: 8,
  count: { P: 0, B: 0, T: 0 },
  win: { P: 0, B: 0, T: 0 },
  loss: { P: 0, B: 0, T: 0 },
  lastPrediction: null,
  accuracyHistory: [],
  predictionsHistory: [],
  analysisMode: 'advanced',
  confidenceThreshold: 45,
  timeWeighting: 'linear',
  modelPerformance: { basic: 0, advanced: 0, pattern: 0, ml: 0 },
  previousPredictions: { P: 0, B: 0, T: 0 },
  ml: new BaccaratMachineLearning(),
  useML: true,
  mlModel: 'ensemble'
};

// Ø¥Ù†Ø´Ø§Ø¡ Ù…Ø¯ÙŠØ± Ø§Ù„Ø¨ÙŠØ§Ù†Ø§Øª
const dataManager = new DataManager();

// Ø¥Ù†Ø´Ø§Ø¡ Ø§Ù„Ù…Ø³Ø§Ø¹Ø¯ Ø§Ù„ØµÙˆØªÙŠ
const voiceAssistant = new VoiceAssistant();

// ========== Ø§Ù„ÙˆØ¸Ø§Ø¦Ù Ø§Ù„Ù…Ø³Ø§Ø¹Ø¯Ø© ==========
const el = id => document.getElementById(id);

// ========== Ø§Ù„ÙˆØ¸Ø§Ø¦Ù Ø§Ù„Ø±Ø¦ÙŠØ³ÙŠØ© ==========
function init() {
  console.log('Initializing Baccarat Pro with Voice Assistant...');
  
  dataManager.loadAllData();
  
  el('windowSize').value = state.windowSize;
  
  el('applyWindow').onclick = () => {
    const v = parseInt(el('windowSize').value);
    if (v >= 5 && v <= 15) {
      state.windowSize = v;
      updateAll();
      showToast(`ØªÙ… ØªØºÙŠÙŠØ± Ù†Ø§ÙØ°Ø© Ø§Ù„ØªØ­Ù„ÙŠÙ„ Ø¥Ù„Ù‰ ${v} Ø¬ÙˆÙ„Ø§Øª`);
    } else {
      showToast('Ø§Ù„Ù†Ø§ÙØ°Ø© ÙŠØ¬Ø¨ Ø£Ù† ØªÙƒÙˆÙ† Ø¨ÙŠÙ† 5 Ùˆ 15', 'error');
    }
  };

  el('analysisMode').value = state.analysisMode;
  el('analysisMode').onchange = (e) => {
    state.analysisMode = e.target.value;
    updateAll();
    showToast(`ØªÙ… ØªØºÙŠÙŠØ± Ù†Ù…Ø· Ø§Ù„ØªØ­Ù„ÙŠÙ„ Ø¥Ù„Ù‰ ${getModeName(state.analysisMode)}`);
  };

  el('confidenceSensitivity').value = state.confidenceThreshold;
  el('confidenceSensitivity').oninput = (e) => {
    state.confidenceThreshold = parseInt(e.target.value);
    el('sensitivityValue').textContent = state.confidenceThreshold + '%';
    updateAll();
  };

  el('timeWeighting').value = state.timeWeighting;
  el('timeWeighting').onchange = (e) => {
    state.timeWeighting = e.target.value;
    updateAll();
    showToast(`ØªÙ… ØªØºÙŠÙŠØ± Ø§Ù„Ù…Ø±Ø¬Ø­Ø© Ø§Ù„Ø²Ù…Ù†ÙŠØ© Ø¥Ù„Ù‰ ${getWeightingName(state.timeWeighting)}`);
  };

  el('mlToggle').checked = state.useML;
  el('mlToggle').onchange = (e) => {
    state.useML = e.target.checked;
    state.ml.isEnabled = state.useML;
    updateMLStatus();
    updateAll();
    showToast(`ØªØ¹Ù„Ù… Ø§Ù„Ø¢Ù„Ø© ${state.useML ? 'Ù…ÙØ¹Ù„' : 'Ù…Ø¹Ø·Ù„'}`);
  };

  el('mlModelSelect').value = state.mlModel;
  el('mlModelSelect').onchange = (e) => {
    state.mlModel = e.target.value;
    state.ml.setActiveModel(state.mlModel);
    updateMLStatus();
    updateAll();
    showToast(`ØªÙ… ØªØºÙŠÙŠØ± Ù†Ù…ÙˆØ°Ø¬ ML Ø¥Ù„Ù‰ ${getMLModelName(state.mlModel)}`);
  };

  el('btnP').onclick = () => pushRound('P');
  el('btnB').onclick = () => pushRound('B');
  el('btnT').onclick = () => pushRound('T');
  el('btnUndo').onclick = undoRound;
  el('btnReset').onclick = resetAll;
  
  el('btnExport').onclick = () => dataManager.exportData();
  el('btnImport').onclick = () => {
    const input = document.createElement('input');
    input.type = 'file';
    input.accept = '.json';
    input.onchange = (e) => {
      if (e.target.files && e.target.files[0]) {
        dataManager.importData(e.target.files[0]);
      }
    };
    input.click();
  };
  el('btnClearData').onclick = () => dataManager.clearAllData();
  
  el('themeToggle').onclick = toggleTheme;
  
  if (!document.documentElement.hasAttribute('data-theme')) {
    document.documentElement.setAttribute('data-theme', 'dark');
  }
  
  dataManager.startAutoSave(30);
  
  // Ø¥Ø¹Ø¯Ø§Ø¯ Ø§Ù„Ù…Ø³Ø§Ø¹Ø¯ Ø§Ù„ØµÙˆØªÙŠ
  setupVoiceAssistant();
  
  updateAll();
  updateMLStatus();
  dataManager.updateDataStats();
  
  console.log('Initialization complete with Voice Assistant');
}

function setupVoiceAssistant() {
  // Ø²Ø± ÙØªØ­/Ø¥ØºÙ„Ø§Ù‚ Ù„ÙˆØ­Ø© Ø§Ù„Ù…Ø³Ø§Ø¹Ø¯
  const voiceBtn = el('voiceAssistantBtn');
  const voicePanel = el('voiceAssistantPanel');
  const voiceCloseBtn = el('voiceCloseBtn');
  
  voiceBtn.addEventListener('click', () => {
    voicePanel.classList.toggle('active');
    if (voicePanel.classList.contains('active')) {
      voiceBtn.style.transform = 'scale(1.1)';
    } else {
      voiceBtn.style.transform = 'scale(1)';
    }
  });
  
  voiceCloseBtn.addEventListener('click', () => {
    voicePanel.classList.remove('active');
    voiceBtn.style.transform = 'scale(1)';
  });
  
  // Ø£Ø²Ø±Ø§Ø± Ø§Ù„ØªØ­ÙƒÙ… ÙÙŠ Ø§Ù„Ù…Ø³Ø§Ø¹Ø¯
  el('startListeningBtn').addEventListener('click', () => {
    voiceAssistant.startListening();
  });
  
  el('stopListeningBtn').addEventListener('click', () => {
    voiceAssistant.stopListening();
  });
  
  el('clearChatBtn').addEventListener('click', () => {
    voiceAssistant.clearChat();
  });
  
  // Ø£Ø²Ø±Ø§Ø± Ø§Ù„Ø£ÙˆØ§Ù…Ø± Ø§Ù„Ø³Ø±ÙŠØ¹Ø©
  document.querySelectorAll('.voice-quick-btn').forEach(btn => {
    btn.addEventListener('click', (e) => {
      const command = e.target.getAttribute('data-command');
      voiceAssistant.processVoiceCommand(command);
    });
  });
  
  // Ø¥Ø¹Ø¯Ø§Ø¯Ø§Øª Ø§Ù„ØµÙˆØª
  el('voiceResponseToggle').addEventListener('change', (e) => {
    voiceAssistant.voiceEnabled = e.target.checked;
    voiceAssistant.saveSettings();
    showToast(`Ø§Ù„Ø±Ø¯ Ø§Ù„ØµÙˆØªÙŠ ${voiceAssistant.voiceEnabled ? 'Ù…ÙØ¹Ù„' : 'Ù…Ø¹Ø·Ù„'}`);
  });
  
  el('voiceSpeedSelect').addEventListener('change', (e) => {
    voiceAssistant.voiceSpeed = parseFloat(e.target.value);
    voiceAssistant.saveSettings();
    showToast(`ØªÙ… ØªØºÙŠÙŠØ± Ø³Ø±Ø¹Ø© Ø§Ù„ØµÙˆØª Ø¥Ù„Ù‰ ${e.target.options[e.target.selectedIndex].text}`);
  });
  
  // Ø¥ØºÙ„Ø§Ù‚ Ø§Ù„Ù„ÙˆØ­Ø© Ø¨Ø§Ù„Ù†Ù‚Ø± Ø®Ø§Ø±Ø¬Ù‡Ø§
  document.addEventListener('click', (e) => {
    if (!voicePanel.contains(e.target) && !voiceBtn.contains(e.target) && voicePanel.classList.contains('active')) {
      voicePanel.classList.remove('active');
      voiceBtn.style.transform = 'scale(1)';
    }
  });
}

function toggleTheme() {
  const currentTheme = document.documentElement.getAttribute('data-theme');
  const newTheme = currentTheme === 'dark' ? 'light' : 'dark';
  document.documentElement.setAttribute('data-theme', newTheme);
  el('themeToggle').textContent = newTheme === 'dark' ? 'ğŸŒš' : 'ğŸŒ•';
  showToast(`ØªÙ… Ø§Ù„ØªØ¨Ø¯ÙŠÙ„ Ø¥Ù„Ù‰ Ø§Ù„ÙˆØ¶Ø¹ ${newTheme === 'dark' ? 'Ø§Ù„Ù„ÙŠÙ„ÙŠ' : 'Ø§Ù„Ù†Ù‡Ø§Ø±ÙŠ'}`);
}

function getModeName(mode) {
  const names = {
    basic: 'Ø£Ø³Ø§Ø³ÙŠ',
    advanced: 'Ù…ØªÙ‚Ø¯Ù…',
    pattern: 'ØªØ­Ù„ÙŠÙ„ Ø§Ù„Ø£Ù†Ù…Ø§Ø·',
    ml: 'ØªØ¹Ù„Ù… Ø§Ù„Ø¢Ù„Ø©'
  };
  return names[mode] || mode;
}

function getWeightingName(weighting) {
  const names = {
    none: 'Ø¨Ø¯ÙˆÙ†',
    linear: 'Ø®Ø·ÙŠ',
    exponential: 'Ø£Ø³Ù‘ÙŠ'
  };
  return names[weighting] || weighting;
}

function getMLModelName(model) {
  const names = {
    knn: 'K-Ø§Ù„Ø¬ÙŠØ±Ø§Ù† Ø§Ù„Ø£Ù‚Ø±Ø¨',
    logistic: 'Ø§Ù„Ø§Ù†Ø­Ø¯Ø§Ø± Ø§Ù„Ù„ÙˆØ¬Ø³ØªÙŠ',
    ensemble: 'Ø§Ù„Ù…Ø¬Ù…Ø¹'
  };
  return names[model] || model;
}

function showToast(message, type = 'success') {
  const toast = document.createElement('div');
  toast.textContent = message;
  toast.style.cssText = `
    position: fixed;
    top: 20px;
    right: 20px;
    background: ${type === 'error' ? '#ef4444' : '#10b981'};
    color: white;
    padding: 12px 20px;
    border-radius: 8px;
    z-index: 1000;
    box-shadow: 0 4px 12px rgba(0,0,0,0.3);
    animation: slideIn 0.3s ease-out;
  `;
  
  document.body.appendChild(toast);
  
  setTimeout(() => {
    toast.style.animation = 'slideOut 0.3s ease-in';
    setTimeout(() => {
      if (toast.parentNode) {
        document.body.removeChild(toast);
      }
    }, 300);
  }, 3000);
}

const style = document.createElement('style');
style.textContent = `
@keyframes slideIn {
  from { transform: translateX(100%); opacity: 0; }
  to { transform: translateX(0); opacity: 1; }
}
@keyframes slideOut {
  from { transform: translateX(0); opacity: 1; }
  to { transform: translateX(100%); opacity: 0; }
}
`;
document.head.appendChild(style);

// ========== Ø®ÙˆØ§Ø±Ø²Ù…ÙŠØ§Øª Ø§Ù„ØªØ­Ù„ÙŠÙ„ ==========
function frequencyAnalysis(rounds) {
  if (!rounds || rounds.length === 0) {
    return { P: 33.3, B: 33.3, T: 33.3 };
  }
  
  const counts = { P: 0, B: 0, T: 0 };
  rounds.forEach(x => {
    if (x in counts) counts[x]++;
  });
  
  const total = rounds.length;
  return {
    P: (counts.P / total) * 100,
    B: (counts.B / total) * 100,
    T: (counts.T / total) * 100
  };
}

function patternAnalysis(rounds) {
  if (!rounds || rounds.length < 3) {
    return { P: 0, B: 0, T: 0 };
  }

  const patterns = {};
  for (let i = 2; i < rounds.length; i++) {
    const pattern = rounds.slice(i-2, i).join('');
    const next = rounds[i];
    
    if (!patterns[pattern]) {
      patterns[pattern] = { P: 0, B: 0, T: 0, total: 0 };
    }
    
    if (next in patterns[pattern]) {
      patterns[pattern][next]++;
      patterns[pattern].total++;
    }
  }

  if (rounds.length >= 2) {
    const lastPattern = rounds.slice(-2).join('');
    const patternData = patterns[lastPattern];
    
    if (patternData && patternData.total >= 1) {
      return {
        P: (patternData.P / patternData.total) * 100,
        B: (patternData.B / patternData.total) * 100,
        T: (patternData.T / patternData.total) * 100
      };
    }
  }

  return { P: 0, B: 0, T: 0 };
}

function applyTimeWeighting(rounds, basePrediction) {
  if (state.timeWeighting === 'none' || !rounds || rounds.length < 2) {
    return basePrediction;
  }

  const n = rounds.length;
  let weightFactor = 1;
  
  if (state.timeWeighting === 'linear') {
    weightFactor = 0.8 + (0.4 * (1 / n));
  } else if (state.timeWeighting === 'exponential') {
    weightFactor = 0.7 + (0.6 * Math.pow(0.9, n));
  }

  return {
    P: basePrediction.P * weightFactor,
    B: basePrediction.B * weightFactor,
    T: basePrediction.T * weightFactor
  };
}

function enhancedPredict() {
  const n = Math.min(state.windowSize, state.rounds.length);
  const recent = state.rounds.slice(-n);
  
  if (recent.length === 0) {
    return { 
      P: 33.3, B: 33.3, T: 33.3, 
      final: 'â€”',
      confidence: 0,
      model: 'basic',
      mlContribution: 0
    };
  }

  let basePrediction, patternBoost, finalPrediction;
  let modelUsed = state.analysisMode;
  let mlContribution = 0;

  switch(state.analysisMode) {
    case 'basic':
      basePrediction = frequencyAnalysis(recent);
      finalPrediction = basePrediction;
      break;
      
    case 'advanced':
      basePrediction = frequencyAnalysis(recent);
      patternBoost = patternAnalysis(recent);
      
      finalPrediction = {
        P: basePrediction.P * 0.7 + patternBoost.P * 0.3,
        B: basePrediction.B * 0.7 + patternBoost.B * 0.3,
        T: basePrediction.T * 0.7 + patternBoost.T * 0.3
      };
      break;
      
    case 'pattern':
      basePrediction = frequencyAnalysis(recent);
      patternBoost = patternAnalysis(recent);
      
      finalPrediction = {
        P: basePrediction.P * 0.4 + patternBoost.P * 0.6,
        B: basePrediction.B * 0.4 + patternBoost.B * 0.6,
        T: basePrediction.T * 0.4 + patternBoost.T * 0.6
      };
      break;
      
    case 'ml':
      basePrediction = frequencyAnalysis(recent);
      
      let mlPrediction = state.ml.predict(state.rounds, state.windowSize);
      if (!mlPrediction) {
        mlPrediction = { P: 33.3, B: 33.3, T: 33.3 };
      }
      
      const mlWeight = state.ml.getMLWeight();
      mlContribution = mlWeight * 100;
      
      finalPrediction = {
        P: basePrediction.P * (1 - mlWeight) + mlPrediction.P * mlWeight,
        B: basePrediction.B * (1 - mlWeight) + mlPrediction.B * mlWeight,
        T: basePrediction.T * (1 - mlWeight) + mlPrediction.T * mlWeight
      };
      break;
  }

  finalPrediction = applyTimeWeighting(recent, finalPrediction);

  const sum = finalPrediction.P + finalPrediction.B + finalPrediction.T;
  if (sum > 0) {
    finalPrediction.P = (finalPrediction.P / sum) * 100;
    finalPrediction.B = (finalPrediction.B / sum) * 100;
    finalPrediction.T = (finalPrediction.T / sum) * 100;
  }

  const entries = Object.entries(finalPrediction);
  const sorted = entries.sort((a, b) => b[1] - a[1]);
  
  const confidence = sorted[0][1] - (sorted[1] ? sorted[1][1] : 0);
  let final = sorted[0][0];
  
  if (sorted[0][1] < state.confidenceThreshold) {
    final = 'â€”';
  }

  return {
    P: finalPrediction.P.toFixed(1),
    B: finalPrediction.B.toFixed(1),
    T: finalPrediction.T.toFixed(1),
    final,
    confidence: Math.min(100, Math.max(0, confidence * 2)),
    model: modelUsed,
    mlContribution: mlContribution.toFixed(1)
  };
}

function pushRound(r) {
  if (!['P', 'B', 'T'].includes(r)) return;
  
  const pred = enhancedPredict();
  state.lastPrediction = pred.final;
  
  state.ml.updateModel(state.rounds, state.windowSize, r);
  
  state.rounds.push(r);
  state.count[r]++;
  
  if (state.lastPrediction !== 'â€”' && state.lastPrediction !== null) {
    const didWin = (r === state.lastPrediction);
    
    if (didWin) {
      state.win[state.lastPrediction]++;
      state.modelPerformance[state.analysisMode] = (state.modelPerformance[state.analysisMode] || 0) + 1;
    } else {
      state.loss[state.lastPrediction] = (state.loss[state.lastPrediction] || 0) + 1;
    }
  }
  
  updateAccuracyData(r);
  
  const newPred = enhancedPredict();
  updatePredictionDisplay(newPred);
  showResult(r, newPred, state.lastPrediction === r);
  updateAll();
  dataManager.saveAllData();
  dataManager.updateDataStats();
  
  playSound('click');
  
  // ØªØ­Ø¯ÙŠØ« Ø§Ù„Ù…Ø³Ø§Ø¹Ø¯ Ø§Ù„ØµÙˆØªÙŠ Ø¨Ø¹Ø¯ ÙƒÙ„ Ø¬ÙˆÙ„Ø©
  if (voiceAssistant && state.rounds.length > 2) {
    const recentChange = state.rounds.slice(-3);
    if (recentChange[0] === recentChange[1] && recentChange[1] === recentChange[2]) {
      voiceAssistant.showMessage(`âš ï¸ ØªØ³Ù„Ø³Ù„ Ù…Ù† 3 Ø¬ÙˆÙ„Ø§Øª Ù…ØªØªØ§Ù„ÙŠØ© Ù„Ù€ ${recentChange[0] === 'P' ? 'Ù„Ø§Ø¹Ø¨' : recentChange[0] === 'B' ? 'Ù…ØµØ±ÙÙŠ' : 'ØªØ¹Ø§Ø¯Ù„'}!`, 'system');
      if (voiceAssistant.voiceEnabled) {
        setTimeout(() => {
          voiceAssistant.speak(`ØªØ­Ø°ÙŠØ±! Ù‡Ù†Ø§Ùƒ ØªØ³Ù„Ø³Ù„ Ù…Ù† 3 Ø¬ÙˆÙ„Ø§Øª Ù…ØªØªØ§Ù„ÙŠØ©`);
        }, 1000);
      }
    }
  }
}

function undoRound() {
  if (state.rounds.length === 0) return;
  
  const lastRound = state.rounds.pop();
  state.count[lastRound] = Math.max(0, state.count[lastRound] - 1);
  
  if (state.rounds.length > 0) {
    const previousPrediction = enhancedPredict();
    if (lastRound === previousPrediction.final) {
      state.win[previousPrediction.final] = Math.max(0, state.win[previousPrediction.final] - 1);
      state.modelPerformance[state.analysisMode] = Math.max(0, state.modelPerformance[state.analysisMode] - 1);
    } else {
      state.loss[previousPrediction.final] = Math.max(0, state.loss[previousPrediction.final] - 1);
    }
  }
  
  if (state.accuracyHistory.length > 0) {
    state.accuracyHistory.pop();
    state.predictionsHistory.pop();
  }
  
  state.lastPrediction = null;
  
  state.ml.reset();
  for (let i = 0; i < state.rounds.length; i++) {
    if (i >= state.windowSize) {
      const recent = state.rounds.slice(i - state.windowSize, i);
      state.ml.updateModel(recent, state.windowSize, state.rounds[i]);
    }
  }
  
  updateAll();
  dataManager.saveAllData();
  dataManager.updateDataStats();
  playSound('undo');
}

function resetAll() {
  if (state.rounds.length === 0) return;
  
  if (!confirm('Ù‡Ù„ ØªØ±ÙŠØ¯ Ø¥Ø¹Ø§Ø¯Ø© ØªØ¹ÙŠÙŠÙ† Ø¬Ù…ÙŠØ¹ Ø§Ù„Ø¨ÙŠØ§Ù†Ø§ØªØŸ')) return;
  
  state.rounds = [];
  state.count = { P: 0, B: 0, T: 0 };
  state.win = { P: 0, B: 0, T: 0 };
  state.loss = { P: 0, B: 0, T: 0 };
  state.lastPrediction = null;
  state.accuracyHistory = [];
  state.predictionsHistory = [];
  state.modelPerformance = { basic: 0, advanced: 0, pattern: 0, ml: 0 };
  state.previousPredictions = { P: 0, B: 0, T: 0 };
  
  state.ml.reset();
  
  updateAll();
  dataManager.saveAllData();
  dataManager.updateDataStats();
  playSound('reset');
}

function playSound(type) {
  try {
    if (type === 'click') {
      const audio = new Audio('data:audio/wav;base64,UklGRigAAABXQVZFZm10IBIAAAABAAEARKwAAIhYAQACABAAZGF0YQQAAAAAAA==');
      audio.volume = 0.1;
      audio.play();
    }
  } catch (e) {
    // ØªØ¬Ø§Ù‡Ù„ Ø£Ø®Ø·Ø§Ø¡ Ø§Ù„ØµÙˆØª
  }
}

function updatePredictionDisplay(pred) {
  el('predPctP').textContent = pred.P + '%';
  el('predPctB').textContent = pred.B + '%';
  el('predPctT').textContent = pred.T + '%';
  
  updateTrendIndicators(pred);
  
  ['predP', 'predB', 'predT'].forEach(id => {
    el(id).classList.remove('active');
  });
  
  if (pred.final !== 'â€”') {
    const finalEl = el('pred' + pred.final);
    if (finalEl) finalEl.classList.add('active');
  }
  
  let finalText = 'â€”';
  if (pred.final === 'P') finalText = 'Ù„Ø§Ø¹Ø¨';
  else if (pred.final === 'B') finalText = 'Ù…ØµØ±ÙÙŠ';
  else if (pred.final === 'T') finalText = 'ØªØ¹Ø§Ø¯Ù„';
  
  el('finalCard').textContent = finalText;
  
  el('mlContribution').textContent = pred.mlContribution > 0 ? 
    `ğŸ“Š Ù…Ø³Ø§Ù‡Ù…Ø© ØªØ¹Ù„Ù… Ø§Ù„Ø¢Ù„Ø©: ${pred.mlContribution}%` : '';
  
  updateConfidenceMeter(pred.confidence);
  updateModelInfo(pred);
}

function updateTrendIndicators(pred) {
  const current = { 
    P: parseFloat(pred.P) || 0, 
    B: parseFloat(pred.B) || 0, 
    T: parseFloat(pred.T) || 0 
  };
  const previous = state.previousPredictions;
  
  ['P', 'B', 'T'].forEach(type => {
    const trendEl = el('predTrend' + type);
    if (!trendEl) return;
    
    if (previous[type] > 0) {
      const diff = current[type] - previous[type];
      if (diff > 2) trendEl.textContent = 'â†—';
      else if (diff < -2) trendEl.textContent = 'â†˜';
      else trendEl.textContent = 'â†’';
      trendEl.style.color = diff > 0 ? '#38b000' : diff < 0 ? '#ff006e' : '#bfb7a6';
    } else {
      trendEl.textContent = 'â†’';
    }
  });
  
  state.previousPredictions = current;
}

function updateConfidenceMeter(confidence) {
  const fill = el('confidenceFill');
  const label = el('confidenceLabel');
  
  if (!fill || !label) return;
  
  fill.style.width = confidence + '%';
  
  if (confidence >= 70) {
    fill.className = 'confidence-fill high-confidence';
    label.textContent = 'Ø«Ù‚Ø© Ø¹Ø§Ù„ÙŠØ©';
    label.style.color = '#38b000';
  } else if (confidence >= 40) {
    fill.className = 'confidence-fill medium-confidence';
    label.textContent = 'Ø«Ù‚Ø© Ù…ØªÙˆØ³Ø·Ø©';
    label.style.color = '#d4af37';
  } else {
    fill.className = 'confidence-fill';
    label.textContent = 'Ø«Ù‚Ø© Ù…Ù†Ø®ÙØ¶Ø©';
    label.style.color = '#ff006e';
  }
}

function updateModelInfo(pred) {
  const modelEl = el('predModel');
  const modelInfoEl = el('modelInfo');
  const reasonEl = el('predictionReason');
  
  if (!modelEl || !modelInfoEl || !reasonEl) return;
  
  let modelName, modelClass, reason;
  
  switch(pred.model) {
    case 'basic':
      modelName = 'Ø£Ø³Ø§Ø³ÙŠ';
      modelClass = 'badge-basic';
      reason = 'ÙŠØ¹ØªÙ…Ø¯ Ø¹Ù„Ù‰ ØªØ­Ù„ÙŠÙ„ Ø§Ù„ØªØ±Ø¯Ø¯ Ø§Ù„Ø£Ø³Ø§Ø³ÙŠ';
      break;
    case 'advanced':
      modelName = 'Ù…ØªÙ‚Ø¯Ù…';
      modelClass = 'badge-advanced';
      reason = 'ÙŠØ¬Ù…Ø¹ Ø¨ÙŠÙ† ØªØ­Ù„ÙŠÙ„ Ø§Ù„ØªØ±Ø¯Ø¯ ÙˆØ§Ù„Ø£Ù†Ù…Ø§Ø·';
      break;
    case 'pattern':
      modelName = 'Ø§Ù„Ø£Ù†Ù…Ø§Ø·';
      modelClass = 'badge-pattern';
      reason = 'ÙŠØ±ÙƒØ² Ø¹Ù„Ù‰ ØªØ­Ù„ÙŠÙ„ Ø§Ù„ØªØ³Ù„Ø³Ù„Ø§Øª ÙˆØ§Ù„Ø£Ù†Ù…Ø§Ø·';
      break;
    case 'ml':
      modelName = 'ØªØ¹Ù„Ù… Ø§Ù„Ø¢Ù„Ø©';
      modelClass = 'badge-ml';
      reason = 'ÙŠØ³ØªØ®Ø¯Ù… Ø®ÙˆØ§Ø±Ø²Ù…ÙŠØ§Øª ML Ù…Ø¹ Ø§Ù„ØªØ¯Ø±ÙŠØ¨ Ø§Ù„ØªÙ„Ù‚Ø§Ø¦ÙŠ';
      break;
    default:
      modelName = 'Ø£Ø³Ø§Ø³ÙŠ';
      modelClass = 'badge-basic';
      reason = 'ÙŠØ¹ØªÙ…Ø¯ Ø¹Ù„Ù‰ ØªØ­Ù„ÙŠÙ„ Ø§Ù„ØªØ±Ø¯Ø¯ Ø§Ù„Ø£Ø³Ø§Ø³ÙŠ';
  }
  
  modelEl.textContent = modelName;
  modelEl.className = 'model-badge ' + modelClass;
  
  const efficiency = calculateModelEfficiency();
  modelInfoEl.textContent = `Ø§Ù„Ù†Ù…ÙˆØ°Ø¬: ${modelName} - Ø§Ù„ÙƒÙØ§Ø¡Ø©: ${efficiency}%`;
  
  if (pred.final === 'â€”') {
    reasonEl.textContent = 'Ø¹Ø¯Ù… ÙƒÙØ§ÙŠØ© Ø§Ù„Ø«Ù‚Ø© Ù„Ù„ØªÙ†Ø¨Ø¤ (ØªØ­Øª ' + state.confidenceThreshold + '%)';
  } else {
    reasonEl.textContent = reason + ` - Ø§Ù„Ø«Ù‚Ø©: ${pred.confidence.toFixed(1)}%`;
  }
}

function calculateModelEfficiency() {
  const total = Object.values(state.modelPerformance).reduce((a, b) => a + b, 0);
  const current = state.modelPerformance[state.analysisMode] || 0;
  return total > 0 ? Math.round((current / total) * 100) : 0;
}

function showResult(r, pred, didWin) {
  const finalCard = el('finalCard');
  if (!finalCard) return;
  
  finalCard.classList.remove('win-effect', 'loss-effect');
  setTimeout(() => {
    finalCard.classList.add(didWin ? 'win-effect' : 'loss-effect');
  }, 10);
}

function updateMLStatus() {
  const trainingCount = state.ml.getTrainingDataCount();
  const mlWeight = state.ml.getMLWeight() * 100;
  const mlAccuracy = state.ml.getModelAccuracy(state.mlModel);
  
  el('mlTrainingCount').textContent = trainingCount;
  el('mlWeight').textContent = mlWeight.toFixed(0) + '%';
  el('mlAccuracy').textContent = mlAccuracy.toFixed(1) + '%';
  
  const statusEl = el('mlStatus');
  if (!statusEl) return;
  
  if (trainingCount < 5) {
    statusEl.innerHTML = '<span class="ml-training-indicator ml-not-trained"></span> ÙŠØ­ØªØ§Ø¬ Ø§Ù„Ù…Ø²ÙŠØ¯ Ù…Ù† Ø§Ù„Ø¨ÙŠØ§Ù†Ø§Øª';
    statusEl.style.color = '#ff006e';
  } else if (trainingCount < 15) {
    statusEl.innerHTML = '<span class="ml-training-indicator ml-training"></span> ÙŠØªØ¹Ù„Ù…...';
    statusEl.style.color = '#d4af37';
  } else {
    statusEl.innerHTML = '<span class="ml-training-indicator ml-training"></span> Ø¬Ø§Ù‡Ø² Ù„Ù„ØªÙ†Ø¨Ø¤';
    statusEl.style.color = '#38b000';
  }
  
  el('mlOverallAccuracy').textContent = mlAccuracy.toFixed(1) + '%';
}

function updateAll() {
  renderStats();
  renderBigRoad();
  updatePredictionCounts();
  updateMLStats();
  updateDataStatsDisplay();
}

function updateDataStatsDisplay() {
  dataManager.updateDataStats();
}

function updateMLStats() {
  const mlAccuracy = state.ml.getModelAccuracy(state.mlModel);
  el('mlOverallAccuracy').textContent = mlAccuracy.toFixed(1) + '%';
  
  el('pMLAccuracy').textContent = (mlAccuracy * 0.9).toFixed(1) + '%';
  el('bMLAccuracy').textContent = (mlAccuracy * 0.95).toFixed(1) + '%';
  el('tMLAccuracy').textContent = (mlAccuracy * 0.7).toFixed(1) + '%';
}

function renderStats() {
  el('pTotal').textContent = state.count.P;
  el('bTotal').textContent = state.count.B;
  el('tTotal').textContent = state.count.T;
  
  el('pWin').textContent = state.win.P;
  el('bWin').textContent = state.win.B;
  el('tWin').textContent = state.win.T;
  
  el('pLoss').textContent = state.loss.P;
  el('bLoss').textContent = state.loss.B;
  el('tLoss').textContent = state.loss.T;
  
  el('pPct').textContent = calculatePercentage(state.win.P, state.loss.P);
  el('bPct').textContent = calculatePercentage(state.win.B, state.loss.B);
  el('tPct').textContent = calculatePercentage(state.win.T, state.loss.T);
  
  el('pAccuracy').textContent = calculateAccuracy('P');
  el('bAccuracy').textContent = calculateAccuracy('B');
  el('tAccuracy').textContent = calculateAccuracy('T');
}

function calculatePercentage(win, loss) {
  const total = win + loss;
  return total > 0 ? ((win / total) * 100).toFixed(1) + '%' : '0%';
}

function calculateAccuracy(type) {
  const totalPredictions = state.predictionsHistory.filter(p => p.prediction === type).length;
  const correctPredictions = state.predictionsHistory.filter(p => p.prediction === type && p.correct).length;
  return totalPredictions > 0 ? ((correctPredictions / totalPredictions) * 100).toFixed(1) + '%' : '0%';
}

function renderBigRoad() {
  const canvas = el('bigRoad');
  if (!canvas) return;
  
  const ctx = canvas.getContext('2d');
  ctx.clearRect(0, 0, canvas.width, canvas.height);
  
  const size = 35;
  let x = 0, y = 0;
  const maxCols = Math.floor(canvas.width / size);
  
  for (let i = 0; i < state.rounds.length; i++) {
    const r = state.rounds[i];
    
    ctx.fillStyle = r === 'P' ? '#3a86ff' : r === 'B' ? '#ff006e' : '#38b000';
    ctx.fillRect(x * size, y * size, size - 2, size - 2);
    
    ctx.fillStyle = '#ffffff';
    ctx.font = 'bold 14px Inter';
    ctx.textAlign = 'center';
    ctx.textBaseline = 'middle';
    ctx.fillText((i+1).toString(), x * size + size/2, y * size + size/2);
    
    y++;
    if (y * size >= canvas.height) {
      y = 0;
      x++;
      if (x >= maxCols) break;
    }
  }
}

function updatePredictionCounts() {
  const pred = enhancedPredict();
  updatePredictionDisplay(pred);
}

function updatePatternInfo() {
  const infoEl = el('patternInfo');
  if (!infoEl) return;
  
  if (state.rounds.length < 3) {
    infoEl.textContent = 'Ù„Ø§ ØªÙˆØ¬Ø¯ Ø£Ù†Ù…Ø§Ø· Ù…ÙƒØªØ´ÙØ© Ø¨Ø¹Ø¯';
    return;
  }
  
  const trend = calculateTrend(state.rounds);
  const recent = state.rounds.slice(-5);
  const pCount = recent.filter(r => r === 'P').length;
  const bCount = recent.filter(r => r === 'B').length;
  const tCount = recent.filter(r => r === 'T').length;
  
  let info = `Ø§Ù„Ø§ØªØ¬Ø§Ù‡: ${trend.direction === 'volatile' ? 'Ù…ØªÙ‚Ù„Ø¨' : trend.direction === 'mixed' ? 'Ù…Ø®ØªÙ„Ø·' : 'Ù…Ø³ØªÙ‚Ø±'}`;
  info += ` | Ø¢Ø®Ø± 5: ğŸ”µ${pCount} ğŸ”´${bCount} ğŸŸ¢${tCount}`;
  
  infoEl.textContent = info;
}

function calculateTrend(rounds) {
  if (rounds.length < 2) return { direction: 'stable', strength: 0 };
  
  const changes = [];
  for (let i = 1; i < rounds.length; i++) {
    changes.push(rounds[i] === rounds[i-1] ? 0 : 1);
  }
  
  const changeRate = changes.reduce((a, b) => a + b, 0) / changes.length;
  return {
    direction: changeRate > 0.6 ? 'volatile' : changeRate > 0.4 ? 'mixed' : 'stable',
    strength: Math.abs(changeRate - 0.5) * 2
  };
}

function updateAccuracyData(actualResult) {
  if (state.lastPrediction && state.lastPrediction !== 'â€”') {
    const isCorrect = state.lastPrediction === actualResult;
    state.predictionsHistory.push({
      prediction: state.lastPrediction,
      actual: actualResult,
      correct: isCorrect,
      model: state.analysisMode
    });
    
    const correctPredictions = state.predictionsHistory.filter(p => p.correct).length;
    const totalPredictions = state.predictionsHistory.length;
    const accuracy = totalPredictions > 0 ? (correctPredictions / totalPredictions) * 100 : 0;
    
    state.accuracyHistory.push(accuracy);
  }
}

// ØªÙ‡ÙŠØ¦Ø© Ø§Ù„ØªØ·Ø¨ÙŠÙ‚ Ø¹Ù†Ø¯ ØªØ­Ù…ÙŠÙ„ Ø§Ù„ØµÙØ­Ø©
window.addEventListener('DOMContentLoaded', init);
</script>
</body>
</html>
