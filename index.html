<!DOCTYPE html>
<html lang="ar">
<head>
  <meta charset="UTF-8" />
  <title>BACCARAT</title>
  <meta name="viewport" content="width=device-width, initial-scale=1.0" />
  <style>
    body {
      background-color: #121212;
      color: gold;
      font-family: 'Segoe UI', Tahoma, sans-serif;
      padding: 2em;
      direction: rtl;
      text-align: center;
      transition: all 0.3s ease;
    }
    body.light-mode {
      background-color: #f5f5f5;
      color: #333;
    }
    h1 { font-size: 2.5em; }
    .buttons button {
      padding: 0.7em 1.5em;
      font-size: 1em;
      margin: 0.5em;
      border: none;
      border-radius: 10px;
      cursor: pointer;
      transition: all 0.3s ease;
    }
    .player { background-color: #007bff; color: white; }
    .banker { background-color: #dc3545; color: white; }
    .tie { background-color: #28a745; color: white; }
    .reset { background-color: #555; color: gold; margin-top: 1em; }
    .language, .amount {
      margin-top: 1em;
      padding: 0.5em;
      font-size: 1em;
      width: 220px;
    }
    .result, .stats, .history, .balance, .ai-stats, .ai-advice {
      margin-top: 1.5em;
      font-size: 1.2em;
      padding: 10px;
      border-radius: 8px;
      background-color: rgba(0,0,0,0.2);
    }
    body.light-mode .result, 
    body.light-mode .stats, 
    body.light-mode .history, 
    body.light-mode .balance, 
    body.light-mode .ai-stats, 
    body.light-mode .ai-advice {
      background-color: rgba(0,0,0,0.05);
    }
    canvas {
      margin-top: 2em;
      max-width: 100%;
    }
    .theme-toggle {
      position: absolute;
      top: 20px;
      left: 20px;
      background: none;
      border: none;
      font-size: 1.5em;
      cursor: pointer;
    }
    .ai-advice {
      border-left: 4px solid gold;
    }
    .probability {
      color: #4CAF50;
      font-weight: bold;
    }
    .hot {
      color: #FF5722;
      font-weight: bold;
    }
    .cold {
      color: #2196F3;
      font-weight: bold;
    }
    /* Ø£Ù†Ù…Ø§Ø· Ø¬Ø¯ÙŠØ¯Ø© */
    .strategy-controls {
      background-color: rgba(0,0,0,0.2);
      padding: 15px;
      border-radius: 8px;
      margin: 15px 0;
    }
    .strategy-controls select, 
    .strategy-controls input {
      width: 100%;
      padding: 8px;
      margin: 5px 0;
      border-radius: 5px;
      border: none;
    }
    .performance-stats {
      background-color: rgba(0,0,0,0.2);
      padding: 15px;
      border-radius: 8px;
      margin: 15px 0;
    }
    .stat-row {
      display: flex;
      justify-content: space-between;
      margin: 5px 0;
    }
    .stat-type {
      font-weight: bold;
      color: gold;
    }
    .stat-value {
      color: white;
    }
    .big-road-container {
      margin-top: 2em;
      padding: 1em;
      background-color: rgba(0, 0, 0, 0.5);
      border-radius: 8px;
      border: 1px solid gold;
      direction: ltr;
    }
    .big-road {
      display: grid;
      grid-auto-flow: column;
      grid-template-rows: repeat(6, 30px);
      gap: 2px;
      padding: 10px;
      overflow-x: auto;
    }
    .big-road-cell {
      width: 30px;
      height: 30px;
      border-radius: 50%;
      display: flex;
      align-items: center;
      justify-content: center;
      font-weight: bold;
      font-size: 14px;
      box-shadow: 0 2px 4px rgba(0, 0, 0, 0.3);
    }
    .big-road-P { background-color: #007bff; color: white; }
    .big-road-B { background-color: #dc3545; color: white; }
    .big-road-T { background-color: #28a745; color: white; }
    .big-road-cell:hover {
      transform: scale(1.1);
      transition: transform 0.2s;
    }
  </style>
</head>
<body>
  <button class="theme-toggle" onclick="toggleTheme()">ğŸŒ“</button>
  <h1>BACCARAT</h1>
  <p>ğŸ“² Ø§Ø®ØªØ± Ù†ØªÙŠØ¬Ø© ÙƒÙ„ Ø¬ÙˆÙ„Ø©:</p>
  <div class="buttons">
    <button class="player" onclick="addResult('P')">ğŸ”µ Ø§Ù„Ù„Ø§Ø¹Ø¨</button>
    <button class="banker" onclick="addResult('B')">ğŸ”´ Ø§Ù„Ù…ØµØ±ÙÙŠ</button>
    <button class="tie" onclick="addResult('T')">ğŸŸ¢ ØªØ¹Ø§Ø¯Ù„</button>
  </div>

  <input type="number" id="betAmount" class="amount" placeholder="ğŸ’° Ù…Ø¨Ù„Øº Ø§Ù„Ø±Ù‡Ø§Ù† Ø¨Ø§Ù„Ø¯Ø±Ù‡Ù…" />
  <br />
  <select id="langSelect" class="language">
    <option value="ar-MA">ğŸ‡²ğŸ‡¦ Ø§Ù„Ø¹Ø±Ø¨ÙŠØ©</option>
    <option value="en-US">ğŸ‡ºğŸ‡¸ English</option>
  </select>

  <div class="strategy-controls">
    <h3>Ø§Ø³ØªØ±Ø§ØªÙŠØ¬ÙŠØ© Ø§Ù„Ø±Ù‡Ø§Ù†</h3>
    <select id="strategySelect" onchange="setStrategy(this.value)">
      <option value="NONE">Ø¨Ø¯ÙˆÙ† Ø§Ø³ØªØ±Ø§ØªÙŠØ¬ÙŠØ©</option>
      <option value="MARTINGALE">Ù…Ø§Ø±ØªÙŠÙ†Ø¬Ø§Ù„</option>
      <option value="FIBONACCI">ÙÙŠØ¨ÙˆÙ†Ø§ØªØ´ÙŠ</option>
    </select>
    <input type="number" id="baseBet" value="10" min="1" 
           onchange="baseBet=parseInt(this.value)">
  </div>

  <div class="result" id="predictionResult"></div>
  <div class="stats" id="statsResult"></div>
  <div class="ai-stats" id="aiStats"></div>
  <div class="ai-advice" id="aiAdvice"></div>
  <div class="history" id="historyDisplay"></div>
  <div class="balance" id="balanceDisplay">ğŸ’µ Ø§Ù„Ø±ØµÙŠØ¯: 0 Ø¯Ø±Ù‡Ù…</div>
  <div class="performance-stats" id="performanceStats"></div>

  <div class="big-road-container">
    <h3>Big Road</h3>
    <div class="big-road" id="bigRoad"></div>
  </div>

  <button class="reset" onclick="resetData()">ğŸ”„ Ø¥Ø¹Ø§Ø¯Ø© ØªØ¹ÙŠÙŠÙ†</button>

  <canvas id="chart" width="400" height="150"></canvas>

  <script src="https://cdn.jsdelivr.net/npm/chart.js"></script>
  <script>
    // Ø§Ù„Ù…ØªØºÙŠØ±Ø§Øª Ø§Ù„Ø¹Ø§Ù…Ø©
    let history = [];
    let balance = 0;
    let balanceHistory = [];
    let currentStreak = { type: null, count: 0 };
    const markovChain = {
        P: { P: 0, B: 0, T: 0 },
        B: { P: 0, B: 0, T: 0 },
        T: { P: 0, B: 0, T: 0 }
    };
    const strategies = {
        NONE: { name: "None", func: (w) => baseBet },
        MARTINGALE: { name: "Martingale", func: (w) => w ? baseBet : currentBet * 2 },
        FIBONACCI: {
            name: "Fibonacci",
            func: (w) => {
                const seq = [1, 1, 2, 3, 5, 8, 13, 21];
                let idx = seq.indexOf(currentBet);
                if (w) return idx <= 1 ? baseBet : seq[idx-2];
                return idx < 0 ? baseBet : (seq[idx+1] || seq[seq.length-1]);
            }
        }
    };
    let currentStrategy = strategies.NONE;
    let baseBet = 10;
    let currentBet = baseBet;

    // ØªÙ‡ÙŠØ¦Ø© Ø§Ù„Ù…Ø®Ø·Ø·
    const ctx = document.getElementById('chart').getContext('2d');
    const chart = new Chart(ctx, {
      type: 'line',
      data: {
        labels: [],
        datasets: [{
          label: 'Ø§Ù„Ø±ØµÙŠØ¯',
          data: [],
          backgroundColor: 'gold',
          borderColor: 'gold',
          fill: false,
        }]
      },
      options: {
        scales: {
          y: { beginAtZero: true }
        }
      }
    });

    // Ø§Ù„Ø¯ÙˆØ§Ù„ Ø§Ù„Ø£Ø³Ø§Ø³ÙŠØ©
    function toggleTheme() {
      document.body.classList.toggle('light-mode');
      const isLight = document.body.classList.contains('light-mode');
      localStorage.setItem('theme', isLight ? 'light' : 'dark');
    }

    function speak(text, lang) {
      const utter = new SpeechSynthesisUtterance(text);
      utter.lang = lang;
      speechSynthesis.speak(utter);
    }

    function updateChart() {
      chart.data.labels = balanceHistory.map((_, i) => i + 1);
      chart.data.datasets[0].data = balanceHistory;
      chart.update();
    }

    // Ø¯Ø§Ù„Ø© ØªØ­Ø¯ÙŠØ« Ø§Ù„Ù…ÙŠØ¬ÙˆØ±Ùƒ
    function updateBigRoad() {
      const bigRoadElement = document.getElementById('bigRoad');
      bigRoadElement.innerHTML = '';
      
      let row = 0;
      let col = 0;
      const maxRows = 6;

      const filteredHistory = history.filter(result => result !== 'T');

      for (let i = 0; i < filteredHistory.length; i++) {
        const result = filteredHistory[i];
        
        if (i > 0 && result === filteredHistory[i - 1]) {
          row++;
          if (row >= maxRows) {
            row = 0;
            col++;
          }
        } else {
          row = 0;
          if (i > 0) col++;
        }

        const cell = document.createElement('div');
        cell.className = `big-road-cell big-road-${result}`;
        cell.textContent = result === 'P' ? 'P' : 'B';
        cell.style.gridColumn = col + 1;
        cell.style.gridRow = row + 1;
        bigRoadElement.appendChild(cell);
      }
    }

    // Ø¯ÙˆØ§Ù„ Ø§Ù„Ø°ÙƒØ§Ø¡ Ø§Ù„Ø§ØµØ·Ù†Ø§Ø¹ÙŠ ÙˆØ§Ù„Ø§Ø³ØªØ±Ø§ØªÙŠØ¬ÙŠØ§Øª
    function updateMarkovChain(result) {
      if (history.length > 0) {
        const prev = history[history.length-1];
        markovChain[prev][result]++;
      }
    }

    function getMarkovPrediction() {
      if (history.length < 2) return null;
      
      const last = history[history.length-1];
      const total = markovChain[last].P + markovChain[last].B + markovChain[last].T;
      
      return {
        P: total ? (markovChain[last].P / total * 100).toFixed(1) : "0",
        B: total ? (markovChain[last].B / total * 100).toFixed(1) : "0", 
        T: total ? (markovChain[last].T / total * 100).toFixed(1) : "0"
      };
    }

    function setStrategy(strategyKey) {
      currentStrategy = strategies[strategyKey] || strategies.NONE;
      currentBet = baseBet;
      const lang = document.getElementById('langSelect').value;
      const strategyName = lang === 'ar-MA' ? 
        (strategyKey === 'MARTINGALE' ? 'Ù…Ø§Ø±ØªÙŠÙ†Ø¬Ø§Ù„' : 
         strategyKey === 'FIBONACCI' ? 'ÙÙŠØ¨ÙˆÙ†Ø§ØªØ´ÙŠ' : 'Ø¨Ø¯ÙˆÙ† Ø§Ø³ØªØ±Ø§ØªÙŠØ¬ÙŠØ©') :
        currentStrategy.name;
      
      document.getElementById('aiAdvice').innerHTML += (lang === 'ar-MA' ? 
        `<div>âœ… ØªÙ… ØªÙØ¹ÙŠÙ„ Ø§Ø³ØªØ±Ø§ØªÙŠØ¬ÙŠØ©: ${strategyName}</div>` :
        `<div>âœ… Strategy activated: ${strategyName}</div>`);
    }

    function calculateNextBet(win) {
      currentBet = currentStrategy.func(win);
      return currentBet;
    }

    // Ø¯ÙˆØ§Ù„ Ø§Ù„Ø£Ø¯Ø§Ø¡ Ø§Ù„Ù…Ø§Ù„ÙŠ
    function calculatePerformance() {
      const stats = {
        P: { bets: 0, wins: 0, profit: 0 },
        B: { bets: 0, wins: 0, profit: 0 },
        T: { bets: 0, wins: 0, profit: 0 },
        overall: { bets: 0, wins: 0, profit: 0 }
      };

      balanceHistory.forEach((bal, i) => {
        if (i === 0) return;
        
        const type = history[i-1];
        const change = bal - balanceHistory[i-1];
        const isWin = change > 0;
        
        stats[type].bets++;
        stats[type].wins += isWin ? 1 : 0;
        stats[type].profit += change;
        
        stats.overall.bets++;
        stats.overall.wins += isWin ? 1 : 0;
        stats.overall.profit += change;
      });

      return stats;
    }

    function updatePerformanceDisplay() {
      const stats = calculatePerformance();
      const lang = document.getElementById('langSelect').value;
      
      let html = lang === 'ar-MA' ? 
        '<h3>Ø¥Ø­ØµØ§Ø¦ÙŠØ§Øª Ø§Ù„Ø£Ø¯Ø§Ø¡</h3>' : 
        '<h3>Performance Statistics</h3>';
      
      ['P', 'B', 'T'].forEach(type => {
        const typeName = lang === 'ar-MA' ? 
          (type === 'P' ? 'Ù„Ø§Ø¹Ø¨' : type === 'B' ? 'Ù…ØµØ±ÙÙŠ' : 'ØªØ¹Ø§Ø¯Ù„') :
          (type === 'P' ? 'Player' : type === 'B' ? 'Banker' : 'Tie');
        
        const winRate = stats[type].bets ? 
          (stats[type].wins / stats[type].bets * 100).toFixed(1) : 0;
        
        html += `
          <div class="stat-row">
            <span class="stat-type">${type === 'P' ? 'ğŸ”µ' : type === 'B' ? 'ğŸ”´' : 'ğŸŸ¢'} ${typeName}:</span>
            <span class="stat-value">${stats[type].bets} ${lang === 'ar-MA' ? 'Ø±Ù‡Ø§Ù†' : 'bets'}</span>
            <span class="stat-value">${winRate}% ${lang === 'ar-MA' ? 'ÙÙˆØ²' : 'win'}</span>
            <span class="stat-value">${stats[type].profit} ${lang === 'ar-MA' ? 'Ø¯Ø±Ù‡Ù…' : 'MAD'}</span>
          </div>
        `;
      });
      
      document.getElementById('performanceStats').innerHTML = html;
    }

    // Ø§Ù„Ø¯ÙˆØ§Ù„ Ø§Ù„Ø±Ø¦ÙŠØ³ÙŠØ©
    function addResult(result) {
      if (currentStreak.type === result) {
        currentStreak.count++;
      } else {
        currentStreak.type = result;
        currentStreak.count = 1;
      }
      
      history.push(result);
      updateMarkovChain(result);
      updateDisplay();
      updateBigRoad();
      predict(result);
      generateAdvice();
      updatePerformanceDisplay();
    }

    function updateDisplay() {
      const displayText = history.map(r => {
        if (r === 'P') return 'ğŸ”µ';
        if (r === 'B') return 'ğŸ”´';
        if (r === 'T') return 'ğŸŸ¢';
      }).join(' ');
      document.getElementById('historyDisplay').innerText = "Ø¬Ù…ÙŠØ¹ Ø§Ù„Ø¬ÙˆÙ„Ø§Øª: " + displayText;

      const totalRounds = history.length;
      const count = { P: 0, B: 0, T: 0 };
      history.forEach(r => { if (count[r] !== undefined) count[r]++; });

      const statsText = `ğŸ“Š Ø¹Ø¯Ø¯ Ø§Ù„Ø¬ÙˆÙ„Ø§Øª: ${totalRounds} | ğŸ”µ Ù„Ø§Ø¹Ø¨: ${count.P} (${((count.P/totalRounds)*100).toFixed(1)}%) | ğŸ”´ Ù…ØµØ±ÙÙŠ: ${count.B} (${((count.B/totalRounds)*100).toFixed(1)}%) | ğŸŸ¢ ØªØ¹Ø§Ø¯Ù„: ${count.T} (${((count.T/totalRounds)*100).toFixed(1)}%)`;
      document.getElementById('aiStats').innerText = statsText;
    }

    function generateAdvice() {
      const lang = document.getElementById('langSelect').value;
      const isArabic = lang === 'ar-MA';
      
      if (history.length < 3) {
        document.getElementById('aiAdvice').innerHTML = isArabic ? 
          "â³ Ø§Ù†ØªØ¸Ø± Ø§Ù„Ù…Ø²ÙŠØ¯ Ù…Ù† Ø§Ù„Ø¬ÙˆÙ„Ø§Øª Ù„ØªØ­Ù„ÙŠÙ„ Ø§Ù„Ø£Ù†Ù…Ø§Ø·..." : 
          "â³ Wait for more rounds to analyze patterns...";
        return;
      }

      const lastTen = history.slice(-10);
      const counts = { P: 0, B: 0, T: 0 };
      lastTen.forEach(r => counts[r]++);
      
      const mostFrequent = Object.keys(counts).reduce((a, b) => counts[a] > counts[b] ? a : b);
      const freqPercent = (counts[mostFrequent] / lastTen.length * 100).toFixed(1);
      
      let streakText = "";
      if (currentStreak.count > 2) {
        const typeName = isArabic ? 
          (currentStreak.type === 'P' ? 'Ø§Ù„Ù„Ø§Ø¹Ø¨' : currentStreak.type === 'B' ? 'Ø§Ù„Ù…ØµØ±ÙÙŠ' : 'ØªØ¹Ø§Ø¯Ù„') :
          (currentStreak.type === 'P' ? 'Player' : currentStreak.type === 'B' ? 'Banker' : 'Tie');
        
        streakText = isArabic ?
          `ğŸ“ˆ Ø³Ù„Ø³Ù„Ø© ${typeName} Ù…Ø³ØªÙ…Ø±Ø©: ${currentStreak.count} Ø¬ÙˆÙ„Ø§Øª` :
          `ğŸ“ˆ ${typeName} streak: ${currentStreak.count} rounds`;
      }

      let hotColdText = "";
      if (history.length >= 3) {
        const hotCold = { P: 0, B: 0, T: 0 };
        history.forEach(r => hotCold[r]++);
        
        hotColdText = isArabic ? "ğŸ”¥ Ø§Ù„Ù†ØªØ§Ø¦Ø¬ Ø§Ù„Ø³Ø§Ø®Ù†Ø© (Ø¬Ù…ÙŠØ¹ Ø§Ù„Ø¬ÙˆÙ„Ø§Øª): " : "ğŸ”¥ Hot (all rounds): ";
        Object.keys(hotCold).forEach(key => {
          const typeName = isArabic ? 
            (key === 'P' ? 'Ù„Ø§Ø¹Ø¨' : key === 'B' ? 'Ù…ØµØ±ÙÙŠ' : 'ØªØ¹Ø§Ø¯Ù„') :
            (key === 'P' ? 'Player' : key === 'B' ? 'Banker' : 'Tie');
          
          const percentage = (hotCold[key] / history.length * 100);
          hotColdText += `<span class="${percentage > 35 ? 'hot' : 'cold'}">${typeName} ${hotCold[key]} (${percentage.toFixed(1)}%)</span> `;
        });
      }

      let recommendation = "";
      if (currentStreak.count >= 3) {
        recommendation = isArabic ?
          `ğŸ’¡ Ø§Ø³ØªÙ…Ø± ÙÙŠ Ø§Ù„Ø±Ù‡Ø§Ù† Ø¹Ù„Ù‰ ${currentStreak.type === 'P' ? 'Ø§Ù„Ù„Ø§Ø¹Ø¨' : currentStreak.type === 'B' ? 'Ø§Ù„Ù…ØµØ±ÙÙŠ' : 'ØªØ¹Ø§Ø¯Ù„'}` :
          `ğŸ’¡ Keep betting on ${currentStreak.type === 'P' ? 'Player' : currentStreak.type === 'B' ? 'Banker' : 'Tie'}`;
      } else if (parseFloat(freqPercent) > 50) {
        const typeName = isArabic ?
          (mostFrequent === 'P' ? 'Ø§Ù„Ù„Ø§Ø¹Ø¨' : mostFrequent === 'B' ? 'Ø§Ù„Ù…ØµØ±ÙÙŠ' : 'ØªØ¹Ø§Ø¯Ù„') :
          (mostFrequent === 'P' ? 'Player' : mostFrequent === 'B' ? 'Banker' : 'Tie');
        
        recommendation = isArabic ?
          `ğŸ’¡ Ø±Ù‡Ø§Ù† Ø¢Ù…Ù† Ø¹Ù„Ù‰ ${typeName} (${freqPercent}%)` :
          `ğŸ’¡ Safe bet on ${typeName} (${freqPercent}%)`;
      } else {
        recommendation = isArabic ?
          "ğŸ’¡ Ù„Ø§ ÙŠÙˆØ¬Ø¯ Ù†Ù…Ø· ÙˆØ§Ø¶Ø­ØŒ Ø§Ø³ØªØ®Ø¯Ù… Ø§Ø³ØªØ±Ø§ØªÙŠØ¬ÙŠØ© Ù…ØªØ­ÙØ¸Ø©" :
          "ğŸ’¡ No clear pattern, use conservative strategy";
      }

      document.getElementById('aiAdvice').innerHTML = `
        ${streakText ? `<div>${streakText}</div>` : ''}
        ${hotColdText ? `<div>${hotColdText}</div>` : ''}
        <div class="probability">${recommendation}</div>
      `;
    }

    function predict(actualResult) {
      const markovPrediction = getMarkovPrediction();
      const lang = document.getElementById('langSelect').value;
      const lastFive = history.slice(-5);
      const count = { P: 0, B: 0, T: 0 };
      lastFive.forEach(r => { if (count[r] !== undefined) count[r]++; });

      const total = lastFive.length || 1;
      const percent = {
        P: ((count.P / total) * 100).toFixed(1),
        B: ((count.B / total) * 100).toFixed(1),
        T: ((count.T / total) * 100).toFixed(1)
      };

      let winner = 'P';
      if (count.B >= count.P && count.B >= count.T) winner = 'B';
      else if (count.T > count.P && count.T > count.B) winner = 'T';

      const labels = {
        ar: { P: 'Ø§Ù„Ù„Ø§Ø¹Ø¨', B: 'Ø§Ù„Ù…ØµØ±ÙÙŠ', T: 'ØªØ¹Ø§Ø¯Ù„' },
        en: { P: 'Player', B: 'Banker', T: 'Tie' }
      };

      const label = lang === 'ar-MA' ? labels.ar[winner] : labels.en[winner];
      let speechText = lang === 'ar-MA'
        ? `ØªÙˆÙ‚Ø¹ Ø§Ù„Ø¬ÙˆÙ„Ø© Ø§Ù„Ù‚Ø§Ø¯Ù…Ø©: ${label} Ø¨Ù†Ø³Ø¨Ø© ${percent[winner]} Ø¨Ø§Ù„Ù…Ø¦Ø©`
        : `Next round prediction: ${label} with ${percent[winner]} percent`;

      if (markovPrediction) {
        speechText += lang === 'ar-MA' ?
          ` | ØªÙ†Ø¨Ø¤ Ù…Ø§Ø±ÙƒÙˆÙ: ${markovPrediction[winner]}%` :
          ` | Markov prediction: ${markovPrediction[winner]}%`;
      }

      document.getElementById('predictionResult').innerText = speechText;
      document.getElementById('statsResult').innerHTML =
        `ğŸ”µ Ù„Ø§Ø¹Ø¨: <span class="probability">${percent.P}%</span> | ğŸ”´ Ù…ØµØ±ÙÙŠ: <span class="probability">${percent.B}%</span> | ğŸŸ¢ ØªØ¹Ø§Ø¯Ù„: <span class="probability">${percent.T}%</span>`;

      speak(speechText, lang);

      const bet = calculateNextBet(actualResult === winner);
      document.getElementById('betAmount').value = bet;
      
      if (actualResult && winner && bet > 0) {
        if (actualResult === winner) {
          balance += bet;
        } else {
          balance -= bet;
        }
        balanceHistory.push(balance);
        updateChart();
        document.getElementById('balanceDisplay').innerText = `ğŸ’µ Ø§Ù„Ø±ØµÙŠØ¯: ${balance} Ø¯Ø±Ù‡Ù…`;
      }
    }

    function resetData() {
      history = [];
      balance = 0;
      balanceHistory = [];
      currentStreak = { type: null, count: 0 };
      
      // Reset Markov Chain
      for (const key in markovChain) {
        markovChain[key] = { P: 0, B: 0, T: 0 };
      }
      
      // Reset betting strategy
      currentStrategy = strategies.NONE;
      currentBet = baseBet;
      
      updateChart();
      updateBigRoad();
      updatePerformanceDisplay();
      document.getElementById('predictionResult').innerText = '';
      document.getElementById('statsResult').innerText = '';
      document.getElementById('aiStats').innerText = '';
      document.getElementById('aiAdvice').innerText = '';
      document.getElementById('historyDisplay').innerText = '';
      document.getElementById('balanceDisplay').innerText = 'ğŸ’µ Ø§Ù„Ø±ØµÙŠØ¯: 0 Ø¯Ø±Ù‡Ù…';
      document.getElementById('performanceStats').innerHTML = '';
    }

    // ØªØ­Ù…ÙŠÙ„ Ø§Ù„ÙˆØ¶Ø¹ Ù…Ù† localStorage Ø¥Ø°Ø§ ÙƒØ§Ù† Ù…ÙˆØ¬ÙˆØ¯Ø§Ù‹
    if (localStorage.getItem('theme') === 'light') {
      document.body.classList.add('light-mode');
    }
  </script>
</body>
                                                </html>
