<!doctype html>
<html lang="ar">
<head>
<meta charset="utf-8">
<meta name="viewport" content="width=device-width,initial-scale=1">
<title>AYOUB BACCARAT PRO - IMPROVED</title>
<style>
/* Ù†ÙØ³ Ø§Ù„Ø£Ù†Ù…Ø§Ø· Ø§Ù„Ø³Ø§Ø¨Ù‚Ø© Ù…Ø¹ Ø¥Ø¶Ø§ÙØ§Øª */
.improvement-panel { margin-top: 15px; padding: 12px; background: rgba(212,175,55,0.05); border-radius: 8px; border-left: 4px solid var(--gold); }
.confidence-meter { display: flex; align-items: center; gap: 10px; margin: 8px 0; }
.confidence-bar { flex: 1; height: 8px; background: rgba(255,255,255,0.1); border-radius: 4px; overflow: hidden; }
.confidence-fill { height: 100%; background: linear-gradient(90deg, #ff006e, #ff8c00, #38b000); border-radius: 4px; transition: width 0.5s; }
.confidence-text { font-size: 12px; font-weight: 600; }
.risk-indicator { padding: 6px 10px; border-radius: 6px; font-size: 12px; font-weight: 600; text-align: center; margin-top: 5px; }
.risk-low { background: rgba(56, 176, 0, 0.2); color: #38b000; border: 1px solid #38b000; }
.risk-medium { background: rgba(255, 140, 0, 0.2); color: #ff8c00; border: 1px solid #ff8c00; }
.risk-high { background: rgba(255, 0, 110, 0.2); color: #ff006e; border: 1px solid #ff006e; }
.suggestion-box { background: rgba(59, 130, 246, 0.1); padding: 10px; border-radius: 8px; margin-top: 10px; border: 1px solid #3b82f6; }
.suggestion-title { font-weight: 600; color: #3b82f6; margin-bottom: 5px; }
.adaptive-controls { display: flex; gap: 10px; margin-top: 10px; }
.adaptive-btn { padding: 8px 12px; border-radius: 6px; border: none; font-size: 12px; font-weight: 600; cursor: pointer; transition: all 0.3s; }
.adaptive-btn.auto { background: rgba(56, 176, 0, 0.2); color: #38b000; border: 1px solid #38b000; }
.adaptive-btn.manual { background: rgba(59, 130, 246, 0.2); color: #3b82f6; border: 1px solid #3b82f6; }
.adaptive-btn:hover { transform: translateY(-2px); }
</style>
</head>
<body>
<div class="app">
<header class="top card">
  <div class="brand">
    <div class="logo">AYOUB BACCARAT PRO - IMPROVED</div>
    <div class="subtitle">Ù†Ø¸Ø§Ù… Ù…ØªÙƒÙŠÙ Ø°ÙƒÙŠ ÙŠØªØ¹Ù„Ù… Ù…Ù† Ø§Ù„Ø£Ø®Ø·Ø§Ø¡ ğŸ§ ğŸ“ˆ</div>
  </div>
  <div class="controls">
    <button id="themeToggle" class="theme-toggle">ğŸŒš</button>
    <button id="btnReset" class="btn gold">Ø¥Ø¹Ø§Ø¯Ø© ØªØ¹ÙŠÙŠÙ†</button>
  </div>
</header>

<main class="card layout">
<aside class="left">
  <!-- Ù†ÙØ³ Ø§Ù„Ù…Ø­ØªÙˆÙ‰ Ø§Ù„Ø³Ø§Ø¨Ù‚ -->
  <div class="panel card">
    <label class="input-label">Ù†Ø§ÙØ°Ø© Ø§Ù„ØªØ­Ù„ÙŠÙ„ Ø§Ù„Ø°ÙƒÙŠØ© (3 - 15)</label>
    <div class="input-group">
      <input id="windowSize" type="number" min="3" max="15" value="7">
      <button id="applyWindow" class="btn gold">ØªØ·Ø¨ÙŠÙ‚</button>
    </div>
    <div class="muted small">ÙŠØªÙƒÙŠÙ ØªÙ„Ù‚Ø§Ø¦ÙŠØ§Ù‹ Ù…Ø¹ Ø§Ø³ØªÙ‚Ø±Ø§Ø± Ø§Ù„Ø£Ù†Ù…Ø§Ø·</div>
    
    <div class="adaptive-controls">
      <button id="btnAutoAdjust" class="adaptive-btn auto">ØªÙƒÙŠÙ ØªÙ„Ù‚Ø§Ø¦ÙŠ</button>
      <button id="btnManualMode" class="adaptive-btn manual">ÙˆØ¶Ø¹ ÙŠØ¯ÙˆÙŠ</button>
    </div>
  </div>

  <div class="panel card">
    <div class="section-title">Ø¥Ø¯Ø®Ø§Ù„ Ø§Ù„Ù†ØªØ§Ø¦Ø¬</div>
    <div class="row">
      <button class="btn player" id="btnP">Ù„Ø§Ø¹Ø¨ ğŸ”µ</button>
      <button class="btn banker" id="btnB">Ù…ØµØ±ÙÙŠ ğŸ”´</button>
      <button class="btn tie" id="btnT">ØªØ¹Ø§Ø¯Ù„ ğŸŸ¢</button>
    </div>
    <div class="row">
      <button class="btn" id="btnUndo" style="flex:1; background:rgba(255,255,255,0.1); border:1px solid rgba(255,255,255,0.2)">ØªØ±Ø§Ø¬Ø¹</button>
    </div>
  </div>

  <div class="panel card patterns">
    <div class="section-title">Ø§Ù„Ø£Ù†Ù…Ø§Ø· Ø§Ù„Ù…ØªÙ‚Ø¯Ù…Ø©</div>
    <ul id="patternList" class="pattern-list">
      <li>ØªØªØ§Ø¨Ø¹: 0</li>
      <li>ØªØ¨Ø§Ø¯Ù„: 0</li>
      <li>Ø§Ø²Ø¯ÙˆØ§Ø¬: 0</li>
      <li>Ø§Ø³ØªÙ‚Ø±Ø§Ø±: 0%</li>
    </ul>
  </div>

  <div class="panel card stats">
    <div class="section-title">Ø§Ù„Ø¥Ø­ØµØ§Ø¡Ø§Øª Ø§Ù„Ø°ÙƒÙŠØ©</div>
    <table class="stat-table">
      <thead>
        <tr><th>Ø§Ù„Ø¬Ù‡Ø©</th><th>Ø§Ù„Ù…Ø¬Ù…ÙˆØ¹</th><th>ÙÙˆØ²</th><th>Ø®Ø³Ø§Ø±Ø©</th><th>Ù†Ø³Ø¨Ø© %</th><th>Ø«Ù‚Ø©</th></tr>
      </thead>
      <tbody>
        <tr><td class="player">Ù„Ø§Ø¹Ø¨</td><td id="pTotal">0</td><td id="pWin">0</td><td id="pLoss">0</td><td id="pPct">0%</td><td id="pConf">-</td></tr>
        <tr><td class="banker">Ù…ØµØ±ÙÙŠ</td><td id="bTotal">0</td><td id="bWin">0</td><td id="bLoss">0</td><td id="bPct">0%</td><td id="bConf">-</td></tr>
        <tr><td class="tie">ØªØ¹Ø§Ø¯Ù„</td><td id="tTotal">0</td><td id="tWin">0</td><td id="tLoss">0</td><td id="tPct">0%</td><td id="tConf">-</td></tr>
      </tbody>
    </table>
  </div>
</aside>

<section class="right card prediction">
  <div class="pred-head">
    <div class="pred-title">Ø§Ù„ØªÙˆÙ‚Ø¹ Ø§Ù„Ø°ÙƒÙŠ Ù„Ù„Ø¬ÙˆÙ„Ø© Ø§Ù„Ù‚Ø§Ø¯Ù…Ø©</div>
    <div class="pred-sub">Ù†Ø¸Ø§Ù… Ù…ØªÙƒÙŠÙ ÙŠØªØ¹Ù„Ù… Ù…Ù† Ø§Ù„Ø£Ù†Ù…Ø§Ø· Ø§Ù„Ø³Ø§Ø¨Ù‚Ø©</div>
  </div>

  <div class="color-legend">
    <span style="background:linear-gradient(135deg, #3a86ff, #2667cc);">ğŸ”µ Ù„Ø§Ø¹Ø¨</span>
    <span style="background:linear-gradient(135deg, #ff006e, #cc0058);">ğŸ”´ Ù…ØµØ±ÙÙŠ</span>
    <span style="background:linear-gradient(135deg, #38b000, #2c8a00);">ğŸŸ¢ ØªØ¹Ø§Ø¯Ù„</span>
  </div>
  
  <canvas id="bigRoad" width="600" height="450"></canvas>

  <div class="prediction-cards">
    <div class="pred-card player" id="predP">
      <div>Ù„Ø§Ø¹Ø¨</div>
      <div id="predPctP">0%</div>
      <div class="confidence-text" id="predConfP">Ø«Ù‚Ø©: -</div>
    </div>
    <div class="pred-card banker" id="predB">
      <div>Ù…ØµØ±ÙÙŠ</div>
      <div id="predPctB">0%</div>
      <div class="confidence-text" id="predConfB">Ø«Ù‚Ø©: -</div>
    </div>
    <div class="pred-card tie" id="predT">
      <div>ØªØ¹Ø§Ø¯Ù„</div>
      <div id="predPctT">0%</div>
      <div class="confidence-text" id="predConfT">Ø«Ù‚Ø©: -</div>
    </div>
  </div>

  <div class="analysis-result">
    <div class="muted">Ø§Ù„ØªÙˆÙ‚Ø¹ Ø§Ù„Ø­Ø§Ù„ÙŠ:</div>
    <div class="final" id="finalCard">â€”</div>
    <div class="confidence-meter">
      <span class="muted">Ù…Ø³ØªÙˆÙ‰ Ø§Ù„Ø«Ù‚Ø©:</span>
      <div class="confidence-bar">
        <div class="confidence-fill" id="confidenceFill" style="width: 0%"></div>
      </div>
      <span class="confidence-text" id="confidenceText">0%</span>
    </div>
    <div id="riskIndicator" class="risk-indicator risk-low">Ù…Ø®Ø§Ø·Ø±Ø© Ù…Ù†Ø®ÙØ¶Ø©</div>
  </div>

  <!-- Ù„ÙˆØ­Ø© Ø§Ù„ØªØ­Ø³ÙŠÙ†Ø§Øª -->
  <div class="improvement-panel">
    <div class="section-title">Ù†Ø¸Ø§Ù… Ø§Ù„ØªØ¹Ù„Ù… Ù…Ù† Ø§Ù„Ø£Ø®Ø·Ø§Ø¡</div>
    <div class="suggestion-box">
      <div class="suggestion-title">ğŸ’¡ Ø§Ù‚ØªØ±Ø§Ø­ Ø°ÙƒÙŠ:</div>
      <div id="aiSuggestion">Ø£Ø¯Ø®Ù„ Ø§Ù„Ù…Ø²ÙŠØ¯ Ù…Ù† Ø§Ù„Ø¨ÙŠØ§Ù†Ø§Øª Ù„ØªØ­Ø³ÙŠÙ† Ø§Ù„ØªÙˆÙ‚Ø¹Ø§Øª</div>
    </div>
    <div class="row">
      <div class="muted small">Ù…Ø¹Ø¯Ù„ Ø§Ù„ØªØ¹Ù„Ù…:</div>
      <div class="muted small" id="learningRate">0%</div>
    </div>
    <div class="row">
      <div class="muted small">Ù†Ù…Ø· Ø§Ù„Ø£Ø®Ø·Ø§Ø¡:</div>
      <div class="muted small" id="mistakePattern">ØºÙŠØ± Ù…Ø­Ø¯Ø¯</div>
    </div>
  </div>

  <!-- Ø¨Ø§Ù‚ÙŠ Ø§Ù„Ù…ÙƒÙˆÙ†Ø§Øª -->
</section>
</main>
</div>

<script>
// State Ù…Ø¹ ØªØ­Ø³ÙŠÙ†Ø§Øª
const state = {
  rounds: [],
  windowSize: 7,
  adaptiveWindow: true,
  count: { P: 0, B: 0, T: 0 },
  win: { P: 0, B: 0, T: 0 },
  loss: { P: 0, B: 0, T: 0 },
  lastPrediction: null,
  patterns: {
    ØªØªØ§Ø¨Ø¹: 0,
    ØªØ¨Ø§Ø¯Ù„: 0,
    Ø§Ø²Ø¯ÙˆØ§Ø¬: 0,
    Ø§Ø³ØªÙ‚Ø±Ø§Ø±: 0
  },
  accuracyHistory: [],
  predictionsHistory: [],
  bigRoadData: [],
  // Ø¨ÙŠØ§Ù†Ø§Øª Ø§Ù„ØªØ¹Ù„Ù…
  learningData: {
    mistakePatterns: [],
    successRates: {},
    adaptiveWeights: { frequency: 0.4, pattern: 0.3, streak: 0.2, external: 0.1 },
    confidenceThresholds: { low: 45, medium: 60, high: 75 }
  }
};

// ØªØ­Ø³ÙŠÙ† Ø¯Ø§Ù„Ø© Ø§Ù„ØªÙ†Ø¨Ø¤ Ø§Ù„Ø±Ø¦ÙŠØ³ÙŠØ©
function improvedPredict() {
  const n = getOptimalWindowSize();
  const recent = state.rounds.slice(-n);
  
  if (recent.length < 3) {
    return { 
      P: 33.3, B: 33.3, T: 33.3, 
      final: 'â€”',
      confidence: 0,
      method: 'ØºÙŠØ± ÙƒØ§ÙÙ'
    };
  }

  // ØªØ­Ù„ÙŠÙ„ Ù…ØªØ¹Ø¯Ø¯ Ø§Ù„Ù…Ø³ØªÙˆÙŠØ§Øª
  const analyses = {
    frequency: analyzeFrequency(recent),
    pattern: analyzePattern(recent),
    streak: analyzeStreak(recent),
    beadRoad: analyzeBeadRoad(),
    historical: analyzeHistoricalPatterns()
  };

  // Ø¯Ù…Ø¬ Ø§Ù„ØªØ­Ù„ÙŠÙ„Ø§Øª Ø¨ÙˆØ²Ù† ØªÙƒÙŠÙÙŠ
  const merged = mergeAnalyses(analyses);
  const confidence = calculateOverallConfidence(merged, analyses);
  
  // ØªØ­Ø¯ÙŠØ¯ Ø§Ù„ØªÙˆÙ‚Ø¹ Ø§Ù„Ù†Ù‡Ø§Ø¦ÙŠ Ù…Ø¹ Ù…Ø±Ø§Ø¹Ø§Ø© Ø§Ù„Ø«Ù‚Ø©
  let final = determineFinalPrediction(merged, confidence);
  
  return {
    P: merged.P.toFixed(1),
    B: merged.B.toFixed(1),
    T: merged.T.toFixed(1),
    final,
    confidence,
    method: getPredictionMethod(analyses)
  };
}

// ØªØ­Ù„ÙŠÙ„ Ø§Ù„ØªÙƒØ±Ø§Ø±
function analyzeFrequency(recent) {
  const counts = { P: 0, B: 0, T: 0 };
  recent.forEach(x => counts[x]++);
  
  const total = recent.length;
  return {
    P: (counts.P / total) * 100,
    B: (counts.B / total) * 100,
    T: (counts.T / total) * 100
  };
}

// ØªØ­Ù„ÙŠÙ„ Ø§Ù„Ø£Ù†Ù…Ø§Ø· Ø§Ù„Ù…ØªÙ‚Ø¯Ù…Ø©
function analyzePattern(recent) {
  const weights = { P: 1, B: 1, T: 1 };
  const lastRound = recent[recent.length - 1];
  
  // ØªØ­Ù„ÙŠÙ„ Ø§Ù„ØªØªØ§Ø¨Ø¹
  const streak = calculateStreak(recent);
  if (streak.length >= 2) {
    weights[streak.type] *= (1 + (streak.length * 0.1));
  }
  
  // ØªØ­Ù„ÙŠÙ„ Ø§Ù„ØªØ¨Ø§Ø¯Ù„
  const pingPong = analyzePingPong(recent);
  if (pingPong.strength > 0.6) {
    weights[pingPong.expected] *= 1.3;
  }
  
  // ØªØ·Ø¨ÙŠÙ‚ Ø§Ù„Ø£ÙˆØ²Ø§Ù†
  const baseFreq = analyzeFrequency(recent);
  return {
    P: baseFreq.P * weights.P,
    B: baseFreq.B * weights.B,
    T: baseFreq.T * weights.T
  };
}

// ØªØ­Ù„ÙŠÙ„ Ø§Ù„ØªØªØ§Ø¨Ø¹
function analyzeStreak(recent) {
  let currentStreak = 1;
  let streakType = recent[recent.length - 1];
  
  for (let i = recent.length - 2; i >= 0; i--) {
    if (recent[i] === streakType) {
      currentStreak++;
    } else {
      break;
    }
  }
  
  return {
    length: currentStreak,
    type: streakType,
    strength: Math.min(currentStreak / 5, 1)
  };
}

// Ø¯Ù…Ø¬ Ø§Ù„ØªØ­Ù„ÙŠÙ„Ø§Øª
function mergeAnalyses(analyses) {
  const weights = state.learningData.adaptiveWeights;
  const result = { P: 0, B: 0, T: 0 };
  
  // ØªØ·Ø¨ÙŠÙ‚ Ø§Ù„Ø£ÙˆØ²Ø§Ù† Ø¹Ù„Ù‰ ÙƒÙ„ ØªØ­Ù„ÙŠÙ„
  for (const [method, analysis] of Object.entries(analyses)) {
    const weight = weights[method] || 0.2;
    result.P += analysis.P * weight;
    result.B += analysis.B * weight;
    result.T += analysis.T * weight;
  }
  
  // ØªØ·Ø¨ÙŠØ¹ Ø§Ù„Ù†ØªØ§Ø¦Ø¬
  const sum = result.P + result.B + result.T;
  if (sum > 0) {
    result.P = (result.P / sum) * 100;
    result.B = (result.B / sum) * 100;
    result.T = (result.T / sum) * 100;
  }
  
  return result;
}

// Ø­Ø³Ø§Ø¨ Ø§Ù„Ø«Ù‚Ø© Ø§Ù„Ø´Ø§Ù…Ù„Ø©
function calculateOverallConfidence(merged, analyses) {
  const maxProb = Math.max(merged.P, merged.B, merged.T);
  const secondMax = Object.values(merged).sort((a, b) => b - a)[1];
  const gap = maxProb - secondMax;
  
  // Ø¹ÙˆØ§Ù…Ù„ Ø§Ù„Ø«Ù‚Ø©
  const dataConfidence = Math.min(state.rounds.length / 20, 1);
  const patternStability = calculatePatternStability();
  const gapConfidence = Math.min(gap / 30, 1);
  
  return (dataConfidence * 0.4 + patternStability * 0.3 + gapConfidence * 0.3) * 100;
}

// ØªØ­Ø¯ÙŠØ¯ Ø§Ù„Ø­Ø¬Ù… Ø§Ù„Ø£Ù…Ø«Ù„ Ù„Ù„Ù†Ø§ÙØ°Ø©
function getOptimalWindowSize() {
  if (!state.adaptiveWindow) return state.windowSize;
  
  const dataLength = state.rounds.length;
  if (dataLength < 10) return Math.max(3, Math.floor(dataLength / 2));
  if (dataLength < 20) return 7;
  if (dataLength < 30) return 10;
  return 12;
}

// Ù†Ø¸Ø§Ù… Ø§Ù„ØªØ¹Ù„Ù… Ù…Ù† Ø§Ù„Ø£Ø®Ø·Ø§Ø¡
function learnFromMistakes() {
  if (state.predictionsHistory.length < 3) return;
  
  const recentPredictions = state.predictionsHistory.slice(-10);
  const mistakeRate = recentPredictions.filter(p => !p.correct).length / recentPredictions.length;
  
  // ØªØ­Ù„ÙŠÙ„ Ø£Ù†Ù…Ø§Ø· Ø§Ù„Ø£Ø®Ø·Ø§Ø¡
  const mistakePatterns = analyzeMistakePatterns(recentPredictions);
  
  // ØªØ¹Ø¯ÙŠÙ„ Ø§Ù„Ø£ÙˆØ²Ø§Ù†
  adjustWeightsBasedOnPerformance(mistakeRate, mistakePatterns);
  
  // ØªØ­Ø¯ÙŠØ« Ø¹ØªØ¨Ø§Øª Ø§Ù„Ø«Ù‚Ø©
  updateConfidenceThresholds(mistakeRate);
  
  return {
    mistakeRate: (mistakeRate * 100).toFixed(1),
    pattern: getMistakePatternDescription(mistakePatterns),
    learningRate: calculateLearningRate()
  };
}

// ØªØ­Ø¯ÙŠØ« ÙˆØ§Ø¬Ù‡Ø© Ø§Ù„Ù…Ø³ØªØ®Ø¯Ù… Ø§Ù„Ù…Ø­Ø³Ù†Ø©
function updateImprovedUI(prediction, learningData) {
  // ØªØ­Ø¯ÙŠØ« Ø§Ù„Ù†Ø³Ø¨ Ø§Ù„Ù…Ø¦ÙˆÙŠØ©
  el('predPctP').textContent = prediction.P + '%';
  el('predPctB').textContent = prediction.B + '%';
  el('predPctT').textContent = prediction.T + '%';
  
  // ØªØ­Ø¯ÙŠØ« Ù…Ø³ØªÙˆÙŠØ§Øª Ø§Ù„Ø«Ù‚Ø©
  updateConfidenceDisplays(prediction);
  
  // ØªØ­Ø¯ÙŠØ« Ø´Ø±ÙŠØ· Ø§Ù„Ø«Ù‚Ø©
  const confidenceFill = el('confidenceFill');
  const confidenceText = el('confidenceText');
  confidenceFill.style.width = prediction.confidence + '%';
  confidenceText.textContent = prediction.confidence.toFixed(1) + '%';
  
  // ØªØ­Ø¯ÙŠØ« Ù…Ø¤Ø´Ø± Ø§Ù„Ù…Ø®Ø§Ø·Ø±Ø©
  updateRiskIndicator(prediction.confidence);
  
  // ØªØ­Ø¯ÙŠØ« Ø§Ù‚ØªØ±Ø§Ø­Ø§Øª Ø§Ù„Ø°ÙƒØ§Ø¡ Ø§Ù„Ø§ØµØ·Ù†Ø§Ø¹ÙŠ
  updateAISuggestions(learningData);
}

// ØªØ­Ø¯ÙŠØ« Ù…Ø¤Ø´Ø± Ø§Ù„Ù…Ø®Ø§Ø·Ø±Ø©
function updateRiskIndicator(confidence) {
  const indicator = el('riskIndicator');
  indicator.className = 'risk-indicator ';
  
  if (confidence >= 70) {
    indicator.classList.add('risk-low');
    indicator.textContent = 'Ù…Ø®Ø§Ø·Ø±Ø© Ù…Ù†Ø®ÙØ¶Ø©';
  } else if (confidence >= 50) {
    indicator.classList.add('risk-medium');
    indicator.textContent = 'Ù…Ø®Ø§Ø·Ø±Ø© Ù…ØªÙˆØ³Ø·Ø©';
  } else {
    indicator.classList.add('risk-high');
    indicator.textContent = 'Ù…Ø®Ø§Ø·Ø±Ø© Ø¹Ø§Ù„ÙŠØ©';
  }
}

// Ø¨Ø§Ù‚ÙŠ Ø§Ù„Ø¯ÙˆØ§Ù„ Ø§Ù„Ø£Ø³Ø§Ø³ÙŠØ© ØªØ¨Ù‚Ù‰ ÙƒÙ…Ø§ Ù‡ÙŠ Ù…Ø¹ Ø§Ù„ØªÙƒÙŠÙ
function pushRound(r) {
  const pred = improvedPredict();
  state.lastPrediction = pred.final;
  
  state.rounds.push(r);
  state.count[r]++;
  updatePatterns();
  
  if (state.lastPrediction !== 'â€”' && state.lastPrediction !== null) {
    const didWin = (r === state.lastPrediction);
    
    if (didWin) {
      state.win[state.lastPrediction]++;
    } else {
      state.loss[state.lastPrediction]++;
    }
  }
  
  updateAccuracyData(r);
  
  // Ø§Ù„ØªØ¹Ù„Ù… Ù…Ù† Ø§Ù„Ø£Ø®Ø·Ø§Ø¡
  const learningData = learnFromMistakes();
  
  const newPred = improvedPredict();
  updateImprovedUI(newPred, learningData);
  showResult(r, newPred, state.lastPrediction === r);
  updateAll();
}

// Ø§Ù„ØªÙ‡ÙŠØ¦Ø© Ø§Ù„Ù…Ø­Ø³Ù†Ø©
function init() {
  // Ø§Ù„ØªÙ‡ÙŠØ¦Ø© Ø§Ù„Ø£Ø³Ø§Ø³ÙŠØ©
  el('windowSize').value = state.windowSize;
  el('applyWindow').onclick = () => {
    const v = Number(el('windowSize').value);
    if (v < 3 || v > 15) {
      alert('Ø§Ù„Ù†Ø§ÙØ°Ø© ÙŠØ¬Ø¨ Ø£Ù† ØªÙƒÙˆÙ† Ø¨ÙŠÙ† 3 Ùˆ 15');
      return;
    }
    state.windowSize = v;
    state.adaptiveWindow = false;
    updateAll();
  };

  el('btnP').onclick = () => pushRound('P');
  el('btnB').onclick = () => pushRound('B');
  el('btnT').onclick = () => pushRound('T');
  el('btnUndo').onclick = undoRound;
  el('btnReset').onclick = resetAll;
  
  // Ø¹Ù†Ø§ØµØ± Ø§Ù„ØªØ­ÙƒÙ… Ø§Ù„ØªÙƒÙŠÙÙŠØ©
  el('btnAutoAdjust').onclick = () => {
    state.adaptiveWindow = true;
    alert('ØªÙ… ØªÙØ¹ÙŠÙ„ Ø§Ù„ÙˆØ¶Ø¹ Ø§Ù„ØªÙƒÙŠÙÙŠ Ø§Ù„Ø°ÙƒÙŠ');
  };
  
  el('btnManualMode').onclick = () => {
    state.adaptiveWindow = false;
    alert('ØªÙ… ØªÙØ¹ÙŠÙ„ Ø§Ù„ÙˆØ¶Ø¹ Ø§Ù„ÙŠØ¯ÙˆÙŠ');
  };

  el('themeToggle').onclick = toggleTheme;
  document.documentElement.setAttribute('data-theme', 'dark');

  updateAll();
}

// Ø¯Ø¹Ù… Ù„Ù„Ø¯ÙˆØ§Ù„ Ø§Ù„Ø¥Ø¶Ø§ÙÙŠØ©
function calculateStreak(arr) {
  if (arr.length === 0) return { length: 0, type: null };
  
  let streak = 1;
  const last = arr[arr.length - 1];
  
  for (let i = arr.length - 2; i >= 0; i--) {
    if (arr[i] === last) streak++;
    else break;
  }
  
  return { length: streak, type: last };
}

function analyzePingPong(arr) {
  if (arr.length < 3) return { strength: 0, expected: null };
  
  let pingPongCount = 0;
  for (let i = arr.length - 1; i >= 2; i--) {
    if (arr[i] !== arr[i-1] && arr[i-1] !== arr[i-2] && arr[i] === arr[i-2]) {
      pingPongCount++;
    }
  }
  
  const strength = pingPongCount / (arr.length - 2);
  const expected = strength > 0.5 ? arr[arr.length - 2] : null;
  
  return { strength, expected };
}

function calculatePatternStability() {
  if (state.rounds.length < 5) return 0;
  
  const recent = state.rounds.slice(-10);
  let changes = 0;
  
  for (let i = 1; i < recent.length; i++) {
    if (recent[i] !== recent[i-1]) changes++;
  }
  
  const stability = 1 - (changes / (recent.length - 1));
  return stability;
}

// Ø§Ø³ØªØ¨Ø¯Ø§Ù„ Ø¯Ø§Ù„Ø© Ø§Ù„ØªÙˆÙ‚Ø¹ Ø§Ù„Ù‚Ø¯ÙŠÙ…Ø© Ø¨Ø§Ù„Ø¬Ø¯ÙŠØ¯Ø©
const predict = improvedPredict;

window.onload = init;
</script>
</body>
</html>
