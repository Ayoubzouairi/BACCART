<!doctype html>
<html lang="ar" dir="rtl">
<head>
<meta charset="utf-8">
<meta name="viewport" content="width=device-width,initial-scale=1">
<title>AYOUB BACCARAT PRO - ุงููุณุฎุฉ ุงููุงููุฉ ูุน ุงูุญูุธ ุงูุชููุงุฆู</title>
<style>
@import url('https://fonts.googleapis.com/css2?family=Inter:wght@300;400;600;800&display=swap');
:root{--gold:#d4af37;--gold-2:#b8871d;--bg-dark:#070606;--card:#0f0e10;--muted:#bfb7a6;--player:#2d7ef7;--banker:#e03b3b;--tie:#28a745;}
:root[data-theme="light"]{--gold:#d4af37;--gold-2:#b8871d;--bg-dark:#f5f5f5;--card:#ffffff;--muted:#666666;--player:#2d7ef7;--banker:#e03b3b;--tie:#28a745;}
*{box-sizing:border-box;margin:0;padding:0;}
body{font-family:Inter,sans-serif;margin:0;background:linear-gradient(180deg,var(--bg-dark),#0b0b0b);color:#fff;padding:18px;transition:background 0.3s, color 0.3s;min-height:100vh;}
:root[data-theme="light"] body{color:#333;}
.app{max-width:1200px;margin:0 auto;width:100%;}
.top{display:flex;align-items:center;justify-content:space-between;gap:12px;margin-bottom:14px;flex-wrap:wrap;}
.logo{font-weight:800;background:linear-gradient(90deg,var(--gold),#fff3b0);color:#000;padding:8px 12px;border-radius:12px;display:inline-block;font-size:1.2rem;}
.subtitle{font-size:14px;color:var(--muted);margin-top:4px;}
.controls{display:flex;gap:8px;align-items:center;flex-wrap:wrap;}
.card{background:linear-gradient(180deg,var(--card),#0b0b0b);border-radius:12px;padding:12px;box-shadow:0 8px 30px rgba(0,0,0,0.6);border:1px solid rgba(212,175,55,0.08);margin-bottom:10px;}
:root[data-theme="light"] .card{background:linear-gradient(180deg,var(--card),#f0f0f0);box-shadow:0 8px 30px rgba(0,0,0,0.1);border:1px solid rgba(0,0,0,0.05);}
.layout{display:flex;gap:12px;flex-wrap:wrap;}
.left{width:360px;min-width:300px;display:flex;flex-direction:column;gap:10px;flex:1;}
.right{flex:2;display:flex;flex-direction:column;gap:12px;min-width:300px;}
.panel{padding:10px;}
.row{display:flex;gap:8px;align-items:center;margin-top:8px;}
input[type=number], select{background:rgba(255,255,255,0.1);border:2px solid rgba(255,255,255,0.3);padding:10px;border-radius:8px;color:#fff;font-weight:600;font-size:14px;width:100%;}
:root[data-theme="light"] input[type=number], :root[data-theme="light"] select{background:rgba(255,255,255,0.9);border:2px solid rgba(0,0,0,0.2);color:#333;}
.btn{padding:12px 16px;border-radius:8px;border:0;color:#fff;cursor:pointer;font-weight:600;font-size:16px;transition:all 0.3s;text-align:center;min-width:70px;}
.btn:hover{transform:translateY(-2px);box-shadow:0 4px 12px rgba(0,0,0,0.3);}
.btn:active{transform:translateY(0);}
.btn.gold{background:linear-gradient(90deg,var(--gold),var(--gold-2));color:#000;font-weight:700;box-shadow:0 6px 20px rgba(212,175,55,0.3);}

/* ุฃููุงู ูุงุถุญุฉ ูููุถุน ุงููููู */
.btn.player{background:linear-gradient(135deg, #3a86ff, #2667cc); color:white; border:2px solid #3a86ff;}
.btn.banker{background:linear-gradient(135deg, #ff006e, #cc0058); color:white; border:2px solid #ff006e;}
.btn.tie{background:linear-gradient(135deg, #38b000, #2c8a00); color:white; border:2px solid #38b000;}

/* ุฃููุงู ุงููุถุน ุงูููุงุฑู */
:root[data-theme="light"] .btn.player{background:linear-gradient(135deg, #2d7ef7, #1a67d8); color:white;}
:root[data-theme="light"] .btn.banker{background:linear-gradient(135deg, #e03b3b, #c53232); color:white;}
:root[data-theme="light"] .btn.tie{background:linear-gradient(135deg, #28a745, #218838); color:white;}

:root[data-theme="light"] .btn{background:rgba(0,0,0,0.1);color:#333; border:1px solid rgba(0,0,0,0.1)}

.small{font-size:13px;color:var(--muted);}
.muted{color:var(--muted);font-size:12px;}
.pattern-list{list-style:none;padding:6px;margin:6px 0 0 0;max-height:200px;overflow:auto;}
.pattern-list li{padding:8px;border-radius:8px;margin-bottom:6px;background:linear-gradient(180deg,rgba(255,255,255,0.02),transparent);display:flex;justify-content:space-between;align-items:center;}
:root[data-theme="light"] .pattern-list li{background:linear-gradient(180deg,rgba(0,0,0,0.02),transparent);}
.section-title{font-weight:700;margin-bottom:6px;color:var(--gold);font-size:1.1rem;}
.stat-table{width:100%;border-collapse:collapse;font-size:13px;}
.stat-table th,.stat-table td{border:1px solid rgba(255,255,255,0.05);padding:6px;text-align:center;}
:root[data-theme="light"] .stat-table th, :root[data-theme="light"] .stat-table td{border:1px solid rgba(0,0,0,0.05);}
.stat-table th{background:rgba(212,175,55,0.1);font-weight:600;}
.player{color:#3a86ff;font-weight:700;}
.banker{color:#ff006e;font-weight:700;}
.tie{color:#38b000;font-weight:700;}
.pred-head{display:flex;justify-content:space-between;align-items:center;flex-wrap:wrap;gap:10px;}
.final{font-size:22px;font-weight:800;text-align:center;padding:12px;background:linear-gradient(90deg,rgba(212,175,55,0.06),transparent);border-radius:10px;margin:10px 0;}
:root[data-theme="light"] .final{background:linear-gradient(90deg,rgba(212,175,55,0.1),transparent);}
.foot{display:flex;justify-content:space-between;align-items:center;margin-top:14px;flex-wrap:wrap;gap:10px;}
.credits{opacity:0.85;font-size:12px;}
canvas{border-radius:10px;background:#0f0e10;width:100% !important;height:auto !important;max-height:450px;}
:root[data-theme="light"] canvas{background:#f0f0f0;}
.color-legend{display:flex;gap:15px;justify-content:center;margin-bottom:10px;font-size:14px;flex-wrap:wrap;}
.color-legend span{padding:4px 8px;border-radius:6px; font-weight:600;}
.prediction-cards{display:flex;gap:10px;justify-content:center;margin:10px 0;flex-wrap:wrap;}
.pred-card{padding:10px;border-radius:8px;text-align:center;min-width:80px; font-weight:600;flex:1;}
.pred-card.active{transform:scale(1.05);border:2px solid var(--gold); box-shadow:0 4px 15px rgba(212,175,55,0.4);}
.win-effect{animation:winPulse 0.5s ease-in-out;}
.loss-effect{animation:lossShake 0.5s ease-in-out;}
@keyframes winPulse{0%{transform:scale(1)}50%{transform:scale(1.1)}100%{transform:scale(1)}}
@keyframes lossShake{0%,100%{transform:translateX(0)}25%{transform:translateX(-5px)}75%{transform:translateX(5px)}}
.analysis-result{margin-top:10px;padding:10px;background:rgba(255,255,255,0.03);border-radius:8px;text-align:center;}
:root[data-theme="light"] .analysis-result{background:rgba(0,0,0,0.03);}
.theme-toggle{background:transparent;border:none;font-size:24px;cursor:pointer;padding:5px;border-radius:50%;transition:background 0.3s;width:40px;height:40px;display:flex;align-items:center;justify-content:center;}
.theme-toggle:hover{background:rgba(255,255,255,0.1);}
:root[data-theme="light"] .theme-toggle:hover{background:rgba(0,0,0,0.05);}

/* ุชุญุณููุงุช ุฅุถุงููุฉ ููุญููู */
.input-group {display: flex; gap: 8px; align-items: center;}
.input-group input {flex: 1;}
.input-label {font-weight: 600; margin-bottom: 6px; display: block;}

/* ุฃููุงู ุงูุจุทุงูุงุช ูู ุงูุชููุน */
.pred-card.player {background: linear-gradient(135deg, #3a86ff, #2667cc); color: white;}
.pred-card.banker {background: linear-gradient(135deg, #ff006e, #cc0058); color: white;}
.pred-card.tie {background: linear-gradient(135deg, #38b000, #2c8a00); color: white;}

/* ุฃููุงุท ูููุญูู ุงูุชููุนุงุช */
.accuracy-panel {margin-top: 12px;}
.accuracy-stats {display: flex; justify-content: space-between; margin-bottom: 8px; flex-wrap: wrap; gap: 10px;}
.accuracy-stats > div {flex: 1; min-width: 120px;}
.accuracy-value {font-weight: 700; font-size: 18px;}
.accuracy-label {font-size: 12px; color: var(--muted);}
.accuracy-chart-container {position: relative; height: 80px; margin-top: 8px; width: 100%;}
.accuracy-line {stroke: var(--gold); stroke-width: 2; fill: none;}
.accuracy-point {fill: var(--gold); r: 3; transition: r 0.2s;}
.accuracy-point:hover {r: 5;}
.accuracy-grid {stroke: rgba(255,255,255,0.1); stroke-width: 1;}
:root[data-theme="light"] .accuracy-grid {stroke: rgba(0,0,0,0.1);}
.accuracy-tooltip {position: absolute; background: rgba(0,0,0,0.9); color: white; padding: 5px 8px; border-radius: 4px; font-size: 12px; pointer-events: none; opacity: 0; transition: opacity 0.2s; z-index: 100;}

/* ุฃููุงุท ุฌุฏูุฏุฉ ูููุงุฌูุฉ ุงููุญุณูุฉ */
.advanced-controls {background: rgba(212,175,55,0.05); border-radius: 8px; padding: 10px; margin-top: 8px;}
.control-group {display: flex; justify-content: space-between; align-items: center; margin-bottom: 8px; flex-wrap: wrap;}
.control-group:last-child {margin-bottom: 0;}
.slider-container {flex: 1; margin-left: 10px; min-width: 150px;}
.slider {width: 100%;}
.model-badge {display: inline-block; padding: 2px 8px; border-radius: 12px; font-size: 10px; font-weight: 600; margin-left: 5px;}
.badge-basic {background: #3a86ff; color: white;}
.badge-advanced {background: #ff006e; color: white;}
.badge-pattern {background: #38b000; color: white;}
.badge-ml {background: #9d4edd; color: white;}
.pattern-info {font-size: 11px; color: var(--muted); margin-top: 4px; line-height: 1.4;}
.confidence-meter {height: 6px; background: rgba(255,255,255,0.1); border-radius: 3px; margin-top: 4px; overflow:hidden;}
.confidence-fill {height: 100%; background: linear-gradient(90deg, #38b000, #ff006e); border-radius: 3px; transition: width 0.3s;}
.high-confidence {background: linear-gradient(90deg, #38b000, #d4af37);}
.medium-confidence {background: linear-gradient(90deg, #d4af37, #ff006e);}

/* ุชุจุฏูู ุฒุฑ ุงูุชุนูู ุงูุขูู */
.switch {position: relative; display: inline-block; width: 50px; height: 24px; flex-shrink: 0;}
.switch input {opacity: 0; width: 0; height: 0;}
.switch .slider {position: absolute; cursor: pointer; top: 0; left: 0; right: 0; bottom: 0; background-color: #ccc; transition: .4s; border-radius: 34px;}
.switch .slider:before {position: absolute; content: ""; height: 16px; width: 16px; left: 4px; bottom: 4px; background-color: white; transition: .4s; border-radius: 50%;}
.switch input:checked + .slider {background: linear-gradient(90deg, #9d4edd, #7b2cbf);}
.switch input:checked + .slider:before {transform: translateX(26px);}

/* ูุคุดุฑ ุชุฏุฑูุจ ML */
.ml-training-indicator {display: inline-block; width: 10px; height: 10px; border-radius: 50%; margin-right: 5px;}
.ml-training {background: #38b000; animation: pulse 1.5s infinite;}
.ml-not-trained {background: #ff006e;}
@keyframes pulse {0% {opacity: 1;} 50% {opacity: 0.5;} 100% {opacity: 1;}}

/* ุชุญุณููุงุช ูููุงุฌูุฉ */
.ml-info-panel {background: rgba(157, 78, 221, 0.05); border-left: 3px solid #9d4edd;}

/* ุฃุฒุฑุงุฑ ุงูุชุญูู ูู ุงูุจูุงูุงุช */
.data-controls {display: flex; gap: 8px; flex-wrap: wrap; margin-top: 8px;}
.data-controls .btn {padding: 6px 10px; font-size: 12px; flex: 1; min-width: 100px;}

/* ========== ุฃููุงุท ูุณุงุนุฏ ุงูุฐูู ========== */
.coach-btn {
    background: linear-gradient(135deg, #6a11cb 0%, #2575fc 100%);
    color: white;
    border: none;
    padding: 10px 16px;
    border-radius: 8px;
    cursor: pointer;
    font-weight: 600;
    display: flex;
    align-items: center;
    gap: 8px;
    transition: all 0.3s;
    margin-left: 8px;
}

.coach-btn:hover {
    transform: translateY(-2px);
    box-shadow: 0 6px 20px rgba(106, 17, 203, 0.4);
}

.coach-status-indicator {
    width: 8px;
    height: 8px;
    border-radius: 50%;
    display: inline-block;
    margin-right: 5px;
}

.coach-status-active {
    background: #38b000;
    animation: pulse 1.5s infinite;
}

.coach-status-inactive {
    background: #ff006e;
}

.coach-modal {
    display: none;
    position: fixed;
    top: 0;
    left: 0;
    width: 100%;
    height: 100%;
    background: rgba(0,0,0,0.85);
    z-index: 9999;
    align-items: center;
    justify-content: center;
    backdrop-filter: blur(5px);
}

.coach-modal.active {
    display: flex;
}

.coach-modal-content {
    background: linear-gradient(180deg, #0f0e10, #070606);
    border: 2px solid var(--gold);
    border-radius: 20px;
    width: 90%;
    max-width: 500px;
    max-height: 80vh;
    overflow: hidden;
    box-shadow: 0 0 50px rgba(212,175,55,0.3);
    animation: modalAppear 0.3s ease-out;
}

@keyframes modalAppear {
    from { opacity: 0; transform: scale(0.9); }
    to { opacity: 1; transform: scale(1); }
}

.coach-header {
    background: linear-gradient(90deg, rgba(106,17,203,0.2), rgba(37,117,252,0.2));
    padding: 20px;
    border-bottom: 1px solid rgba(212,175,55,0.2);
    display: flex;
    justify-content: space-between;
    align-items: center;
}

.coach-header h2 {
    margin: 0;
    background: linear-gradient(90deg, #6a11cb, #2575fc);
    -webkit-background-clip: text;
    background-clip: text;
    color: transparent;
    font-size: 1.3rem;
}

.close-coach {
    background: none;
    border: none;
    color: var(--muted);
    font-size: 28px;
    cursor: pointer;
    width: 40px;
    height: 40px;
    display: flex;
    align-items: center;
    justify-content: center;
    border-radius: 50%;
    transition: all 0.3s;
}

.close-coach:hover {
    background: rgba(255,255,255,0.1);
    color: var(--gold);
}

.coach-body {
    padding: 20px;
    overflow-y: auto;
    max-height: 60vh;
}

.coach-message {
    background: linear-gradient(135deg, rgba(106,17,203,0.1), rgba(37,117,252,0.1));
    border-radius: 12px;
    padding: 15px;
    margin-bottom: 15px;
    border-left: 4px solid #6a11cb;
    animation: messageSlide 0.3s ease-out;
}

@keyframes messageSlide {
    from { opacity: 0; transform: translateX(-10px); }
    to { opacity: 1; transform: translateX(0); }
}

.coach-message h3 {
    color: var(--gold);
    margin-bottom: 10px;
    font-size: 1.1rem;
}

.coach-message p {
    margin: 0;
    line-height: 1.6;
}

.coach-stats {
    display: grid;
    grid-template-columns: repeat(2, 1fr);
    gap: 10px;
    margin-bottom: 20px;
}

.stat-box {
    background: rgba(255,255,255,0.05);
    border-radius: 10px;
    padding: 12px;
    text-align: center;
    border: 1px solid rgba(212,175,55,0.1);
}

.stat-value {
    font-size: 24px;
    font-weight: 700;
    color: var(--gold);
    margin-bottom: 5px;
}

.stat-label {
    font-size: 11px;
    color: var(--muted);
}

.coach-controls {
    display: flex;
    gap: 10px;
    margin-top: 20px;
    flex-wrap: wrap;
}

.control-btn {
    flex: 1;
    min-width: 120px;
    padding: 10px;
    border: none;
    border-radius: 8px;
    cursor: pointer;
    font-weight: 600;
    transition: all 0.3s;
}

.control-btn.primary {
    background: linear-gradient(135deg, #6a11cb, #2575fc);
    color: white;
}

.control-btn.secondary {
    background: rgba(255,255,255,0.1);
    color: white;
    border: 1px solid rgba(255,255,255,0.2);
}

.control-btn:hover {
    transform: translateY(-2px);
    box-shadow: 0 4px 12px rgba(0,0,0,0.3);
}

/* ูุคุดุฑุงุช ุงูุฏุฎูู ูุงูุฎุฑูุฌ */
.entry-signal {
    display: inline-block;
    padding: 4px 12px;
    border-radius: 20px;
    font-weight: 600;
    font-size: 12px;
    margin-left: 10px;
}

.signal-entry {
    background: linear-gradient(135deg, #38b000, #2c8a00);
    color: white;
}

.signal-exit {
    background: linear-gradient(135deg, #ff006e, #cc0058);
    color: white;
}

.signal-wait {
    background: linear-gradient(135deg, #d4af37, #b8871d);
    color: white;
}

/* ุดุฑูุท ุงูุชูุฏู */
.progress-bar {
    height: 8px;
    background: rgba(255,255,255,0.1);
    border-radius: 4px;
    margin: 10px 0;
    overflow: hidden;
}

.progress-fill {
    height: 100%;
    border-radius: 4px;
    transition: width 0.3s;
}

/* ุฅุดุนุงุฑุงุช ุงูุฏูู */
.dicky-notification {
    position: fixed;
    bottom: 20px;
    right: 20px;
    background: linear-gradient(135deg, #6a11cb, #2575fc);
    color: white;
    padding: 15px 20px;
    border-radius: 10px;
    box-shadow: 0 8px 30px rgba(106,17,203,0.4);
    z-index: 9998;
    animation: slideInRight 0.3s ease-out;
    max-width: 300px;
    border-left: 4px solid var(--gold);
}

@keyframes slideInRight {
    from { transform: translateX(100%); opacity: 0; }
    to { transform: translateX(0); opacity: 1; }
}

.dicky-notification.hide {
    animation: slideOutRight 0.3s ease-in;
    transform: translateX(100%);
    opacity: 0;
}

@keyframes slideOutRight {
    from { transform: translateX(0); opacity: 1; }
    to { transform: translateX(100%); opacity: 0; }
}

.dicky-notification h4 {
    margin: 0 0 5px 0;
    color: var(--gold);
}

.dicky-notification p {
    margin: 0;
    font-size: 14px;
}

/* ููุญุฉ ุชุญูู ุงูููุณ */
.mental-control-panel {
    background: linear-gradient(135deg, rgba(37,117,252,0.1), rgba(106,17,203,0.1));
    border-radius: 12px;
    padding: 15px;
    margin-top: 15px;
}

.mental-stats {
    display: grid;
    grid-template-columns: repeat(3, 1fr);
    gap: 10px;
    margin-bottom: 15px;
}

.mental-stat {
    text-align: center;
    padding: 10px;
    background: rgba(0,0,0,0.3);
    border-radius: 8px;
}

.mental-stat .value {
    font-size: 20px;
    font-weight: 700;
    color: var(--gold);
}

.mental-stat .label {
    font-size: 10px;
    color: var(--muted);
    margin-top: 5px;
}

.advice-list {
    list-style: none;
    padding: 0;
    margin: 15px 0 0 0;
}

.advice-list li {
    padding: 8px;
    margin-bottom: 8px;
    background: rgba(255,255,255,0.05);
    border-radius: 8px;
    border-right: 3px solid #6a11cb;
    font-size: 13px;
}

/* ุฒุฑ ุงููุณุงุนุฏ ุงูุณุฑูุน */
.coach-quick-btn {
    position: fixed;
    bottom: 20px;
    left: 20px;
    width: 50px;
    height: 50px;
    background: linear-gradient(135deg, #6a11cb, #2575fc);
    border: none;
    border-radius: 50%;
    cursor: pointer;
    z-index: 999;
    box-shadow: 0 4px 15px rgba(106,17,203,0.4);
    display: flex;
    align-items: center;
    justify-content: center;
    font-size: 20px;
    transition: all 0.3s;
}

.coach-quick-btn:hover {
    transform: scale(1.1);
    box-shadow: 0 6px 20px rgba(106,17,203,0.6);
}

.coach-badge {
    position: absolute;
    top: -5px;
    right: -5px;
    background: #ff006e;
    color: white;
    font-size: 10px;
    padding: 2px 5px;
    border-radius: 10px;
    min-width: 15px;
    text-align: center;
}

/* ุชุญุณููุงุช ููุงุณุชุฌุงุจุฉ */
@media (max-width: 768px) {
    .layout {flex-direction: column;}
    .left, .right {width: 100%;}
    .top {flex-direction: column; align-items: flex-start;}
    .controls {width: 100%; justify-content: space-between;}
    .accuracy-stats > div {min-width: 100px;}
    .prediction-cards {flex-direction: column;}
    .pred-card {width: 100%;}
    .color-legend {justify-content: flex-start;}
    .row {flex-wrap: wrap;}
    .btn {flex: 1; min-width: 60px;}
    
    .coach-modal-content {
        width: 95%;
        margin: 10px;
    }
    
    .coach-stats {
        grid-template-columns: 1fr;
    }
    
    .mental-stats {
        grid-template-columns: repeat(2, 1fr);
    }
    
    .dicky-notification {
        bottom: 10px;
        right: 10px;
        left: 10px;
        max-width: none;
    }
    
    .coach-quick-btn {
        bottom: 10px;
        left: 10px;
    }
}

@media (max-width: 480px) {
    body {padding: 10px;}
    .card {padding: 8px;}
    .btn {padding: 10px 12px; font-size: 14px;}
    .accuracy-stats {flex-direction: column;}
    .accuracy-stats > div {min-width: 100%;}
    
    .coach-header h2 {
        font-size: 1.1rem;
    }
    
    .coach-controls {
        flex-direction: column;
    }
    
    .control-btn {
        min-width: 100%;
    }
}
</style>
</head>
<body>
<div class="app">
<header class="top card">
  <div class="brand">
    <div class="logo">AYOUB BACCARAT PRO <span class="model-badge badge-ml">ูุณุฎุฉ ูุงููุฉ</span></div>
    <div class="subtitle">ูุธุงู ุชูุจุค ุฐูู ูุน ุฎูุงุฑุฒููุงุช ุชุนูู ุขูุฉ ูุญูุธ ุชููุงุฆู ๐ง๐พ๐</div>
  </div>
  <div class="controls">
    <button id="themeToggle" class="theme-toggle" title="ุชุจุฏูู ุงููุถุน">๐</button>
    <button id="coachBtn" class="coach-btn">
      <span class="coach-status-indicator coach-status-active"></span>
      ูุณุงุนุฏ ุงูุฐูู
    </button>
    <button id="btnReset" class="btn gold">ุฅุนุงุฏุฉ ุชุนููู</button>
  </div>
</header>

<main class="layout">
<aside class="left">
  <div class="panel card">
    <label class="input-label">ูุงูุฐุฉ ุงูุชุญููู (5 - 15)</label>
    <div class="input-group">
      <input id="windowSize" type="number" min="5" max="15" value="8">
      <button id="applyWindow" class="btn gold">ุชุทุจูู</button>
    </div>
    <div class="muted small">ูุญูู ุขุฎุฑ 5-15 ุฌููุฉ ุจุงุณุชุฎุฏุงู ุฎูุงุฑุฒููุงุช ูุชูุฏูุฉ</div>
  </div>

  <!-- ุฅุนุฏุงุฏุงุช ุงูุชูุจุค ุงููุชูุฏู -->
  <div class="panel card">
    <div class="section-title">ุฅุนุฏุงุฏุงุช ุงูุชูุจุค ุงููุชูุฏู</div>
    <div class="advanced-controls">
      <div class="control-group">
        <label for="analysisMode">ููุท ุงูุชุญููู:</label>
        <select id="analysisMode">
          <option value="basic">ุฃุณุงุณู <span class="model-badge badge-basic">+5%</span></option>
          <option value="advanced" selected>ูุชูุฏู <span class="model-badge badge-advanced">+15%</span></option>
          <option value="pattern">ุชุญููู ุงูุฃููุงุท <span class="model-badge badge-pattern">+25%</span></option>
          <option value="ml">ุชุนูู ุงูุขูุฉ <span class="model-badge badge-ml">+35%</span></option>
        </select>
      </div>
      <div class="control-group">
        <label for="confidenceSensitivity">ุญุณุงุณูุฉ ุงูุซูุฉ:</label>
        <div class="slider-container">
          <input type="range" id="confidenceSensitivity" class="slider" min="30" max="60" value="45">
          <div class="muted small" id="sensitivityValue">45%</div>
        </div>
      </div>
      <div class="control-group">
        <label for="timeWeighting">ุงููุฑุฌุญุฉ ุงูุฒูููุฉ:</label>
        <select id="timeWeighting">
          <option value="none">ุจุฏูู</option>
          <option value="linear" selected>ุฎุทู</option>
          <option value="exponential">ุฃุณูู</option>
        </select>
      </div>
    </div>
  </div>

  <!-- ูุณู ุชุนูู ุงูุขูุฉ -->
  <div class="panel card ml-info-panel">
    <div class="section-title">โ๏ธ ุชุนูู ุงูุขูุฉ</div>
    <div class="row">
      <label class="switch">
        <input type="checkbox" id="mlToggle" checked>
        <span class="slider"></span>
      </label>
      <span>ุชูุนูู ุชุนูู ุงูุขูุฉ</span>
    </div>
    <div class="row">
      <select id="mlModelSelect" style="flex:1; margin-top: 5px;">
        <option value="knn">K-ุงูุฌูุฑุงู ุงูุฃูุฑุจ</option>
        <option value="logistic">ุงูุงูุญุฏุงุฑ ุงูููุฌุณุชู</option>
        <option value="ensemble" selected>ุงููุฌูุน (ุฌููุน ุงูููุงุฐุฌ)</option>
      </select>
    </div>
    <div class="row">
      <div id="mlStatus" class="muted small">
        <span class="ml-training-indicator ml-training"></span> 
        ุงููููุฐุฌ ูุชุนูู ูู ุงูุจูุงูุงุช...
      </div>
    </div>
    <div class="pattern-info">
      <span id="mlTrainingCount">0</span> ุนููุฉ ุชุฏุฑูุจ โข 
      <span id="mlAccuracy">0%</span> ุฏูุฉ โข 
      <span id="mlWeight">30%</span> ุชุฃุซูุฑ
    </div>
  </div>

  <!-- ุฅุฏุฎุงู ุงููุชุงุฆุฌ -->
  <div class="panel card">
    <div class="section-title">ุฅุฏุฎุงู ุงููุชุงุฆุฌ</div>
    <div class="row">
      <button class="btn player" id="btnP">ูุงุนุจ ๐ต</button>
      <button class="btn banker" id="btnB">ูุตุฑูู ๐ด</button>
      <button class="btn tie" id="btnT">ุชุนุงุฏู ๐ข</button>
    </div>
    <div class="row">
      <button class="btn" id="btnUndo" style="flex:1; background:rgba(255,255,255,0.1); border:1px solid rgba(255,255,255,0.2)">ุชุฑุงุฌุน</button>
    </div>
    <div class="muted small" style="margin-top: 8px; text-align: center;">
      ุฃุฏุฎู ูุชูุฌุฉ ูู ุฌููุฉ ุจุงูุถุบุท ุนูู ุงูุฒุฑ ุงูููุงุณุจ
    </div>
  </div>

  <!-- ุงูุฅุญุตุงุกุงุช -->
  <div class="panel card stats">
    <div class="section-title">ุงูุฅุญุตุงุกุงุช ุงููุชูุฏูุฉ</div>
    <table class="stat-table">
      <thead>
        <tr><th>ุงูุฌูุฉ</th><th>ุงููุฌููุน</th><th>ููุฒ</th><th>ุฎุณุงุฑุฉ</th><th>ูุณุจุฉ %</th><th>ุฏูุฉ</th><th>ML ุฏูุฉ</th></tr>
      </thead>
      <tbody>
        <tr><td class="player">ูุงุนุจ</td><td id="pTotal">0</td><td id="pWin">0</td><td id="pLoss">0</td><td id="pPct">0%</td><td id="pAccuracy">0%</td><td id="pMLAccuracy">0%</td></tr>
        <tr><td class="banker">ูุตุฑูู</td><td id="bTotal">0</td><td id="bWin">0</td><td id="bLoss">0</td><td id="bPct">0%</td><td id="bAccuracy">0%</td><td id="bMLAccuracy">0%</td></tr>
        <tr><td class="tie">ุชุนุงุฏู</td><td id="tTotal">0</td><td id="tWin">0</td><td id="tLoss">0</td><td id="tPct">0%</td><td id="tAccuracy">0%</td><td id="tMLAccuracy">0%</td></tr>
      </tbody>
    </table>
    <div class="pattern-info" id="patternInfo">ูุง ุชูุฌุฏ ุฃููุงุท ููุชุดูุฉ ุจุนุฏ</div>
  </div>

  <!-- ูุคุดุฑ ุงูุซูุฉ -->
  <div class="panel card">
    <div class="section-title">ูุคุดุฑ ุงูุซูุฉ</div>
    <div class="muted small" id="confidenceLabel">ุซูุฉ ููุฎูุถุฉ</div>
    <div class="confidence-meter">
      <div class="confidence-fill" id="confidenceFill" style="width: 0%"></div>
    </div>
    <div class="pattern-info" id="modelInfo">ุงููููุฐุฌ: ุฃุณุงุณู</div>
  </div>
</aside>

<section class="right">
  <div class="card prediction">
    <div class="pred-head">
      <div class="pred-title">ุชููุน ุงูุฌููุฉ ุงููุงุฏูุฉ <span id="predModel" class="model-badge badge-basic">ุฃุณุงุณู</span></div>
      <div class="pred-sub">ูุธุงู ุชูุจุค ูุชุนุฏุฏ ุงูููุงุฐุฌ ูุน ุฎูุงุฑุฒููุงุช ุชุนูู ุขูุฉ</div>
    </div>

    <div class="color-legend">
      <span style="background:linear-gradient(135deg, #3a86ff, #2667cc);">๐ต ูุงุนุจ</span>
      <span style="background:linear-gradient(135deg, #ff006e, #cc0058);">๐ด ูุตุฑูู</span>
      <span style="background:linear-gradient(135deg, #38b000, #2c8a00);">๐ข ุชุนุงุฏู</span>
    </div>
    
    <canvas id="bigRoad" width="800" height="450"></canvas>

    <div class="prediction-cards">
      <div class="pred-card player" id="predP">
        <div>ูุงุนุจ</div>
        <div id="predPctP">0%</div>
        <div class="muted small" id="predTrendP">โ</div>
      </div>
      <div class="pred-card banker" id="predB">
        <div>ูุตุฑูู</div>
        <div id="predPctB">0%</div>
        <div class="muted small" id="predTrendB">โ</div>
      </div>
      <div class="pred-card tie" id="predT">
        <div>ุชุนุงุฏู</div>
        <div id="predPctT">0%</div>
        <div class="muted small" id="predTrendT">โ</div>
      </div>
    </div>

    <div class="analysis-result">
      <div class="muted">ุงูุชููุน ุงูุญุงูู:</div>
      <div class="final" id="finalCard">โ</div>
      <div class="muted small" id="predictionReason">ุจุงูุชุธุงุฑ ุจูุงูุงุช ูุงููุฉ ููุชุญููู</div>
      <div class="muted small" id="mlContribution" style="margin-top: 5px; color: #9d4edd;"></div>
    </div>
  </div>

  <!-- ููุญูู ุงูุชููุนุงุช -->
  <div class="panel card accuracy-panel">
    <div class="section-title">ููุญูู ุฏูุฉ ุงูุชููุนุงุช ุงููุชูุฏู</div>
    <div class="accuracy-stats">
      <div>
        <div class="accuracy-label">ุงูุฏูุฉ ุงูุญุงููุฉ</div>
        <div class="accuracy-value" id="currentAccuracy">0%</div>
      </div>
      <div>
        <div class="accuracy-label">ุฃูุถู ุฏูุฉ</div>
        <div class="accuracy-value" id="bestAccuracy">0%</div>
      </div>
      <div>
        <div class="accuracy-label">ูุชูุณุท ุงูุฏูุฉ</div>
        <div class="accuracy-value" id="averageAccuracy">0%</div>
      </div>
      <div>
        <div class="accuracy-label">ุฏูุฉ ML</div>
        <div class="accuracy-value" id="mlOverallAccuracy">0%</div>
      </div>
    </div>
    <div class="accuracy-chart-container">
      <svg id="accuracyChart" width="100%" height="100%"></svg>
      <div id="accuracyTooltip" class="accuracy-tooltip"></div>
    </div>
    <div class="muted small">ุชุชุจุน ุฏูุฉ ุชููุนุงุชู ูุน ุชุญููู ุฃุฏุงุก ุงูููุงุฐุฌ ุงููุฎุชููุฉ</div>
  </div>
</section>
</main>

<footer class="foot card">
  <div style="flex: 1;">
    <div>ุชุตููู: Ayoub โข ุงููุณุฎุฉ ุงููุงููุฉ ูุน ุงูุญูุธ ุงูุชููุงุฆู</div>
    <div class="credits small">ูุธุงู ูุชุนุฏุฏ ุงูููุงุฐุฌ โข ุชุนูู ุขูุฉ โข ุชุญููู ุงูุฃููุงุท โข ุญูุธ ุชููุงุฆู โข ูุคุดุฑุงุช ูุชูุฏูุฉ</div>
  </div>
  <div class="data-controls">
    <button id="btnExport" class="btn" style="background: rgba(59, 130, 246, 0.2); border: 1px solid #3a86ff;">๐ฅ ุชุตุฏูุฑ</button>
    <button id="btnImport" class="btn" style="background: rgba(16, 185, 129, 0.2); border: 1px solid #10b981;">๐ค ุงุณุชูุฑุงุฏ</button>
    <button id="btnClearData" class="btn" style="background: rgba(239, 68, 68, 0.2); border: 1px solid #ef4444;">๐๏ธ ูุณุญ</button>
  </div>
  <div class="muted small" style="text-align: center; width: 100%; margin-top: 10px;">
    <span id="autoSaveStatus">๐พ ุงูุญูุธ ุงูุชููุงุฆู ููุนู</span> โข 
    <span id="dataStats">0 ุฌููุฉ โข 0 ุนููุฉ ุชุฏุฑูุจ</span>
  </div>
</footer>
</div>

<!-- ========== ูุงูุฐุฉ ุงููุณุงุนุฏ ุงูุฐูู ========== -->
<div id="coachModal" class="coach-modal">
  <div class="coach-modal-content">
    <div class="coach-header">
      <h2>๐จโ๐ซ ูุณุงุนุฏ ุงูุจุงูุงุฑุงุช ุงูุฐูู - AYOUB COACH</h2>
      <button class="close-coach">&times;</button>
    </div>
    <div class="coach-body">
      <div class="coach-message" id="coachMessage">
        <h3>ูุฑุญุจูุง ุจู ูู ูุธุงู ุงูุชุฏุฑูุจ ุงูุฐูู!</h3>
        <p>ุฃูุง ูุณุงุนุฏู ุงูุฐูู ูุชุญููู ูุนุจุฉ ุงูุจุงูุงุฑุงุช. ุณุฃุชุงุจุน ูุนุจุชู ูุฃุนุทูู ุฅุดุงุฑุงุช ุฏุฎูู ูุฎุฑูุฌ ุฐููุฉ ุจูุงุกู ุนูู ุชุญููู ุงูุฃููุงุท ูุงูุฅุญุตุงุฆูุงุช.</p>
      </div>
      
      <div class="coach-stats">
        <div class="stat-box">
          <div class="stat-value" id="coachWinRate">0%</div>
          <div class="stat-label">ูุนุฏู ุงูููุฒ</div>
        </div>
        <div class="stat-box">
          <div class="stat-value" id="coachStreak">0</div>
          <div class="stat-label">ุชุชุงุจุน ุงููุชุงุฆุฌ</div>
        </div>
        <div class="stat-box">
          <div class="stat-value" id="coachRiskLevel">ููุฎูุถ</div>
          <div class="stat-label">ูุณุชูู ุงููุฎุงุทุฑุฉ</div>
        </div>
        <div class="stat-box">
          <div class="stat-value" id="coachSessionTime">0:00</div>
          <div class="stat-label">ูุฏุฉ ุงูุฌูุณุฉ</div>
        </div>
      </div>
      
      <div class="mental-control-panel">
        <h3 style="color: var(--gold); margin-bottom: 15px;">๐ฏ ุชุญูู ูู ุงูููุณ ูุงูุงูุถุจุงุท</h3>
        
        <div class="mental-stats">
          <div class="mental-stat">
            <div class="value" id="mentalFocus">85%</div>
            <div class="label">ุงูุชุฑููุฒ</div>
          </div>
          <div class="mental-stat">
            <div class="value" id="mentalPressure">35%</div>
            <div class="label">ุงูุถุบุท</div>
          </div>
          <div class="mental-stat">
            <div class="value" id="mentalDecisions">12</div>
            <div class="label">ูุฑุงุฑุงุช ุตุญูุญุฉ</div>
          </div>
        </div>
        
        <div class="progress-bar">
          <div class="progress-fill" id="mentalProgress" style="width: 60%; background: linear-gradient(90deg, #38b000, #d4af37);"></div>
        </div>
        <div style="text-align: center; font-size: 12px; color: var(--muted); margin-top: 5px;" id="mentalStatus">ุญุงูุฉ ุนูููุฉ: ุฌูุฏุฉ</div>
      </div>
      
      <div style="margin-top: 20px;">
        <h3 style="color: var(--gold); margin-bottom: 10px;">๐ ุฅุดุงุฑุงุช ุงูุฏุฎูู/ุงูุฎุฑูุฌ</h3>
        <div id="entrySignals" style="background: rgba(255,255,255,0.05); padding: 15px; border-radius: 10px;">
          <div id="currentSignal" class="entry-signal signal-wait">ุงูุชุธุงุฑ</div>
          <span id="signalReason" style="font-size: 13px; color: var(--muted);">ุจุงูุชุธุงุฑ ุจูุงูุงุช ูุงููุฉ ููุชุญููู...</span>
        </div>
      </div>
      
      <div style="margin-top: 20px;">
        <h3 style="color: var(--gold); margin-bottom: 10px;">๐ก ูุตุงุฆุญ ุฐููุฉ</h3>
        <ul class="advice-list" id="coachAdvice">
          <li>ุงุจุฏุฃ ุจุงููุฑุงูุจุฉ ุฃููุงู ูุจู ุงูุฏุฎูู</li>
          <li>ุชููู ุจุนุฏ 3 ุฎุณุงุฆุฑ ูุชุชุงููุฉ</li>
          <li>ุงุญุชูุธ ุจู 50% ูู ุฑุฃุณ ุงููุงู ุงุญุชูุงุทููุง</li>
        </ul>
      </div>
      
      <div class="coach-controls">
        <button class="control-btn primary" id="coachAnalyzeBtn">๐ ุชุญููู ููุฑู</button>
        <button class="control-btn secondary" id="coachResetBtn">๐ ุฅุนุงุฏุฉ ุถุจุท ุงููุณุงุนุฏ</button>
        <button class="control-btn secondary" id="coachSettingsBtn">โ๏ธ ุฅุนุฏุงุฏุงุช ุงููุณุงุนุฏ</button>
      </div>
    </div>
  </div>
</div>

<!-- ุฒุฑ ุงููุณุงุนุฏ ุงูุณุฑูุน -->
<button id="quickCoachBtn" class="coach-quick-btn">
  ๐ค
  <span class="coach-badge" id="coachAlertBadge" style="display: none;">!</span>
</button>

<!-- ุฅุดุนุงุฑุงุช ุงูุฏูู -->
<div id="dickyNotification" class="dicky-notification" style="display: none;">
  <h4>๐ข ูุตูุญุฉ ูู ุงูุฏูู</h4>
  <p id="dickyMessage">ุชููู ูุคูุชูุง ูุฎุฐ ููุณูุง ุนููููุง</p>
</div>

<script>
// ========== ูุธุงู ุงููุณุงุนุฏ ุงูุฐูู (ุงูุฏูู) ==========

class AICoach {
    constructor() {
        this.isActive = true;
        this.sessionStart = new Date();
        this.entrySignals = [];
        this.mentalState = {
            focus: 85,
            pressure: 35,
            correctDecisions: 0,
            totalDecisions: 0,
            emotionalStability: 75
        };
        this.coachStats = {
            totalRounds: 0,
            wins: 0,
            losses: 0,
            currentStreak: 0,
            bestStreak: 0,
            winRate: 0,
            riskLevel: 'ููุฎูุถ'
        };
        this.notificationQueue = [];
        this.isShowingNotification = false;
        this.alertCount = 0;
    }

    // ุชุญููู ุงููุถุน ุงูุญุงูู ูุฅุนุทุงุก ุฅุดุงุฑุฉ
    analyzeSituation(rounds, predictions, stats) {
        if (rounds.length < 3) {
            return {
                signal: 'wait',
                reason: 'ุจุญุงุฌุฉ ููุฒูุฏ ูู ุงูุจูุงูุงุช ููุชุญููู',
                confidence: 0,
                advice: 'ุชุงุจุน ุงููุฑุงูุจุฉ ุฏูู ุฏุฎูู'
            };
        }

        const recent = rounds.slice(-5);
        const playerWins = recent.filter(r => r === 'P').length;
        const bankerWins = recent.filter(r => r === 'B').length;
        const ties = recent.filter(r => r === 'T').length;

        // ุชุญููู ุงูุฃููุงุท
        let patternAnalysis = this.analyzePatterns(rounds);
        
        // ุชุญููู ุงููุฎุงุทุฑ
        let riskLevel = this.calculateRiskLevel(stats, patternAnalysis);
        
        // ุชุญููู ุงูุนูููุฉ
        let mentalReadiness = this.assessMentalReadiness();
        
        // ุงุชุฎุงุฐ ุงููุฑุงุฑ
        let signal = 'wait';
        let reason = '';
        let confidence = 0;

        // ุดุฑูุท ุงูุฏุฎูู ููุงุนุจ
        if (patternAnalysis.playerPattern.strength > 0.7 && 
            mentalReadiness > 0.6 && 
            riskLevel === 'ููุฎูุถ' &&
            predictions.P > 45) {
            signal = 'entry';
            reason = `ููุท ูุงุนุจ ููู (${(patternAnalysis.playerPattern.strength * 100).toFixed(0)}%) + ุชุฑููุฒ ุนุงูู`;
            confidence = predictions.P;
        }
        // ุดุฑูุท ุงูุฏุฎูู ูููุตุฑูู
        else if (patternAnalysis.bankerPattern.strength > 0.7 && 
                 mentalReadiness > 0.6 && 
                 riskLevel === 'ููุฎูุถ' &&
                 predictions.B > 45) {
            signal = 'entry';
            reason = `ููุท ูุตุฑูู ููู (${(patternAnalysis.bankerPattern.strength * 100).toFixed(0)}%) + ุชุฑููุฒ ุนุงูู`;
            confidence = predictions.B;
        }
        // ุดุฑูุท ุงูุฎุฑูุฌ
        else if (stats.lossStreak >= 3 || mentalReadiness < 0.4 || riskLevel === 'ูุฑุชูุน') {
            signal = 'exit';
            reason = stats.lossStreak >= 3 ? '3 ุฎุณุงุฆุฑ ูุชุชุงููุฉ' : 
                     mentalReadiness < 0.4 ? 'ุงูุฎูุงุถ ุงูุชุฑููุฒ' : 'ูุฎุงุทุฑ ูุฑุชูุนุฉ';
            confidence = 85;
        }
        // ุดุฑูุท ุงูุงูุชุธุงุฑ
        else {
            signal = 'wait';
            reason = 'ุงููุถุน ุบูุฑ ูุงุถุญ - ุฃูุถู ุงูุงูุชุธุงุฑ';
            confidence = 50;
        }

        // ุชุญุฏูุซ ุงูุฅุญุตุงุฆูุงุช
        this.updateCoachStats(rounds, signal);

        return {
            signal,
            reason,
            confidence,
            advice: this.generateAdvice(signal, patternAnalysis, mentalReadiness, riskLevel),
            riskLevel,
            mentalReadiness: Math.round(mentalReadiness * 100)
        };
    }

    analyzePatterns(rounds) {
        if (rounds.length < 4) {
            return {
                playerPattern: { type: 'none', strength: 0 },
                bankerPattern: { type: 'none', strength: 0 },
                volatility: 0
            };
        }

        const recent = rounds.slice(-8);
        let playerStreak = 0;
        let bankerStreak = 0;
        let playerSequences = [];
        let bankerSequences = [];
        
        // ุชุญููู ุงูุชุชุงุจุนุงุช
        for (let i = 0; i < recent.length; i++) {
            if (recent[i] === 'P') {
                playerStreak++;
                bankerStreak = 0;
            } else if (recent[i] === 'B') {
                bankerStreak++;
                playerStreak = 0;
            }
            
            if (playerStreak >= 2) playerSequences.push(playerStreak);
            if (bankerStreak >= 2) bankerSequences.push(bankerStreak);
        }

        // ุญุณุงุจ ุงูุชููุจ
        let changes = 0;
        for (let i = 1; i < recent.length; i++) {
            if (recent[i] !== recent[i-1]) changes++;
        }
        const volatility = changes / (recent.length - 1);

        return {
            playerPattern: {
                type: playerSequences.length > 0 ? 'streak' : 'none',
                strength: playerSequences.length > 0 ? Math.min(1, Math.max(...playerSequences) / 5) : 0
            },
            bankerPattern: {
                type: bankerSequences.length > 0 ? 'streak' : 'none',
                strength: bankerSequences.length > 0 ? Math.min(1, Math.max(...bankerSequences) / 5) : 0
            },
            volatility
        };
    }

    calculateRiskLevel(stats, patternAnalysis) {
        let riskScore = 0;
        
        // ุฒูุงุฏุฉ ุงููุฎุงุทุฑ ูุน ุงูุฎุณุงุฆุฑ ุงููุชุชุงููุฉ
        if (stats.lossStreak >= 3) riskScore += 40;
        else if (stats.lossStreak >= 2) riskScore += 20;
        
        // ุฒูุงุฏุฉ ุงููุฎุงุทุฑ ูุน ุงูุชููุจ ุงูุนุงูู
        if (patternAnalysis.volatility > 0.7) riskScore += 30;
        else if (patternAnalysis.volatility > 0.5) riskScore += 15;
        
        // ุฒูุงุฏุฉ ุงููุฎุงุทุฑ ูุน ุงูุฎูุงุถ ุงูุชุฑููุฒ
        if (this.mentalState.focus < 50) riskScore += 20;
        
        // ุชุญุฏูุฏ ูุณุชูู ุงููุฎุงุทุฑ
        if (riskScore >= 60) return 'ูุฑุชูุน';
        else if (riskScore >= 30) return 'ูุชูุณุท';
        else return 'ููุฎูุถ';
    }

    assessMentalReadiness() {
        // ุญุณุงุจ ุงูุฌุงูุฒูุฉ ุงูุนูููุฉ ุจูุงุกู ุนูู ุนุฏุฉ ุนูุงูู
        let score = 0;
        score += (this.mentalState.focus / 100) * 0.4;
        score += ((100 - this.mentalState.pressure) / 100) * 0.3;
        score += (this.mentalState.emotionalStability / 100) * 0.2;
        
        // ุชุฃุซูุฑ ุงููุฑุงุฑุงุช ุงูุตุญูุญุฉ
        if (this.mentalState.totalDecisions > 0) {
            const decisionAccuracy = this.mentalState.correctDecisions / this.mentalState.totalDecisions;
            score += decisionAccuracy * 0.1;
        }
        
        return Math.max(0, Math.min(1, score));
    }

    generateAdvice(signal, patternAnalysis, mentalReadiness, riskLevel) {
        const adviceList = [];
        
        if (signal === 'entry') {
            adviceList.push('โ ุฃุฏุฎู ุจุฑูุงู ุตุบูุฑ ูู ุงูุจุฏุงูุฉ');
            adviceList.push('๐ ุชุงุจุน ุงูููุท ุนู ูุซุจ');
            adviceList.push('โฑ๏ธ ุญุฏุฏ ูุฏู ุฑุจุญ ูุฎุณุงุฑุฉ ูุณุจููุง');
        } else if (signal === 'exit') {
            adviceList.push('โ ุชููู ููุฑุงู ุนู ุงููุฑุงููุฉ');
            adviceList.push('๐ง ุฎุฐ ูุณุทุงู ูู ุงูุฑุงุญุฉ');
            adviceList.push('๐ ุฑุงุฌุน ุฃุณุจุงุจ ุงูุฎุณุงุฑุฉ ุจููุถูุนูุฉ');
        } else {
            adviceList.push('๐ ุงุณุชูุฑ ูู ุงููุฑุงูุจุฉ ุฏูู ุฏุฎูู');
            adviceList.push('๐ ุงุจุญุซ ุนู ุฃููุงุท ูุงุถุญุฉ');
            adviceList.push('๐ญ ุฑูุฒ ุนูู ุฌูุฏุฉ ุงููุฑุงุฑ ูููุณ ุงููููุฉ');
        }
        
        // ูุตุงุฆุญ ุฅุถุงููุฉ ุจูุงุกู ุนูู ุงูุนูุงูู
        if (mentalReadiness < 0.5) {
            adviceList.push('๐ง ุฎุฐ ููุณูุง ุนููููุง ูุงุณุชุนุงุฏุฉ ุงูุชุฑููุฒ');
        }
        
        if (riskLevel === 'ูุฑุชูุน') {
            adviceList.push('โ๏ธ ููู ุญุฌู ุงูุฑูุงู ุฅูู ุงููุตู');
        }
        
        if (patternAnalysis.volatility > 0.6) {
            adviceList.push('๐ ุงูุณูู ูุชููุจ - ูู ุญุฐุฑูุง');
        }
        
        return adviceList;
    }

    updateCoachStats(rounds, lastSignal) {
        this.coachStats.totalRounds = rounds.length;
        
        // ุชุญุฏูุซ ูุนุฏู ุงูููุฒ (ูุจุณุท)
        if (rounds.length > 0) {
            const last10 = rounds.slice(-10);
            const wins = last10.filter((r, i) => {
                if (this.entrySignals[i] === 'entry') {
                    return true; // ูุฐุง ุชุจุณูุท - ูู ุงููุงูุน ูุฌุจ ููุงุฑูุฉ ูุน ุงููุชูุฌุฉ ุงููุนููุฉ
                }
                return false;
            }).length;
            this.coachStats.winRate = last10.length > 0 ? (wins / last10.length) * 100 : 0;
        }
        
        // ุชุญุฏูุซ ุงูุชุชุงุจุน
        if (lastSignal === 'entry') {
            this.coachStats.currentStreak++;
            this.coachStats.bestStreak = Math.max(this.coachStats.bestStreak, this.coachStats.currentStreak);
        } else if (lastSignal === 'exit') {
            this.coachStats.currentStreak = 0;
        }
        
        // ุญูุธ ุงูุฅุดุงุฑุฉ
        this.entrySignals.push(lastSignal);
        if (this.entrySignals.length > 20) {
            this.entrySignals = this.entrySignals.slice(-20);
        }
    }

    updateMentalState(result, wasCorrect) {
        // ุชุญุฏูุซ ุญุงูุฉ ุงูุนูููุฉ ุจูุงุกู ุนูู ุงููุชูุฌุฉ
        if (wasCorrect) {
            this.mentalState.correctDecisions++;
            this.mentalState.focus = Math.min(100, this.mentalState.focus + 5);
            this.mentalState.pressure = Math.max(0, this.mentalState.pressure - 8);
            this.mentalState.emotionalStability = Math.min(100, this.mentalState.emotionalStability + 10);
        } else {
            this.mentalState.focus = Math.max(30, this.mentalState.focus - 15);
            this.mentalState.pressure = Math.min(100, this.mentalState.pressure + 20);
            this.mentalState.emotionalStability = Math.max(20, this.mentalState.emotionalStability - 15);
        }
        
        this.mentalState.totalDecisions++;
        
        // ุฅุถุงูุฉ ุฅุดุนุงุฑ ุฅุฐุง ูุงูุช ุงูุญุงูุฉ ุณูุฆุฉ
        if (this.mentalState.focus < 40 || this.mentalState.pressure > 70) {
            this.addNotification('ุงูุชุจุงู! ุญุงูุชู ุงูุนูููุฉ ุชุญุชุงุฌ ุชุญุณูู. ุฎุฐ ุงุณุชุฑุงุญุฉ ูุตูุฑุฉ.');
        }
    }

    addNotification(message, type = 'advice') {
        this.notificationQueue.push({
            message,
            type,
            timestamp: new Date(),
            read: false
        });
        
        this.alertCount++;
        this.updateAlertBadge();
        
        // ุฅุธูุงุฑ ุงูุฅุดุนุงุฑ ููุฑูุง ุฅุฐุง ูู ููู ููุงู ุฅุดุนุงุฑ ูุนุฑูุถ
        if (!this.isShowingNotification) {
            this.showNextNotification();
        }
    }

    showNextNotification() {
        if (this.notificationQueue.length === 0) {
            this.isShowingNotification = false;
            return;
        }
        
        this.isShowingNotification = true;
        const notification = this.notificationQueue.shift();
        
        // ุฅุธูุงุฑ ุงูุฅุดุนุงุฑ ูู ุงููุงุฌูุฉ
        showDickyNotification(notification.message);
        
        // ุฌุฏููุฉ ุงูุฅุดุนุงุฑ ุงูุชุงูู ุจุนุฏ 5 ุซูุงูู
        setTimeout(() => {
            this.isShowingNotification = false;
            this.showNextNotification();
        }, 5000);
    }

    updateAlertBadge() {
        const badge = document.getElementById('coachAlertBadge');
        if (badge) {
            if (this.alertCount > 0) {
                badge.textContent = this.alertCount > 9 ? '9+' : this.alertCount;
                badge.style.display = 'block';
            } else {
                badge.style.display = 'none';
            }
        }
    }

    clearAlerts() {
        this.alertCount = 0;
        this.notificationQueue = [];
        this.updateAlertBadge();
    }

    getSessionTime() {
        const now = new Date();
        const diff = now - this.sessionStart;
        const hours = Math.floor(diff / 3600000);
        const minutes = Math.floor((diff % 3600000) / 60000);
        return `${hours}:${minutes.toString().padStart(2, '0')}`;
    }

    reset() {
        this.sessionStart = new Date();
        this.entrySignals = [];
        this.mentalState = {
            focus: 85,
            pressure: 35,
            correctDecisions: 0,
            totalDecisions: 0,
            emotionalStability: 75
        };
        this.coachStats = {
            totalRounds: 0,
            wins: 0,
            losses: 0,
            currentStreak: 0,
            bestStreak: 0,
            winRate: 0,
            riskLevel: 'ููุฎูุถ'
        };
        this.clearAlerts();
    }

    getStats() {
        return {
            mentalState: this.mentalState,
            coachStats: this.coachStats,
            sessionTime: this.getSessionTime(),
            alertCount: this.alertCount,
            isActive: this.isActive
        };
    }
}

// ========== ุฎูุงุฑุฒููุงุช ุชุนูู ุงูุขูุฉ ==========

class SimpleKNN {
  constructor(k = 3) {
    this.k = k;
    this.trainingData = [];
    this.predictions = { correct: 0, total: 0 };
  }

  train(features, labels) {
    if (!features || !labels || features.length === 0) return;
    
    features.forEach((f, i) => {
      if (f && labels[i]) {
        this.trainingData.push({
          features: f,
          label: labels[i]
        });
      }
    });
    
    // ุงูุญูุงุธ ุนูู ุญุฌู ูุนููู
    if (this.trainingData.length > 100) {
      this.trainingData = this.trainingData.slice(-100);
    }
  }

  predict(newFeatures) {
    if (!newFeatures || this.trainingData.length === 0) {
      return { P: 33.3, B: 33.3, T: 33.3 };
    }

    try {
      const distances = this.trainingData.map((dataPoint, index) => ({
        index,
        distance: this.euclideanDistance(newFeatures, dataPoint.features),
        label: dataPoint.label
      }));

      distances.sort((a, b) => a.distance - b.distance);
      const nearestNeighbors = distances.slice(0, this.k);
      
      const votes = { P: 0, B: 0, T: 0 };
      nearestNeighbors.forEach(n => {
        if (n.label in votes) {
          votes[n.label] += 1 / (n.distance + 1);
        }
      });

      const total = votes.P + votes.B + votes.T;
      if (total === 0) return { P: 33.3, B: 33.3, T: 33.3 };
      
      return {
        P: (votes.P / total) * 100,
        B: (votes.B / total) * 100,
        T: (votes.T / total) * 100
      };
    } catch (e) {
      console.error('KNN prediction error:', e);
      return { P: 33.3, B: 33.3, T: 33.3 };
    }
  }

  euclideanDistance(a, b) {
    if (!a || !b || a.length !== b.length) return 1000;
    
    let sum = 0;
    for (let i = 0; i < a.length; i++) {
      sum += Math.pow((a[i] || 0) - (b[i] || 0), 2);
    }
    return Math.sqrt(sum);
  }

  updateAccuracy(prediction, actual) {
    this.predictions.total++;
    if (prediction === actual) this.predictions.correct++;
  }

  getAccuracy() {
    return this.predictions.total > 0 ? 
      (this.predictions.correct / this.predictions.total) * 100 : 0;
  }
}

class SimpleLogisticRegression {
  constructor() {
    this.weights = { P: 0.1, B: 0.1, T: 0.1 };
    this.bias = 0;
    this.learningRate = 0.05;
    this.predictions = { correct: 0, total: 0 };
  }

  sigmoid(x) {
    return 1 / (1 + Math.exp(-x));
  }

  trainOne(features, label) {
    if (!features || !label || features.length === 0) return;
    
    try {
      const labelNum = { P: 0, B: 1, T: 2 }[label];
      if (labelNum === undefined) return;
      
      const score = features[0] * this.weights.P + features[1] * this.weights.B + features[2] * this.weights.T + this.bias;
      const prediction = this.sigmoid(score);
      const error = (labelNum / 2) - prediction;
      
      this.weights.P += this.learningRate * error * features[0];
      this.weights.B += this.learningRate * error * features[1];
      this.weights.T += this.learningRate * error * features[2];
      this.bias += this.learningRate * error;
    } catch (e) {
      console.error('Logistic regression training error:', e);
    }
  }

  predict(features) {
    if (!features || features.length === 0) {
      return { P: 33.3, B: 33.3, T: 33.3 };
    }
    
    try {
      const pScore = this.sigmoid(features[0] * this.weights.P + this.bias);
      const bScore = this.sigmoid(features[1] * this.weights.B + this.bias);
      const tScore = this.sigmoid(features[2] * this.weights.T + this.bias);
      
      const total = pScore + bScore + tScore;
      if (total === 0) return { P: 33.3, B: 33.3, T: 33.3 };
      
      return {
        P: (pScore / total) * 100,
        B: (bScore / total) * 100,
        T: (tScore / total) * 100
      };
    } catch (e) {
      console.error('Logistic regression prediction error:', e);
      return { P: 33.3, B: 33.3, T: 33.3 };
    }
  }

  updateAccuracy(prediction, actual) {
    this.predictions.total++;
    if (prediction === actual) this.predictions.correct++;
  }

  getAccuracy() {
    return this.predictions.total > 0 ? 
      (this.predictions.correct / this.predictions.total) * 100 : 0;
  }
}

class EnsembleModel {
  constructor() {
    this.models = {
      knn: new SimpleKNN(5),
      logistic: new SimpleLogisticRegression()
    };
    this.weights = { knn: 0.5, logistic: 0.5 };
    this.predictions = { correct: 0, total: 0 };
  }

  train(features, label) {
    if (!features || !label) return;
    
    try {
      this.models.knn.train([features], [label]);
      this.models.logistic.trainOne(features, label);
      
      const knnAcc = this.models.knn.getAccuracy();
      const logisticAcc = this.models.logistic.getAccuracy();
      
      const totalAcc = knnAcc + logisticAcc;
      if (totalAcc > 0) {
        this.weights.knn = knnAcc / totalAcc;
        this.weights.logistic = logisticAcc / totalAcc;
      }
    } catch (e) {
      console.error('Ensemble training error:', e);
    }
  }

  predict(features) {
    if (!features) return { P: 33.3, B: 33.3, T: 33.3 };
    
    try {
      const knnPred = this.models.knn.predict(features);
      const logisticPred = this.models.logistic.predict(features);
      
      return {
        P: (knnPred.P * this.weights.knn + logisticPred.P * this.weights.logistic),
        B: (knnPred.B * this.weights.knn + logisticPred.B * this.weights.logistic),
        T: (knnPred.T * this.weights.knn + logisticPred.T * this.weights.logistic)
      };
    } catch (e) {
      console.error('Ensemble prediction error:', e);
      return { P: 33.3, B: 33.3, T: 33.3 };
    }
  }

  updateAccuracy(prediction, actual) {
    this.predictions.total++;
    if (prediction === actual) this.predictions.correct++;
    
      this.models.knn.updateAccuracy(prediction, actual);
      this.models.logistic.updateAccuracy(prediction, actual);
  }

  getAccuracy() {
    return this.predictions.total > 0 ? 
      (this.predictions.correct / this.predictions.total) * 100 : 0;
  }
}

class BaccaratMachineLearning {
  constructor() {
    this.models = {
      knn: new SimpleKNN(5),
      logistic: new SimpleLogisticRegression(),
      ensemble: new EnsembleModel()
    };
    this.activeModel = 'ensemble';
    this.featureHistory = [];
    this.mlPredictions = [];
    this.isEnabled = true;
    this.trainingData = [];
  }

  extractFeatures(rounds, windowSize) {
    if (!rounds || rounds.length < windowSize) return null;
    
    try {
      const recent = rounds.slice(-windowSize);
      const pRatio = recent.filter(r => r === 'P').length / windowSize;
      const bRatio = recent.filter(r => r === 'B').length / windowSize;
      const tRatio = recent.filter(r => r === 'T').length / windowSize;
      
      let pStreak = 0, bStreak = 0;
      for (let i = recent.length - 1; i >= 0; i--) {
        if (recent[i] === 'P') pStreak++; else break;
      }
      for (let i = recent.length - 1; i >= 0; i--) {
        if (recent[i] === 'B') bStreak++; else break;
      }
      
      const volatility = this.calculateVolatility(recent);
      const patternType = this.getPatternType(recent);
      
      return [
        pRatio, bRatio, tRatio,
        pStreak / windowSize,
        bStreak / windowSize,
        recent[recent.length - 1] === recent[recent.length - 2] ? 1 : 0,
        volatility,
        patternType
      ];
    } catch (e) {
      console.error('Feature extraction error:', e);
      return null;
    }
  }

  calculateVolatility(rounds) {
    if (rounds.length < 2) return 0;
    let changes = 0;
    for (let i = 1; i < rounds.length; i++) {
      if (rounds[i] !== rounds[i-1]) changes++;
    }
    return changes / (rounds.length - 1);
  }

  getPatternType(rounds) {
    if (rounds.length < 3) return 0;
    const lastThree = rounds.slice(-3);
    if (lastThree[0] === lastThree[1] && lastThree[1] === lastThree[2]) return 1;
    if (lastThree[0] !== lastThree[1] && lastThree[1] !== lastThree[2]) return 2;
    return 0;
  }

  updateModel(rounds, windowSize, actualResult) {
    if (!this.isEnabled || !rounds || !actualResult) return;
    
    const features = this.extractFeatures(rounds, windowSize);
    if (!features) return;
    
    try {
      this.featureHistory.push({ features, label: actualResult, timestamp: Date.now() });
      
      if (this.featureHistory.length > 100) {
        this.featureHistory = this.featureHistory.slice(-100);
      }
      
      if (this.featureHistory.length > 5) {
        const trainingBatch = this.featureHistory.slice(-10);
        
        trainingBatch.forEach(({ features, label }) => {
          if (features && label) {
            this.models.knn.train([features], [label]);
            this.models.logistic.trainOne(features, label);
            this.models.ensemble.train(features, label);
          }
        });
      }
    } catch (e) {
      console.error('ML update error:', e);
    }
  }

  predict(rounds, windowSize) {
    if (!this.isEnabled || !rounds || rounds.length < windowSize) {
      return null;
    }
    
    const features = this.extractFeatures(rounds, windowSize);
    if (!features) return null;
    
    try {
      let prediction;
      switch(this.activeModel) {
        case 'knn':
          prediction = this.models.knn.predict(features);
          break;
        case 'logistic':
          prediction = this.models.logistic.predict(features);
          break;
        case 'ensemble':
        default:
          prediction = this.models.ensemble.predict(features);
          break;
      }
      
      if (prediction) {
        this.mlPredictions.push({
          features,
          prediction: this.getPredictedClass(prediction),
          timestamp: Date.now()
        });
        
        if (this.mlPredictions.length > 50) {
          this.mlPredictions = this.mlPredictions.slice(-50);
        }
      }
      
      return prediction;
    } catch (e) {
      console.error('ML prediction error:', e);
      return null;
    }
  }

  getPredictedClass(prediction) {
    if (!prediction) return null;
    const entries = Object.entries(prediction);
    if (entries.length === 0) return null;
    
    entries.sort((a, b) => b[1] - a[1]);
    return entries[0][0];
  }

  getModelAccuracy(modelName) {
    const model = this.models[modelName];
    return model && model.getAccuracy ? model.getAccuracy() : 0;
  }

  getTrainingDataCount() {
    return this.featureHistory.length;
  }

  getMLWeight() {
    const minWeight = 0.1;
    const maxWeight = 0.6;
    const dataPoints = this.getTrainingDataCount();
    const weight = minWeight + (maxWeight - minWeight) * (dataPoints / 100);
    return Math.min(weight, maxWeight);
  }

  enable() {
    this.isEnabled = true;
  }

  disable() {
    this.isEnabled = false;
  }

  setActiveModel(modelName) {
    if (this.models[modelName]) {
      this.activeModel = modelName;
    }
  }

  reset() {
    this.models = {
      knn: new SimpleKNN(5),
      logistic: new SimpleLogisticRegression(),
      ensemble: new EnsembleModel()
    };
    this.featureHistory = [];
    this.mlPredictions = [];
    this.trainingData = [];
  }

  getStats() {
    return {
      trainingCount: this.featureHistory.length,
      accuracy: this.getModelAccuracy(this.activeModel),
      weight: this.getMLWeight(),
      isEnabled: this.isEnabled,
      activeModel: this.activeModel
    };
  }
}

// ========== ูุธุงู ุญูุธ ุงูุจูุงูุงุช ==========

class DataManager {
  constructor() {
    this.storageKey = 'baccaratPro_v4';
    this.autoSaveInterval = null;
    this.lastSaveTime = null;
    this.isSaving = false;
  }

  saveAllData() {
    if (this.isSaving) return false;
    
    this.isSaving = true;
    try {
      const saveData = {
        state: {
          rounds: state.rounds,
          count: state.count,
          win: state.win,
          loss: state.loss,
          windowSize: state.windowSize,
          analysisMode: state.analysisMode,
          confidenceThreshold: state.confidenceThreshold,
          timeWeighting: state.timeWeighting,
          useML: state.useML,
          mlModel: state.mlModel,
          modelPerformance: state.modelPerformance,
          previousPredictions: state.previousPredictions,
          lastPrediction: state.lastPrediction
        },
        history: {
          accuracyHistory: state.accuracyHistory,
          predictionsHistory: state.predictionsHistory
        },
        mlData: {
          featureHistory: state.ml.featureHistory,
          mlPredictions: state.ml.mlPredictions,
          activeModel: state.ml.activeModel,
          isEnabled: state.ml.isEnabled
        },
        coachData: {
          mentalState: state.aiCoach.mentalState,
          coachStats: state.aiCoach.coachStats,
          sessionStart: state.aiCoach.sessionStart,
          entrySignals: state.aiCoach.entrySignals
        },
        meta: {
          version: '4.0',
          lastSave: new Date().toISOString(),
          totalRounds: state.rounds.length,
          sessionStart: this.getSessionStartTime()
        }
      };

      localStorage.setItem(this.storageKey, JSON.stringify(saveData));
      this.lastSaveTime = new Date();
      this.updateSaveStatus(true);
      return true;
    } catch (e) {
      console.error('Error saving data:', e);
      this.updateSaveStatus(false, 'ุฎุทุฃ ูู ุงูุญูุธ');
      return false;
    } finally {
      this.isSaving = false;
    }
  }

  loadAllData() {
    try {
      const saved = localStorage.getItem(this.storageKey);
      if (!saved) {
        this.updateSaveStatus(true, 'ุจุฏูู ุจูุงูุงุช ุณุงุจูุฉ');
        return false;
      }

      const data = JSON.parse(saved);
      
      // ุชุญููู ุจูุงูุงุช ุงูุญุงูุฉ
      if (data.state) {
        state.rounds = Array.isArray(data.state.rounds) ? data.state.rounds : [];
        state.count = data.state.count || { P: 0, B: 0, T: 0 };
        state.win = data.state.win || { P: 0, B: 0, T: 0 };
        state.loss = data.state.loss || { P: 0, B: 0, T: 0 };
        state.windowSize = data.state.windowSize || 8;
        state.analysisMode = data.state.analysisMode || 'advanced';
        state.confidenceThreshold = data.state.confidenceThreshold || 45;
        state.timeWeighting = data.state.timeWeighting || 'linear';
        state.useML = data.state.useML !== false;
        state.mlModel = data.state.mlModel || 'ensemble';
        state.modelPerformance = data.state.modelPerformance || { basic: 0, advanced: 0, pattern: 0, ml: 0 };
        state.previousPredictions = data.state.previousPredictions || { P: 0, B: 0, T: 0 };
        state.lastPrediction = data.state.lastPrediction || null;
      }

      // ุชุญููู ุงูุชุงุฑูุฎ
      if (data.history) {
        state.accuracyHistory = Array.isArray(data.history.accuracyHistory) ? data.history.accuracyHistory : [];
        state.predictionsHistory = Array.isArray(data.history.predictionsHistory) ? data.history.predictionsHistory : [];
      }

      // ุชุญููู ML
      if (data.mlData) {
        state.ml.featureHistory = Array.isArray(data.mlData.featureHistory) ? data.mlData.featureHistory : [];
        state.ml.mlPredictions = Array.isArray(data.mlData.mlPredictions) ? data.mlData.mlPredictions : [];
        state.ml.activeModel = data.mlData.activeModel || 'ensemble';
        state.ml.isEnabled = data.mlData.isEnabled !== false;
        
        // ุฅุนุงุฏุฉ ุชุฏุฑูุจ ุงูููุงุฐุฌ
        setTimeout(() => {
          if (state.ml.featureHistory.length > 0) {
            state.ml.featureHistory.forEach((item, index) => {
              if (index > 0 && item.features && item.label) {
                state.ml.models.knn.train([item.features], [item.label]);
                state.ml.models.logistic.trainOne(item.features, item.label);
                state.ml.models.ensemble.train(item.features, item.label);
              }
            });
          }
        }, 500);
      }

      // ุชุญููู ุจูุงูุงุช ุงููุณุงุนุฏ
      if (data.coachData) {
        state.aiCoach.mentalState = data.coachData.mentalState || state.aiCoach.mentalState;
        state.aiCoach.coachStats = data.coachData.coachStats || state.aiCoach.coachStats;
        state.aiCoach.entrySignals = Array.isArray(data.coachData.entrySignals) ? data.coachData.entrySignals : [];
        
        if (data.coachData.sessionStart) {
          state.aiCoach.sessionStart = new Date(data.coachData.sessionStart);
        }
      }

      this.lastSaveTime = new Date();
      this.updateSaveStatus(true, 'ุชู ุชุญููู ุงูุจูุงูุงุช');
      return true;
    } catch (e) {
      console.error('Error loading data:', e);
      this.updateSaveStatus(false, 'ุฎุทุฃ ูู ุงูุชุญููู');
      return false;
    }
  }

  exportData() {
    try {
      const exportData = {
        state: {
          rounds: state.rounds,
          count: state.count,
          win: state.win,
          loss: state.loss,
          windowSize: state.windowSize
        },
        ml: {
          featureHistory: state.ml.featureHistory,
          trainingCount: state.ml.getTrainingDataCount()
        },
        coach: state.aiCoach.getStats(),
        meta: {
          exportDate: new Date().toISOString(),
          version: 'AYOUB_BACCARAT_PRO_v4.0',
          totalRounds: state.rounds.length
        }
      };

      const dataStr = JSON.stringify(exportData, null, 2);
      const dataBlob = new Blob([dataStr], { type: 'application/json' });
      const url = URL.createObjectURL(dataBlob);
      
      const a = document.createElement('a');
      a.href = url;
      a.download = `baccarat_data_${new Date().toISOString().split('T')[0]}.json`;
      document.body.appendChild(a);
      a.click();
      
      setTimeout(() => {
        document.body.removeChild(a);
        URL.revokeObjectURL(url);
      }, 100);
      
      alert(`โ ุชู ุชุตุฏูุฑ ${state.rounds.length} ุฌููุฉ ู ${state.ml.featureHistory.length} ุนููุฉ ุชุฏุฑูุจ`);
    } catch (e) {
      alert('โ ุฎุทุฃ ูู ุชุตุฏูุฑ ุงูุจูุงูุงุช: ' + e.message);
    }
  }

  importData(file) {
    const reader = new FileReader();
    
    reader.onload = (e) => {
      try {
        const importedData = JSON.parse(e.target.result);
        
        if (!confirm(`ูู ุชุฑูุฏ ุงุณุชูุฑุงุฏ ${importedData.state?.rounds?.length || 0} ุฌููุฉุ\nุณูุชู ูุณุญ ุงูุจูุงูุงุช ุงูุญุงููุฉ.`)) {
          return;
        }

        // ูุณุญ ุงูุจูุงูุงุช ุงูุญุงููุฉ
        resetAll();
        
        // ุชุญููู ุงูุจูุงูุงุช ุงููุณุชูุฑุฏุฉ
        if (importedData.state) {
          state.rounds = Array.isArray(importedData.state.rounds) ? importedData.state.rounds : [];
          state.count = importedData.state.count || { P: 0, B: 0, T: 0 };
          state.win = importedData.state.win || { P: 0, B: 0, T: 0 };
          state.loss = importedData.state.loss || { P: 0, B: 0, T: 0 };
          state.windowSize = importedData.state.windowSize || 8;
          
          // ุญุณุงุจ ุงูุฅุญุตุงุกุงุช ูู ุงูุฌููุงุช
          state.rounds.forEach(round => {
            state.count[round]++;
          });
        }

        if (importedData.ml && Array.isArray(importedData.ml.featureHistory)) {
          state.ml.featureHistory = importedData.ml.featureHistory;
          
          // ุฅุนุงุฏุฉ ุชุฏุฑูุจ ML
          setTimeout(() => {
            if (state.ml.featureHistory.length > 0) {
              state.ml.featureHistory.forEach((item, index) => {
                if (index > 0 && item.features && item.label) {
                  state.ml.models.knn.train([item.features], [item.label]);
                  state.ml.models.logistic.trainOne(item.features, item.label);
                  state.ml.models.ensemble.train(item.features, item.label);
                }
              });
            }
          }, 500);
        }

        // ุชุญุฏูุซ ุงููุงุฌูุฉ
        updateAll();
        updateMLStatus();
        updateCoachDisplay();
        this.saveAllData();
        
        alert(`โ ุชู ุงุณุชูุฑุงุฏ ${state.rounds.length} ุฌููุฉ ุจูุฌุงุญ!`);
      } catch (error) {
        alert('โ ุฎุทุฃ ูู ุชูุณูู ุงูููู: ' + error.message);
      }
    };
    
    reader.onerror = () => {
      alert('โ ุฎุทุฃ ูู ูุฑุงุกุฉ ุงูููู');
    };
    
    reader.readAsText(file);
  }

  clearAllData() {
    if (confirm('โ๏ธ ูู ุฃูุช ูุชุฃูุฏ ูู ูุณุญ ุฌููุน ุงูุจูุงูุงุชุ\nูุง ูููู ุงูุชุฑุงุฌุน ุนู ูุฐุง ุงูุฅุฌุฑุงุก.')) {
      localStorage.removeItem(this.storageKey);
      resetAll();
      alert('โ ุชู ูุณุญ ุฌููุน ุงูุจูุงูุงุช.');
    }
  }

  startAutoSave(intervalSeconds = 30) {
    if (this.autoSaveInterval) {
      clearInterval(this.autoSaveInterval);
    }
    
    this.autoSaveInterval = setInterval(() => {
      if (state.rounds.length > 0 && !this.isSaving) {
        this.saveAllData();
      }
    }, intervalSeconds * 1000);
    
    // ุญูุธ ุนูุฏ ุฅุบูุงู ุงูุตูุญุฉ
    window.addEventListener('beforeunload', () => {
      if (!this.isSaving) {
        this.saveAllData();
      }
    });
  }

  updateSaveStatus(success, message = '') {
    const statusEl = document.getElementById('autoSaveStatus');
    if (statusEl) {
      if (success) {
        const timeStr = this.lastSaveTime ? 
          `๐พ ุขุฎุฑ ุญูุธ: ${this.lastSaveTime.toLocaleTimeString('ar-EG', {hour: '2-digit', minute:'2-digit'})}` : 
          '๐พ ุงูุญูุธ ุงูุชููุงุฆู ููุนู';
        statusEl.textContent = message || timeStr;
        statusEl.style.color = '#38b000';
      } else {
        statusEl.textContent = message || 'โ ุฎุทุฃ ูู ุงูุญูุธ';
        statusEl.style.color = '#ff006e';
      }
    }
  }

  getSessionStartTime() {
    const saved = localStorage.getItem('session_start');
    if (!saved) {
      const startTime = new Date().toISOString();
      localStorage.setItem('session_start', startTime);
      return startTime;
    }
    return saved;
  }

  updateDataStats() {
    const statsEl = document.getElementById('dataStats');
    if (statsEl) {
      statsEl.textContent = `${state.rounds.length} ุฌููุฉ โข ${state.ml.featureHistory.length} ุนููุฉ ุชุฏุฑูุจ`;
    }
  }
}

// ========== ุงูุญุงูุฉ ุงูุนุงูุฉ ููุชุทุจูู ==========
const state = {
  rounds: [],
  windowSize: 8,
  count: { P: 0, B: 0, T: 0 },
  win: { P: 0, B: 0, T: 0 },
  loss: { P: 0, B: 0, T: 0 },
  lastPrediction: null,
  accuracyHistory: [],
  predictionsHistory: [],
  analysisMode: 'advanced',
  confidenceThreshold: 45,
  timeWeighting: 'linear',
  modelPerformance: { basic: 0, advanced: 0, pattern: 0, ml: 0 },
  previousPredictions: { P: 0, B: 0, T: 0 },
  ml: new BaccaratMachineLearning(),
  useML: true,
  mlModel: 'ensemble',
  aiCoach: new AICoach()
};

// ุฅูุดุงุก ูุฏูุฑ ุงูุจูุงูุงุช
const dataManager = new DataManager();

// ========== ุงููุธุงุฆู ุงููุณุงุนุฏุฉ ==========
const el = id => document.getElementById(id);

// ========== ูุธุงุฆู ุงููุณุงุนุฏ ุงูุฐูู ==========

function showCoachModal() {
  el('coachModal').classList.add('active');
  updateCoachDisplay();
}

function hideCoachModal() {
  el('coachModal').classList.remove('active');
}

function updateCoachDisplay() {
  const coachStats = state.aiCoach.getStats();
  
  // ุชุญุฏูุซ ุงูุฅุญุตุงุฆูุงุช
  el('coachWinRate').textContent = coachStats.coachStats.winRate.toFixed(1) + '%';
  el('coachStreak').textContent = coachStats.coachStats.currentStreak;
  el('coachRiskLevel').textContent = coachStats.coachStats.riskLevel;
  el('coachSessionTime').textContent = coachStats.sessionTime;
  
  // ุชุญุฏูุซ ุญุงูุฉ ุงูุนูููุฉ
  el('mentalFocus').textContent = coachStats.mentalState.focus + '%';
  el('mentalPressure').textContent = coachStats.mentalState.pressure + '%';
  el('mentalDecisions').textContent = coachStats.mentalState.correctDecisions;
  el('mentalProgress').style.width = coachStats.mentalState.focus + '%';
  
  // ุชุญุฏูุซ ุญุงูุฉ ุงูุนูููุฉ ุงููุตูุฉ
  let mentalStatus = 'ุฌูุฏุฉ';
  if (coachStats.mentalState.focus < 40) mentalStatus = 'ุถุนููุฉ';
  else if (coachStats.mentalState.pressure > 70) mentalStatus = 'ูุชูุชุฑุฉ';
  el('mentalStatus').textContent = `ุญุงูุฉ ุนูููุฉ: ${mentalStatus}`;
  
  // ุชุญุฏูุซ ููู ุดุฑูุท ุงูุชูุฏู
  const progressBar = el('mentalProgress');
  if (coachStats.mentalState.focus >= 70) {
    progressBar.style.background = 'linear-gradient(90deg, #38b000, #d4af37)';
  } else if (coachStats.mentalState.focus >= 40) {
    progressBar.style.background = 'linear-gradient(90deg, #d4af37, #ff006e)';
  } else {
    progressBar.style.background = 'linear-gradient(90deg, #ff006e, #cc0058)';
  }
  
  // ุชุญููู ุงููุถุน ุงูุญุงูู ูุนุฑุถ ุงูุฅุดุงุฑุฉ
  const predictions = {
    P: parseFloat(el('predPctP').textContent) || 0,
    B: parseFloat(el('predPctB').textContent) || 0,
    T: parseFloat(el('predPctT').textContent) || 0
  };
  
  const stats = {
    lossStreak: calculateLossStreak(),
    winStreak: calculateWinStreak(),
    totalRounds: state.rounds.length
  };
  
  const analysis = state.aiCoach.analyzeSituation(state.rounds, predictions, stats);
  
  // ุชุญุฏูุซ ุฅุดุงุฑุฉ ุงูุฏุฎูู/ุงูุฎุฑูุฌ
  const signalElement = el('currentSignal');
  const reasonElement = el('signalReason');
  
  signalElement.className = 'entry-signal ';
  if (analysis.signal === 'entry') {
    signalElement.classList.add('signal-entry');
    signalElement.textContent = 'ุฏุฎูู ๐ฏ';
  } else if (analysis.signal === 'exit') {
    signalElement.classList.add('signal-exit');
    signalElement.textContent = 'ุฎุฑูุฌ โ';
  } else {
    signalElement.classList.add('signal-wait');
    signalElement.textContent = 'ุงูุชุธุงุฑ ๐';
  }
  
  reasonElement.textContent = analysis.reason;
  
  // ุชุญุฏูุซ ุงููุตุงุฆุญ
  const adviceList = el('coachAdvice');
  adviceList.innerHTML = '';
  analysis.advice.forEach(advice => {
    const li = document.createElement('li');
    li.textContent = advice;
    adviceList.appendChild(li);
  });
  
  // ุชุญุฏูุซ ุญุงูุฉ ุงููุณุงุนุฏ ูู ุงูุฒุฑ
  const coachIndicator = document.querySelector('.coach-status-indicator');
  if (state.aiCoach.isActive) {
    coachIndicator.classList.add('coach-status-active');
    coachIndicator.classList.remove('coach-status-inactive');
  } else {
    coachIndicator.classList.add('coach-status-inactive');
    coachIndicator.classList.remove('coach-status-active');
  }
}

function showDickyNotification(message) {
  const notification = el('dickyNotification');
  const messageElement = el('dickyMessage');
  
  messageElement.textContent = message;
  notification.style.display = 'block';
  
  // ุฅุฎูุงุก ุงูุฅุดุนุงุฑ ุจุนุฏ 5 ุซูุงูู
  setTimeout(() => {
    notification.classList.add('hide');
    setTimeout(() => {
      notification.style.display = 'none';
      notification.classList.remove('hide');
    }, 300);
  }, 5000);
}

function calculateLossStreak() {
  if (state.rounds.length < 2) return 0;
  
  let streak = 0;
  for (let i = state.rounds.length - 1; i >= 0; i--) {
    if (state.lastPrediction && state.rounds[i] !== state.lastPrediction) {
      streak++;
    } else {
      break;
    }
  }
  return streak;
}

function calculateWinStreak() {
  if (state.rounds.length < 2) return 0;
  
  let streak = 0;
  for (let i = state.rounds.length - 1; i >= 0; i--) {
    if (state.lastPrediction && state.rounds[i] === state.lastPrediction) {
      streak++;
    } else {
      break;
    }
  }
  return streak;
}

// ========== ุงููุธุงุฆู ุงูุฑุฆูุณูุฉ ==========

function init() {
  console.log('Initializing Baccarat Pro with AI Coach...');
  
  // ุชุญููู ุงูุจูุงูุงุช ุงููุญููุธุฉ
  dataManager.loadAllData();
  
  // ุฅุนุฏุงุฏ ุนูุงุตุฑ ุงููุงุฌูุฉ
  el('windowSize').value = state.windowSize;
  
  el('applyWindow').onclick = () => {
    const v = parseInt(el('windowSize').value);
    if (v >= 5 && v <= 15) {
      state.windowSize = v;
      updateAll();
      showToast(`ุชู ุชุบููุฑ ูุงูุฐุฉ ุงูุชุญููู ุฅูู ${v} ุฌููุงุช`);
    } else {
      showToast('ุงููุงูุฐุฉ ูุฌุจ ุฃู ุชููู ุจูู 5 ู 15', 'error');
    }
  };

  el('analysisMode').value = state.analysisMode;
  el('analysisMode').onchange = (e) => {
    state.analysisMode = e.target.value;
    updateAll();
    showToast(`ุชู ุชุบููุฑ ููุท ุงูุชุญููู ุฅูู ${getModeName(state.analysisMode)}`);
  };

  el('confidenceSensitivity').value = state.confidenceThreshold;
  el('confidenceSensitivity').oninput = (e) => {
    state.confidenceThreshold = parseInt(e.target.value);
    el('sensitivityValue').textContent = state.confidenceThreshold + '%';
    updateAll();
  };

  el('timeWeighting').value = state.timeWeighting;
  el('timeWeighting').onchange = (e) => {
    state.timeWeighting = e.target.value;
    updateAll();
    showToast(`ุชู ุชุบููุฑ ุงููุฑุฌุญุฉ ุงูุฒูููุฉ ุฅูู ${getWeightingName(state.timeWeighting)}`);
  };

  // ุฅุนุฏุงุฏุงุช ุชุนูู ุงูุขูุฉ
  el('mlToggle').checked = state.useML;
  el('mlToggle').onchange = (e) => {
    state.useML = e.target.checked;
    state.ml.isEnabled = state.useML;
    updateMLStatus();
    updateAll();
    showToast(`ุชุนูู ุงูุขูุฉ ${state.useML ? 'ููุนู' : 'ูุนุทู'}`);
  };

  el('mlModelSelect').value = state.mlModel;
  el('mlModelSelect').onchange = (e) => {
    state.mlModel = e.target.value;
    state.ml.setActiveModel(state.mlModel);
    updateMLStatus();
    updateAll();
    showToast(`ุชู ุชุบููุฑ ูููุฐุฌ ML ุฅูู ${getMLModelName(state.mlModel)}`);
  };

  // ุฃุฒุฑุงุฑ ุงูุฅุฏุฎุงู
  el('btnP').onclick = () => pushRound('P');
  el('btnB').onclick = () => pushRound('B');
  el('btnT').onclick = () => pushRound('T');
  el('btnUndo').onclick = undoRound;
  el('btnReset').onclick = resetAll;
  
  // ุฃุฒุฑุงุฑ ุงููุณุงุนุฏ ุงูุฐูู
  el('coachBtn').onclick = showCoachModal;
  el('quickCoachBtn').onclick = showCoachModal;
  el('closeCoach').onclick = hideCoachModal;
  el('coachAnalyzeBtn').onclick = () => {
    updateCoachDisplay();
    showToast('ุชู ุฅุฌุฑุงุก ุชุญููู ููุฑู ูู ุงููุณุงุนุฏ ุงูุฐูู');
  };
  el('coachResetBtn').onclick = () => {
    state.aiCoach.reset();
    updateCoachDisplay();
    showToast('ุชู ุฅุนุงุฏุฉ ุถุจุท ุงููุณุงุนุฏ ุงูุฐูู');
  };
  el('coachSettingsBtn').onclick = () => {
    showToast('ูุฑูุจูุง: ุฅุนุฏุงุฏุงุช ูุชูุฏูุฉ ูููุณุงุนุฏ ุงูุฐูู');
  };
  
  // ุฅุบูุงู ุงููุงูุฐุฉ ุนูุฏ ุงูููุฑ ุฎุงุฑุฌูุง
  el('coachModal').onclick = (e) => {
    if (e.target === el('coachModal')) {
      hideCoachModal();
    }
  };
  
  // ุฃุฒุฑุงุฑ ุงูุจูุงูุงุช
  el('btnExport').onclick = () => dataManager.exportData();
  el('btnImport').onclick = () => {
    const input = document.createElement('input');
    input.type = 'file';
    input.accept = '.json';
    input.onchange = (e) => {
      if (e.target.files && e.target.files[0]) {
        dataManager.importData(e.target.files[0]);
      }
    };
    input.click();
  };
  el('btnClearData').onclick = () => dataManager.clearAllData();
  
  // ุชุจุฏูู ุงููุถุน
  el('themeToggle').onclick = toggleTheme;
  
  // ุชุนููู ุงููุถุน ุงูุงูุชุฑุงุถู
  if (!document.documentElement.hasAttribute('data-theme')) {
    document.documentElement.setAttribute('data-theme', 'dark');
  }
  
  // ุจุฏุก ุงูุญูุธ ุงูุชููุงุฆู
  dataManager.startAutoSave(30);
  
  // ุชุญุฏูุซ ุงููุงุฌูุฉ
  updateAll();
  updateMLStatus();
  updateCoachDisplay();
  dataManager.updateDataStats();
  
  console.log('Initialization complete');
}

function toggleTheme() {
  const currentTheme = document.documentElement.getAttribute('data-theme');
  const newTheme = currentTheme === 'dark' ? 'light' : 'dark';
  document.documentElement.setAttribute('data-theme', newTheme);
  el('themeToggle').textContent = newTheme === 'dark' ? '๐' : '๐';
  updateAccuracyChart();
  showToast(`ุชู ุงูุชุจุฏูู ุฅูู ุงููุถุน ${newTheme === 'dark' ? 'ุงููููู' : 'ุงูููุงุฑู'}`);
}

function getModeName(mode) {
  const names = {
    basic: 'ุฃุณุงุณู',
    advanced: 'ูุชูุฏู',
    pattern: 'ุชุญููู ุงูุฃููุงุท',
    ml: 'ุชุนูู ุงูุขูุฉ'
  };
  return names[mode] || mode;
}

function getWeightingName(weighting) {
  const names = {
    none: 'ุจุฏูู',
    linear: 'ุฎุทู',
    exponential: 'ุฃุณูู'
  };
  return names[weighting] || weighting;
}

function getMLModelName(model) {
  const names = {
    knn: 'K-ุงูุฌูุฑุงู ุงูุฃูุฑุจ',
    logistic: 'ุงูุงูุญุฏุงุฑ ุงูููุฌุณุชู',
    ensemble: 'ุงููุฌูุน'
  };
  return names[model] || model;
}

function showToast(message, type = 'success') {
  // ุฅูุดุงุก ุนูุตุฑ ุงูุชูุณุช
  const toast = document.createElement('div');
  toast.textContent = message;
  toast.style.cssText = `
    position: fixed;
    top: 20px;
    right: 20px;
    background: ${type === 'error' ? '#ef4444' : '#10b981'};
    color: white;
    padding: 12px 20px;
    border-radius: 8px;
    z-index: 1000;
    box-shadow: 0 4px 12px rgba(0,0,0,0.3);
    animation: slideIn 0.3s ease-out;
  `;
  
  document.body.appendChild(toast);
  
  // ุฅุฒุงูุฉ ุงูุชูุณุช ุจุนุฏ 3 ุซูุงูู
  setTimeout(() => {
    toast.style.animation = 'slideOut 0.3s ease-in';
    setTimeout(() => {
      if (toast.parentNode) {
        document.body.removeChild(toast);
      }
    }, 300);
  }, 3000);
}

// ุฅุถุงูุฉ ุฃููููุดู ููุชูุณุช
const style = document.createElement('style');
style.textContent = `
@keyframes slideIn {
  from { transform: translateX(100%); opacity: 0; }
  to { transform: translateX(0); opacity: 1; }
}
@keyframes slideOut {
  from { transform: translateX(0); opacity: 1; }
  to { transform: translateX(100%); opacity: 0; }
}
`;
document.head.appendChild(style);

// ========== ุฎูุงุฑุฒููุงุช ุงูุชุญููู ==========

function frequencyAnalysis(rounds) {
  if (!rounds || rounds.length === 0) {
    return { P: 33.3, B: 33.3, T: 33.3 };
  }
  
  const counts = { P: 0, B: 0, T: 0 };
  rounds.forEach(x => {
    if (x in counts) counts[x]++;
  });
  
  const total = rounds.length;
  return {
    P: (counts.P / total) * 100,
    B: (counts.B / total) * 100,
    T: (counts.T / total) * 100
  };
}

function patternAnalysis(rounds) {
  if (!rounds || rounds.length < 3) {
    return { P: 0, B: 0, T: 0 };
  }

  const patterns = {};
  for (let i = 2; i < rounds.length; i++) {
    const pattern = rounds.slice(i-2, i).join('');
    const next = rounds[i];
    
    if (!patterns[pattern]) {
      patterns[pattern] = { P: 0, B: 0, T: 0, total: 0 };
    }
    
    if (next in patterns[pattern]) {
      patterns[pattern][next]++;
      patterns[pattern].total++;
    }
  }

  if (rounds.length >= 2) {
    const lastPattern = rounds.slice(-2).join('');
    const patternData = patterns[lastPattern];
    
    if (patternData && patternData.total >= 1) {
      return {
        P: (patternData.P / patternData.total) * 100,
        B: (patternData.B / patternData.total) * 100,
        T: (patternData.T / patternData.total) * 100
      };
    }
  }

  return { P: 0, B: 0, T: 0 };
}

function applyTimeWeighting(rounds, basePrediction) {
  if (state.timeWeighting === 'none' || !rounds || rounds.length < 2) {
    return basePrediction;
  }

  const n = rounds.length;
  let weightFactor = 1;
  
  if (state.timeWeighting === 'linear') {
    weightFactor = 0.8 + (0.4 * (1 / n));
  } else if (state.timeWeighting === 'exponential') {
    weightFactor = 0.7 + (0.6 * Math.pow(0.9, n));
  }

  return {
    P: basePrediction.P * weightFactor,
    B: basePrediction.B * weightFactor,
    T: basePrediction.T * weightFactor
  };
}

function enhancedPredict() {
  const n = Math.min(state.windowSize, state.rounds.length);
  const recent = state.rounds.slice(-n);
  
  if (recent.length === 0) {
    return { 
      P: 33.3, B: 33.3, T: 33.3, 
      final: 'โ',
      confidence: 0,
      model: 'basic',
      mlContribution: 0
    };
  }

  let basePrediction, patternBoost, finalPrediction;
  let modelUsed = state.analysisMode;
  let mlContribution = 0;

  switch(state.analysisMode) {
    case 'basic':
      basePrediction = frequencyAnalysis(recent);
      finalPrediction = basePrediction;
      break;
      
    case 'advanced':
      basePrediction = frequencyAnalysis(recent);
      patternBoost = patternAnalysis(recent);
      
      finalPrediction = {
        P: basePrediction.P * 0.7 + patternBoost.P * 0.3,
        B: basePrediction.B * 0.7 + patternBoost.B * 0.3,
        T: basePrediction.T * 0.7 + patternBoost.T * 0.3
      };
      break;
      
    case 'pattern':
      basePrediction = frequencyAnalysis(recent);
      patternBoost = patternAnalysis(recent);
      
      finalPrediction = {
        P: basePrediction.P * 0.4 + patternBoost.P * 0.6,
        B: basePrediction.B * 0.4 + patternBoost.B * 0.6,
        T: basePrediction.T * 0.4 + patternBoost.T * 0.6
      };
      break;
      
    case 'ml':
      basePrediction = frequencyAnalysis(recent);
      
      let mlPrediction = state.ml.predict(state.rounds, state.windowSize);
      if (!mlPrediction) {
        mlPrediction = { P: 33.3, B: 33.3, T: 33.3 };
      }
      
      const mlWeight = state.ml.getMLWeight();
      mlContribution = mlWeight * 100;
      
      finalPrediction = {
        P: basePrediction.P * (1 - mlWeight) + mlPrediction.P * mlWeight,
        B: basePrediction.B * (1 - mlWeight) + mlPrediction.B * mlWeight,
        T: basePrediction.T * (1 - mlWeight) + mlPrediction.T * mlWeight
      };
      break;
  }

  finalPrediction = applyTimeWeighting(recent, finalPrediction);

  const sum = finalPrediction.P + finalPrediction.B + finalPrediction.T;
  if (sum > 0) {
    finalPrediction.P = (finalPrediction.P / sum) * 100;
    finalPrediction.B = (finalPrediction.B / sum) * 100;
    finalPrediction.T = (finalPrediction.T / sum) * 100;
  }

  const entries = Object.entries(finalPrediction);
  const sorted = entries.sort((a, b) => b[1] - a[1]);
  
  const confidence = sorted[0][1] - (sorted[1] ? sorted[1][1] : 0);
  let final = sorted[0][0];
  
  if (sorted[0][1] < state.confidenceThreshold) {
    final = 'โ';
  }

  return {
    P: finalPrediction.P.toFixed(1),
    B: finalPrediction.B.toFixed(1),
    T: finalPrediction.T.toFixed(1),
    final,
    confidence: Math.min(100, Math.max(0, confidence * 2)),
    model: modelUsed,
    mlContribution: mlContribution.toFixed(1)
  };
}

function pushRound(r) {
  if (!['P', 'B', 'T'].includes(r)) return;
  
  const pred = enhancedPredict();
  state.lastPrediction = pred.final;
  
  state.ml.updateModel(state.rounds, state.windowSize, r);
  
  state.rounds.push(r);
  state.count[r]++;
  
  let wasCorrect = false;
  if (state.lastPrediction !== 'โ' && state.lastPrediction !== null) {
    wasCorrect = (r === state.lastPrediction);
    
    if (wasCorrect) {
      state.win[state.lastPrediction]++;
      state.modelPerformance[state.analysisMode] = (state.modelPerformance[state.analysisMode] || 0) + 1;
    } else {
      state.loss[state.lastPrediction] = (state.loss[state.lastPrediction] || 0) + 1;
    }
  }
  
  updateAccuracyData(r);
  
  // ุชุญุฏูุซ ุงููุณุงุนุฏ ุงูุฐูู
  state.aiCoach.updateMentalState(r, wasCorrect);
  
  const newPred = enhancedPredict();
  updatePredictionDisplay(newPred);
  showResult(r, newPred, wasCorrect);
  updateAll();
  updateCoachDisplay();
  dataManager.saveAllData();
  dataManager.updateDataStats();
  
  // ุฅุดุนุงุฑ ูู ุงููุณุงุนุฏ ุฅุฐุง ูุฒู ุงูุฃูุฑ
  if (!wasCorrect && calculateLossStreak() >= 3) {
    state.aiCoach.addNotification('โ๏ธ 3 ุฎุณุงุฆุฑ ูุชุชุงููุฉ! ููุช ุงูุชููู ูุงููุฑุงุฌุนุฉ.', 'warning');
  }
  
  // ุฅุดุนุงุฑ ุตูุชู ุจุณูุท
  playSound('click');
}

function undoRound() {
  if (state.rounds.length === 0) return;
  
  const lastRound = state.rounds.pop();
  state.count[lastRound] = Math.max(0, state.count[lastRound] - 1);
  
  if (state.rounds.length > 0) {
    const previousPrediction = enhancedPredict();
    if (lastRound === previousPrediction.final) {
      state.win[previousPrediction.final] = Math.max(0, state.win[previousPrediction.final] - 1);
      state.modelPerformance[state.analysisMode] = Math.max(0, state.modelPerformance[state.analysisMode] - 1);
    } else {
      state.loss[previousPrediction.final] = Math.max(0, state.loss[previousPrediction.final] - 1);
    }
  }
  
  if (state.accuracyHistory.length > 0) {
    state.accuracyHistory.pop();
    state.predictionsHistory.pop();
  }
  
  state.lastPrediction = null;
  
  // ุฅุนุงุฏุฉ ุชุฏุฑูุจ ML ูุน ุงูุจูุงูุงุช ุงููุญุฏุซุฉ
  state.ml.reset();
  for (let i = 0; i < state.rounds.length; i++) {
    if (i >= state.windowSize) {
      const recent = state.rounds.slice(i - state.windowSize, i);
      state.ml.updateModel(recent, state.windowSize, state.rounds[i]);
    }
  }
  
  updateAll();
  updateCoachDisplay();
  dataManager.saveAllData();
  dataManager.updateDataStats();
  playSound('undo');
}

function resetAll() {
  if (state.rounds.length === 0) return;
  
  if (!confirm('ูู ุชุฑูุฏ ุฅุนุงุฏุฉ ุชุนููู ุฌููุน ุงูุจูุงูุงุชุ')) return;
  
  state.rounds = [];
  state.count = { P: 0, B: 0, T: 0 };
  state.win = { P: 0, B: 0, T: 0 };
  state.loss = { P: 0, B: 0, T: 0 };
  state.lastPrediction = null;
  state.accuracyHistory = [];
  state.predictionsHistory = [];
  state.modelPerformance = { basic: 0, advanced: 0, pattern: 0, ml: 0 };
  state.previousPredictions = { P: 0, B: 0, T: 0 };
  
  state.ml.reset();
  state.aiCoach.reset();
  
  updateAll();
  updateCoachDisplay();
  dataManager.saveAllData();
  dataManager.updateDataStats();
  playSound('reset');
}

function playSound(type) {
  try {
    if (type === 'click') {
      const audio = new Audio('data:audio/wav;base64,UklGRigAAABXQVZFZm10IBIAAAABAAEARKwAAIhYAQACABAAZGF0YQQAAAAAAA==');
      audio.volume = 0.1;
      audio.play();
    }
  } catch (e) {
    // ุชุฌุงูู ุฃุฎุทุงุก ุงูุตูุช
  }
}

function updatePredictionDisplay(pred) {
  el('predPctP').textContent = pred.P + '%';
  el('predPctB').textContent = pred.B + '%';
  el('predPctT').textContent = pred.T + '%';
  
  updateTrendIndicators(pred);
  
  ['predP', 'predB', 'predT'].forEach(id => {
    el(id).classList.remove('active');
  });
  
  if (pred.final !== 'โ') {
    const finalEl = el('pred' + pred.final);
    if (finalEl) finalEl.classList.add('active');
  }
  
  let finalText = 'โ';
  if (pred.final === 'P') finalText = 'ูุงุนุจ';
  else if (pred.final === 'B') finalText = 'ูุตุฑูู';
  else if (pred.final === 'T') finalText = 'ุชุนุงุฏู';
  
  el('finalCard').textContent = finalText;
  
  el('mlContribution').textContent = pred.mlContribution > 0 ? 
    `๐ ูุณุงููุฉ ุชุนูู ุงูุขูุฉ: ${pred.mlContribution}%` : '';
  
  updateConfidenceMeter(pred.confidence);
  updateModelInfo(pred);
}

function updateTrendIndicators(pred) {
  const current = { 
    P: parseFloat(pred.P) || 0, 
    B: parseFloat(pred.B) || 0, 
    T: parseFloat(pred.T) || 0 
  };
  const previous = state.previousPredictions;
  
  ['P', 'B', 'T'].forEach(type => {
    const trendEl = el('predTrend' + type);
    if (!trendEl) return;
    
    if (previous[type] > 0) {
      const diff = current[type] - previous[type];
      if (diff > 2) trendEl.textContent = 'โ';
      else if (diff < -2) trendEl.textContent = 'โ';
      else trendEl.textContent = 'โ';
      trendEl.style.color = diff > 0 ? '#38b000' : diff < 0 ? '#ff006e' : '#bfb7a6';
    } else {
      trendEl.textContent = 'โ';
    }
  });
  
  state.previousPredictions = current;
}

function updateConfidenceMeter(confidence) {
  const fill = el('confidenceFill');
  const label = el('confidenceLabel');
  
  if (!fill || !label) return;
  
  fill.style.width = confidence + '%';
  
  if (confidence >= 70) {
    fill.className = 'confidence-fill high-confidence';
    label.textContent = 'ุซูุฉ ุนุงููุฉ';
    label.style.color = '#38b000';
  } else if (confidence >= 40) {
    fill.className = 'confidence-fill medium-confidence';
    label.textContent = 'ุซูุฉ ูุชูุณุทุฉ';
    label.style.color = '#d4af37';
  } else {
    fill.className = 'confidence-fill';
    label.textContent = 'ุซูุฉ ููุฎูุถุฉ';
    label.style.color = '#ff006e';
  }
}

function updateModelInfo(pred) {
  const modelEl = el('predModel');
  const modelInfoEl = el('modelInfo');
  const reasonEl = el('predictionReason');
  
  if (!modelEl || !modelInfoEl || !reasonEl) return;
  
  let modelName, modelClass, reason;
  
  switch(pred.model) {
    case 'basic':
      modelName = 'ุฃุณุงุณู';
      modelClass = 'badge-basic';
      reason = 'ูุนุชูุฏ ุนูู ุชุญููู ุงูุชุฑุฏุฏ ุงูุฃุณุงุณู';
      break;
    case 'advanced':
      modelName = 'ูุชูุฏู';
      modelClass = 'badge-advanced';
      reason = 'ูุฌูุน ุจูู ุชุญููู ุงูุชุฑุฏุฏ ูุงูุฃููุงุท';
      break;
    case 'pattern':
      modelName = 'ุงูุฃููุงุท';
      modelClass = 'badge-pattern';
      reason = 'ูุฑูุฒ ุนูู ุชุญููู ุงูุชุณูุณูุงุช ูุงูุฃููุงุท';
      break;
    case 'ml':
      modelName = 'ุชุนูู ุงูุขูุฉ';
      modelClass = 'badge-ml';
      reason = 'ูุณุชุฎุฏู ุฎูุงุฑุฒููุงุช ML ูุน ุงูุชุฏุฑูุจ ุงูุชููุงุฆู';
      break;
    default:
      modelName = 'ุฃุณุงุณู';
      modelClass = 'badge-basic';
      reason = 'ูุนุชูุฏ ุนูู ุชุญููู ุงูุชุฑุฏุฏ ุงูุฃุณุงุณู';
  }
  
  modelEl.textContent = modelName;
  modelEl.className = 'model-badge ' + modelClass;
  
  const efficiency = calculateModelEfficiency();
  modelInfoEl.textContent = `ุงููููุฐุฌ: ${modelName} - ุงูููุงุกุฉ: ${efficiency}%`;
  
  if (pred.final === 'โ') {
    reasonEl.textContent = 'ุนุฏู ููุงูุฉ ุงูุซูุฉ ููุชูุจุค (ุชุญุช ' + state.confidenceThreshold + '%)';
  } else {
    reasonEl.textContent = reason + ` - ุงูุซูุฉ: ${pred.confidence.toFixed(1)}%`;
  }
}

function calculateModelEfficiency() {
  const total = Object.values(state.modelPerformance).reduce((a, b) => a + b, 0);
  const current = state.modelPerformance[state.analysisMode] || 0;
  return total > 0 ? Math.round((current / total) * 100) : 0;
}

function showResult(r, pred, didWin) {
  const finalCard = el('finalCard');
  if (!finalCard) return;
  
  finalCard.classList.remove('win-effect', 'loss-effect');
  setTimeout(() => {
    finalCard.classList.add(didWin ? 'win-effect' : 'loss-effect');
  }, 10);
}

function updateMLStatus() {
  const trainingCount = state.ml.getTrainingDataCount();
  const mlWeight = state.ml.getMLWeight() * 100;
  const mlAccuracy = state.ml.getModelAccuracy(state.mlModel);
  
  el('mlTrainingCount').textContent = trainingCount;
  el('mlWeight').textContent = mlWeight.toFixed(0) + '%';
  el('mlAccuracy').textContent = mlAccuracy.toFixed(1) + '%';
  
  const statusEl = el('mlStatus');
  if (!statusEl) return;
  
  if (trainingCount < 5) {
    statusEl.innerHTML = '<span class="ml-training-indicator ml-not-trained"></span> ูุญุชุงุฌ ุงููุฒูุฏ ูู ุงูุจูุงูุงุช';
    statusEl.style.color = '#ff006e';
  } else if (trainingCount < 15) {
    statusEl.innerHTML = '<span class="ml-training-indicator ml-training"></span> ูุชุนูู...';
    statusEl.style.color = '#d4af37';
  } else {
    statusEl.innerHTML = '<span class="ml-training-indicator ml-training"></span> ุฌุงูุฒ ููุชูุจุค';
    statusEl.style.color = '#38b000';
  }
  
  el('mlOverallAccuracy').textContent = mlAccuracy.toFixed(1) + '%';
}

function updateAll() {
  renderStats();
  renderBigRoad();
  updatePredictionCounts();
  updateAccuracyStats();
  updateAccuracyChart();
  updatePatternInfo();
  updateMLStats();
  updateDataStatsDisplay();
}

function updateDataStatsDisplay() {
  dataManager.updateDataStats();
}

function updateMLStats() {
  const mlAccuracy = state.ml.getModelAccuracy(state.mlModel);
  el('mlOverallAccuracy').textContent = mlAccuracy.toFixed(1) + '%';
  
  // ุชุญุฏูุซ ุฏูุฉ ML ููู ููุน (ูุจุณุทุฉ)
  const mlOverall = mlAccuracy;
  el('pMLAccuracy').textContent = (mlOverall * 0.9).toFixed(1) + '%';
  el('bMLAccuracy').textContent = (mlOverall * 0.95).toFixed(1) + '%';
  el('tMLAccuracy').textContent = (mlOverall * 0.7).toFixed(1) + '%';
}

function renderStats() {
  el('pTotal').textContent = state.count.P;
  el('bTotal').textContent = state.count.B;
  el('tTotal').textContent = state.count.T;
  
  el('pWin').textContent = state.win.P;
  el('bWin').textContent = state.win.B;
  el('tWin').textContent = state.win.T;
  
  el('pLoss').textContent = state.loss.P;
  el('bLoss').textContent = state.loss.B;
  el('tLoss').textContent = state.loss.T;
  
  el('pPct').textContent = calculatePercentage(state.win.P, state.loss.P);
  el('bPct').textContent = calculatePercentage(state.win.B, state.loss.B);
  el('tPct').textContent = calculatePercentage(state.win.T, state.loss.T);
  
  el('pAccuracy').textContent = calculateAccuracy('P');
  el('bAccuracy').textContent = calculateAccuracy('B');
  el('tAccuracy').textContent = calculateAccuracy('T');
}

function calculatePercentage(win, loss) {
  const total = win + loss;
  return total > 0 ? ((win / total) * 100).toFixed(1) + '%' : '0%';
}

function calculateAccuracy(type) {
  const totalPredictions = state.predictionsHistory.filter(p => p.prediction === type).length;
  const correctPredictions = state.predictionsHistory.filter(p => p.prediction === type && p.correct).length;
  return totalPredictions > 0 ? ((correctPredictions / totalPredictions) * 100).toFixed(1) + '%' : '0%';
}

function renderBigRoad() {
  const canvas = el('bigRoad');
  if (!canvas) return;
  
  const ctx = canvas.getContext('2d');
  ctx.clearRect(0, 0, canvas.width, canvas.height);
  
  const size = 35;
  let x = 0, y = 0;
  const maxCols = Math.floor(canvas.width / size);
  
  for (let i = 0; i < state.rounds.length; i++) {
    const r = state.rounds[i];
    
    ctx.fillStyle = r === 'P' ? '#3a86ff' : r === 'B' ? '#ff006e' : '#38b000';
    ctx.fillRect(x * size, y * size, size - 2, size - 2);
    
    ctx.fillStyle = '#ffffff';
    ctx.font = 'bold 14px Inter';
    ctx.textAlign = 'center';
    ctx.textBaseline = 'middle';
    ctx.fillText((i+1).toString(), x * size + size/2, y * size + size/2);
    
    y++;
    if (y * size >= canvas.height) {
      y = 0;
      x++;
      if (x >= maxCols) break;
    }
  }
}

function updatePredictionCounts() {
  const pred = enhancedPredict();
  updatePredictionDisplay(pred);
}

function updatePatternInfo() {
  const infoEl = el('patternInfo');
  if (!infoEl) return;
  
  if (state.rounds.length < 3) {
    infoEl.textContent = 'ูุง ุชูุฌุฏ ุฃููุงุท ููุชุดูุฉ ุจุนุฏ';
    return;
  }
  
  const trend = calculateTrend(state.rounds);
  const recent = state.rounds.slice(-5);
  const pCount = recent.filter(r => r === 'P').length;
  const bCount = recent.filter(r => r === 'B').length;
  const tCount = recent.filter(r => r === 'T').length;
  
  let info = `ุงูุงุชุฌุงู: ${trend.direction === 'volatile' ? 'ูุชููุจ' : trend.direction === 'mixed' ? 'ูุฎุชูุท' : 'ูุณุชูุฑ'}`;
  info += ` | ุขุฎุฑ 5: ๐ต${pCount} ๐ด${bCount} ๐ข${tCount}`;
  
  infoEl.textContent = info;
}

function calculateTrend(rounds) {
  if (rounds.length < 2) return { direction: 'stable', strength: 0 };
  
  const changes = [];
  for (let i = 1; i < rounds.length; i++) {
    changes.push(rounds[i] === rounds[i-1] ? 0 : 1);
  }
  
  const changeRate = changes.reduce((a, b) => a + b, 0) / changes.length;
  return {
    direction: changeRate > 0.6 ? 'volatile' : changeRate > 0.4 ? 'mixed' : 'stable',
    strength: Math.abs(changeRate - 0.5) * 2
  };
}

function updateAccuracyData(actualResult) {
  if (state.lastPrediction && state.lastPrediction !== 'โ') {
    const isCorrect = state.lastPrediction === actualResult;
    state.predictionsHistory.push({
      prediction: state.lastPrediction,
      actual: actualResult,
      correct: isCorrect,
      model: state.analysisMode
    });
    
    const correctPredictions = state.predictionsHistory.filter(p => p.correct).length;
    const totalPredictions = state.predictionsHistory.length;
    const accuracy = totalPredictions > 0 ? (correctPredictions / totalPredictions) * 100 : 0;
    
    state.accuracyHistory.push(accuracy);
  }
}

function updateAccuracyStats() {
  if (state.accuracyHistory.length === 0) {
    el('currentAccuracy').textContent = '0%';
    el('bestAccuracy').textContent = '0%';
    el('averageAccuracy').textContent = '0%';
    return;
  }
  
  const currentAccuracy = state.accuracyHistory[state.accuracyHistory.length - 1];
  const bestAccuracy = Math.max(...state.accuracyHistory);
  const averageAccuracy = state.accuracyHistory.reduce((a, b) => a + b, 0) / state.accuracyHistory.length;
  
  el('currentAccuracy').textContent = currentAccuracy.toFixed(1) + '%';
  el('bestAccuracy').textContent = bestAccuracy.toFixed(1) + '%';
  el('averageAccuracy').textContent = averageAccuracy.toFixed(1) + '%';
}

function updateAccuracyChart() {
  const svg = el('accuracyChart');
  const tooltip = el('accuracyTooltip');
  if (!svg || !tooltip) return;
  
  svg.innerHTML = '';
  
  if (state.accuracyHistory.length < 2) return;
  
  const width = svg.clientWidth || 600;
  const height = svg.clientHeight || 80;
  const padding = 20;
  
  // ุฑุณู ุงูุดุจูุฉ
  for (let i = 0; i <= 100; i += 20) {
    const y = height - padding - (i / 100) * (height - 2 * padding);
    const line = document.createElementNS('http://www.w3.org/2000/svg', 'line');
    line.setAttribute('class', 'accuracy-grid');
    line.setAttribute('x1', padding);
    line.setAttribute('y1', y);
    line.setAttribute('x2', width - padding);
    line.setAttribute('y2', y);
    svg.appendChild(line);
    
    const text = document.createElementNS('http://www.w3.org/2000/svg', 'text');
    text.setAttribute('x', padding - 5);
    text.setAttribute('y', y + 4);
    text.setAttribute('text-anchor', 'end');
    text.setAttribute('fill', 'var(--muted)');
    text.setAttribute('font-size', '10px');
    text.textContent = i + '%';
    svg.appendChild(text);
  }
  
  // ุฑุณู ุงูุฎุท
  const path = document.createElementNS('http://www.w3.org/2000/svg', 'path');
  let pathData = '';
  
  state.accuracyHistory.forEach((accuracy, index) => {
    const x = padding + (index / (state.accuracyHistory.length - 1)) * (width - 2 * padding);
    const y = height - padding - (accuracy / 100) * (height - 2 * padding);
    
    if (index === 0) {
      pathData = `M ${x} ${y}`;
    } else {
      pathData += ` L ${x} ${y}`;
    }
    
    // ููุงุท ุชูุงุนููุฉ
    const point = document.createElementNS('http://www.w3.org/2000/svg', 'circle');
    point.setAttribute('class', 'accuracy-point');
    point.setAttribute('cx', x);
    point.setAttribute('cy', y);
    point.setAttribute('r', 3);
    
    point.addEventListener('mouseover', (e) => {
      const rect = svg.getBoundingClientRect();
      tooltip.style.left = (e.clientX - rect.left + 10) + 'px';
      tooltip.style.top = (e.clientY - rect.top - 30) + 'px';
      tooltip.textContent = `ุงูุฌููุฉ ${index + 1}: ${accuracy.toFixed(1)}%`;
      tooltip.style.opacity = '1';
    });
    
    point.addEventListener('mouseout', () => {
      tooltip.style.opacity = '0';
    });
    
    svg.appendChild(point);
  });
  
  path.setAttribute('d', pathData);
  path.setAttribute('class', 'accuracy-line');
  svg.appendChild(path);
}

// ุชููุฆุฉ ุงูุชุทุจูู ุนูุฏ ุชุญููู ุงูุตูุญุฉ
window.addEventListener('DOMContentLoaded', init);
</script>
</body>
</html>
