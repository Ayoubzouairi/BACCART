<!doctype html>
<html lang="ar">
<head>
<meta charset="utf-8">
<meta name="viewport" content="width=device-width,initial-scale=1">
<title>AYOUB BACCARAT PRO FULL - Ø§Ù„Ù†Ø³Ø®Ø© Ø§Ù„Ù…Ø­Ø³Ù†Ø© Ù…Ø¹ ØªØ­Ù„ÙŠÙ„ Ø§Ù„ÙÙŠØ¯ÙŠÙˆ</title>
<style>
@import url('https://fonts.googleapis.com/css2?family=Inter:wght@300;400;600;800&display=swap');
:root{--gold:#d4af37;--gold-2:#b8871d;--bg-dark:#070606;--card:#0f0e10;--muted:#bfb7a6;--player:#2d7ef7;--banker:#e03b3b;--tie:#28a745;}
:root[data-theme="light"]{--gold:#d4af37;--gold-2:#b8871d;--bg-dark:#f5f5f5;--card:#ffffff;--muted:#666666;--player:#2d7ef7;--banker:#e03b3b;--tie:#28a745;}
*{box-sizing:border-box}
body{font-family:Inter,sans-serif;margin:0;background:linear-gradient(180deg,var(--bg-dark),#0b0b0b);color:#fff;padding:18px;transition:background 0.3s, color 0.3s;}
:root[data-theme="light"] body{color:#333;}
.app{max-width:1200px;margin:0 auto}
.top{display:flex;align-items:center;justify-content:space-between;gap:12px;margin-bottom:14px}
.logo{font-weight:800;background:linear-gradient(90deg,var(--gold),#fff3b0);color:#000;padding:8px 12px;border-radius:12px;display:inline-block}
.subtitle{font-size:14px;color:var(--muted);margin-top:4px}
.controls{display:flex;gap:8px;align-items:center}
.card{background:linear-gradient(180deg,var(--card),#0b0b0b);border-radius:12px;padding:12px;box-shadow:0 8px 30px rgba(0,0,0,0.6);border:1px solid rgba(212,175,55,0.08)}
:root[data-theme="light"] .card{background:linear-gradient(180deg,var(--card),#f0f0f0);box-shadow:0 8px 30px rgba(0,0,0,0.1);border:1px solid rgba(0,0,0,0.05)}
.layout{display:flex;gap:12px}
.left{width:360px;display:flex;flex-direction:column;gap:10px}
.right{flex:1;display:flex;flex-direction:column;gap:12px}
.panel{padding:10px}
.row{display:flex;gap:8px;align-items:center;margin-top:8px}
input[type=number], select{background:rgba(255,255,255,0.1);border:2px solid rgba(255,255,255,0.3);padding:10px;border-radius:8px;color:#fff;font-weight:600;font-size:14px;width:100%}
:root[data-theme="light"] input[type=number], :root[data-theme="light"] select{background:rgba(255,255,255,0.9);border:2px solid rgba(0,0,0,0.2);color:#333;}
.btn{padding:12px 16px;border-radius:8px;border:0;color:#fff;cursor:pointer;font-weight:600;font-size:16px;transition:all 0.3s}
.btn:hover{transform:translateY(-2px);box-shadow:0 4px 12px rgba(0,0,0,0.3)}
.btn.gold{background:linear-gradient(90deg,var(--gold),var(--gold-2));color:#000;font-weight:700;box-shadow:0 6px 20px rgba(212,175,55,0.3)}

/* Ø£Ù„ÙˆØ§Ù† ÙˆØ§Ø¶Ø­Ø© Ù„Ù„ÙˆØ¶Ø¹ Ø§Ù„Ù„ÙŠÙ„ÙŠ */
.btn.player{background:linear-gradient(135deg, #3a86ff, #2667cc); color:white; border:2px solid #3a86ff;}
.btn.banker{background:linear-gradient(135deg, #ff006e, #cc0058); color:white; border:2px solid #ff006e;}
.btn.tie{background:linear-gradient(135deg, #38b000, #2c8a00); color:white; border:2px solid #38b000;}

/* Ø£Ù„ÙˆØ§Ù† Ø§Ù„ÙˆØ¶Ø¹ Ø§Ù„Ù†Ù‡Ø§Ø±ÙŠ */
:root[data-theme="light"] .btn.player{background:linear-gradient(135deg, #2d7ef7, #1a67d8); color:white;}
:root[data-theme="light"] .btn.banker{background:linear-gradient(135deg, #e03b3b, #c53232); color:white;}
:root[data-theme="light"] .btn.tie{background:linear-gradient(135deg, #28a745, #218838); color:white;}

:root[data-theme="light"] .btn{background:rgba(0,0,0,0.1);color:#333; border:1px solid rgba(0,0,0,0.1)}

.small{font-size:13px;color:var(--muted)}
.muted{color:var(--muted);font-size:12px}
.pattern-list{list-style:none;padding:6px;margin:6px 0 0 0;max-height:200px;overflow:auto}
.pattern-list li{padding:8px;border-radius:8px;margin-bottom:6px;background:linear-gradient(180deg,rgba(255,255,255,0.02),transparent);display:flex;justify-content:space-between;align-items:center}
:root[data-theme="light"] .pattern-list li{background:linear-gradient(180deg,rgba(0,0,0,0.02),transparent)}
.section-title{font-weight:700;margin-bottom:6px;color:var(--gold)}
.stat-table{width:100%;border-collapse:collapse}
.stat-table th,.stat-table td{border:1px solid rgba(255,255,255,0.05);padding:6px;text-align:center}
:root[data-theme="light"] .stat-table th, :root[data-theme="light"] .stat-table td{border:1px solid rgba(0,0,0,0.05)}
.stat-table th{background:rgba(212,175,55,0.1);font-weight:600}
.player{color:#3a86ff;font-weight:700}
.banker{color:#ff006e;font-weight:700}
.tie{color:#38b000;font-weight:700}
.pred-head{display:flex;justify-content:space-between;align-items:center}
.final{font-size:22px;font-weight:800;text-align:center;padding:12px;background:linear-gradient(90deg,rgba(212,175,55,0.06),transparent);border-radius:10px}
:root[data-theme="light"] .final{background:linear-gradient(90deg,rgba(212,175,55,0.1),transparent)}
.foot{display:flex;justify-content:space-between;align-items:center;margin-top:14px}
.credits{opacity:0.85}
canvas{border-radius:10px;background:#0f0e10}
:root[data-theme="light"] canvas{background:#f0f0f0}
.color-legend{display:flex;gap:15px;justify-content:center;margin-bottom:10px;font-size:14px}
.color-legend span{padding:4px 8px;border-radius:6px; font-weight:600;}
.prediction-cards{display:flex;gap:10px;justify-content:center;margin:10px 0}
.pred-card{padding:10px;border-radius:8px;text-align:center;min-width:80px; font-weight:600;}
.pred-card.active{transform:scale(1.1);border:2px solid var(--gold); box-shadow:0 4px 15px rgba(212,175,55,0.4);}
.win-effect{animation:winPulse 0.5s ease-in-out}
.loss-effect{animation:lossShake 0.5s ease-in-out}
@keyframes winPulse{0%{transform:scale(1)}50%{transform:scale(1.2)}100%{transform:scale(1)}}
@keyframes lossShake{0%,100%{transform:translateX(0)}25%{transform:translateX(-5px)}75%{transform:translateX(5px)}}
.analysis-result{margin-top:10px;padding:10px;background:rgba(255,255,255,0.03);border-radius:8px;text-align:center}
:root[data-theme="light"] .analysis-result{background:rgba(0,0,0,0.03)}
.theme-toggle{background:transparent;border:none;font-size:24px;cursor:pointer;padding:5px;border-radius:50%;transition:background 0.3s}
.theme-toggle:hover{background:rgba(255,255,255,0.1)}
:root[data-theme="light"] .theme-toggle:hover{background:rgba(0,0,0,0.05)}

/* ØªØ­Ø³ÙŠÙ†Ø§Øª Ø¥Ø¶Ø§ÙÙŠØ© Ù„Ù„Ø­Ù‚ÙˆÙ„ */
.input-group {display: flex; gap: 8px; align-items: center;}
.input-group input {flex: 1;}
.input-label {font-weight: 600; margin-bottom: 6px; display: block;}

/* Ø£Ù„ÙˆØ§Ù† Ø§Ù„Ø¨Ø·Ø§Ù‚Ø§Øª ÙÙŠ Ø§Ù„ØªÙˆÙ‚Ø¹ */
.pred-card.player {background: linear-gradient(135deg, #3a86ff, #2667cc); color: white;}
.pred-card.banker {background: linear-gradient(135deg, #ff006e, #cc0058); color: white;}
.pred-card.tie {background: linear-gradient(135deg, #38b000, #2c8a00); color: white;}

/* Ø£Ù†Ù…Ø§Ø· Ù„Ù…Ù†Ø­Ù†Ù‰ Ø§Ù„ØªÙˆÙ‚Ø¹Ø§Øª */
.accuracy-panel {margin-top: 12px;}
.accuracy-stats {display: flex; justify-content: space-between; margin-bottom: 8px;}
.accuracy-value {font-weight: 700; font-size: 18px;}
.accuracy-label {font-size: 12px; color: var(--muted);}
.accuracy-chart-container {position: relative; height: 80px; margin-top: 8px;}
.accuracy-line {stroke: var(--gold); stroke-width: 2; fill: none;}
.accuracy-point {fill: var(--gold); r: 3; transition: r 0.2s;}
.accuracy-point:hover {r: 5;}
.accuracy-grid {stroke: rgba(255,255,255,0.1); stroke-width: 1;}
:root[data-theme="light"] .accuracy-grid {stroke: rgba(0,0,0,0.1);}
.accuracy-tooltip {position: absolute; background: rgba(0,0,0,0.8); color: white; padding: 5px 8px; border-radius: 4px; font-size: 12px; pointer-events: none; opacity: 0; transition: opacity 0.2s;}

/* Ø£Ù†Ù…Ø§Ø· Ø¬Ø¯ÙŠØ¯Ø© Ù„Ù„ÙˆØ§Ø¬Ù‡Ø© Ø§Ù„Ù…Ø­Ø³Ù†Ø© */
.advanced-controls {background: rgba(212,175,55,0.05); border-radius: 8px; padding: 10px; margin-top: 8px;}
.control-group {display: flex; justify-content: space-between; align-items: center; margin-bottom: 8px;}
.control-group:last-child {margin-bottom: 0;}
.slider-container {flex: 1; margin-left: 10px;}
.slider {width: 100%;}
.model-badge {display: inline-block; padding: 2px 8px; border-radius: 12px; font-size: 10px; font-weight: 600; margin-left: 5px;}
.badge-basic {background: #3a86ff; color: white;}
.badge-advanced {background: #ff006e; color: white;}
.badge-pattern {background: #38b000; color: white;}
.pattern-info {font-size: 11px; color: var(--muted); margin-top: 4px;}
.confidence-meter {height: 6px; background: rgba(255,255,255,0.1); border-radius: 3px; margin-top: 4px; overflow: hidden;}
.confidence-fill {height: 100%; background: linear-gradient(90deg, #38b000, #ff006e); border-radius: 3px; transition: width 0.3s;}
.high-confidence {background: linear-gradient(90deg, #38b000, #d4af37);}
.medium-confidence {background: linear-gradient(90deg, #d4af37, #ff006e);}

/* Ø£Ù†Ù…Ø§Ø· Ø®Ø§ØµØ© Ø¨ØªØ­Ù„ÙŠÙ„ Ø§Ù„ÙÙŠØ¯ÙŠÙˆ */
.video-panel {margin-top: 12px;}
.video-container {position: relative; width: 100%; margin-bottom: 10px;}
.video-preview {width: 100%; border-radius: 8px; background: #000;}
.canvas-overlay {position: absolute; top: 0; left: 0; width: 100%; height: 100%; pointer-events: none;}
.video-controls {display: flex; gap: 8px; margin-top: 10px;}
.video-controls .btn {flex: 1;}
.analysis-status {padding: 8px; border-radius: 8px; text-align: center; margin-top: 8px; font-size: 14px;}
.status-processing {background: rgba(212,175,55,0.1); color: var(--gold);}
.status-success {background: rgba(56,176,0,0.1); color: #38b000;}
.status-error {background: rgba(255,0,110,0.1); color: #ff006e;}
.card-detection-grid {display: grid; grid-template-columns: 1fr 1fr; gap: 8px; margin-top: 10px;}
.card-cell {padding: 8px; border-radius: 6px; text-align: center; background: rgba(255,255,255,0.05);}
.card-cell.player {border: 1px solid #3a86ff;}
.card-cell.banker {border: 1px solid #ff006e;}
.card-value {font-weight: 700; font-size: 18px;}
.card-label {font-size: 12px; color: var(--muted);}
</style>
</head>
<body>
<div class="app">
<header class="top card">
  <div class="brand">
    <div class="logo">AYOUB BACCARAT PRO FULL <span class="model-badge badge-advanced">Ù…Ø­Ø³Ù‘Ù† + ØªØ­Ù„ÙŠÙ„ Ø§Ù„ÙÙŠØ¯ÙŠÙˆ</span></div>
    <div class="subtitle">Ù†Ø¸Ø§Ù… ØªÙ†Ø¨Ø¤ Ø°ÙƒÙŠ Ù…ØªÙ‚Ø¯Ù… Ù…Ø¹ ØªØ­Ù„ÙŠÙ„ Ø§Ù„ÙÙŠØ¯ÙŠÙˆ Ø§Ù„Ù…Ø¨Ø§Ø´Ø± Ù„Ù„Ø¨Ø·Ø§Ù‚Ø§Øª ğŸ°ğŸš€ğŸ“¹</div>
  </div>
  <div class="controls">
    <button id="themeToggle" class="theme-toggle">ğŸŒš</button>
    <button id="btnReset" class="btn gold">Ø¥Ø¹Ø§Ø¯Ø© ØªØ¹ÙŠÙŠÙ†</button>
  </div>
</header>

<main class="card layout">
<aside class="left">
  <div class="panel card">
    <label class="input-label">Ù†Ø§ÙØ°Ø© Ø§Ù„ØªØ­Ù„ÙŠÙ„ (5 - 15)</label>
    <div class="input-group">
      <input id="windowSize" type="number" min="5" max="15" value="8">
      <button id="applyWindow" class="btn gold">ØªØ·Ø¨ÙŠÙ‚</button>
    </div>
    <div class="muted small">ÙŠØ­Ù„Ù„ Ø¢Ø®Ø± 5-15 Ø¬ÙˆÙ„Ø© Ø¨Ø§Ø³ØªØ®Ø¯Ø§Ù… Ø®ÙˆØ§Ø±Ø²Ù…ÙŠØ§Øª Ù…ØªÙ‚Ø¯Ù…Ø©</div>
  </div>

  <!-- Ø¥Ø¹Ø¯Ø§Ø¯Ø§Øª Ø§Ù„ØªÙ†Ø¨Ø¤ Ø§Ù„Ù…ØªÙ‚Ø¯Ù… -->
  <div class="panel card">
    <div class="section-title">Ø¥Ø¹Ø¯Ø§Ø¯Ø§Øª Ø§Ù„ØªÙ†Ø¨Ø¤ Ø§Ù„Ù…ØªÙ‚Ø¯Ù…</div>
    <div class="advanced-controls">
      <div class="control-group">
        <label for="analysisMode">Ù†Ù…Ø· Ø§Ù„ØªØ­Ù„ÙŠÙ„:</label>
        <select id="analysisMode">
          <option value="basic">Ø£Ø³Ø§Ø³ÙŠ <span class="model-badge badge-basic">+5%</span></option>
          <option value="advanced" selected>Ù…ØªÙ‚Ø¯Ù… <span class="model-badge badge-advanced">+15%</span></option>
          <option value="pattern">ØªØ­Ù„ÙŠÙ„ Ø§Ù„Ø£Ù†Ù…Ø§Ø· <span class="model-badge badge-pattern">+25%</span></option>
        </select>
      </div>
      <div class="control-group">
        <label for="confidenceSensitivity">Ø­Ø³Ø§Ø³ÙŠØ© Ø§Ù„Ø«Ù‚Ø©:</label>
        <div class="slider-container">
          <input type="range" id="confidenceSensitivity" class="slider" min="30" max="60" value="45">
          <div class="muted small" id="sensitivityValue">45%</div>
        </div>
      </div>
      <div class="control-group">
        <label for="timeWeighting">Ø§Ù„Ù…Ø±Ø¬Ø­Ø© Ø§Ù„Ø²Ù…Ù†ÙŠØ©:</label>
        <select id="timeWeighting">
          <option value="none">Ø¨Ø¯ÙˆÙ†</option>
          <option value="linear" selected>Ø®Ø·ÙŠ</option>
          <option value="exponential">Ø£Ø³Ù‘ÙŠ</option>
        </select>
      </div>
    </div>
  </div>

  <div class="panel card">
    <div class="section-title">Ø¥Ø¯Ø®Ø§Ù„ Ø§Ù„Ù†ØªØ§Ø¦Ø¬</div>
    <div class="row">
      <button class="btn player" id="btnP">Ù„Ø§Ø¹Ø¨ ğŸ”µ</button>
      <button class="btn banker" id="btnB">Ù…ØµØ±ÙÙŠ ğŸ”´</button>
      <button class="btn tie" id="btnT">ØªØ¹Ø§Ø¯Ù„ ğŸŸ¢</button>
    </div>
    <div class="row">
      <button class="btn" id="btnUndo" style="flex:1; background:rgba(255,255,255,0.1); border:1px solid rgba(255,255,255,0.2)">ØªØ±Ø§Ø¬Ø¹</button>
    </div>
  </div>

  <div class="panel card stats">
    <div class="section-title">Ø§Ù„Ø¥Ø­ØµØ§Ø¡Ø§Øª Ø§Ù„Ù…ØªÙ‚Ø¯Ù…Ø©</div>
    <table class="stat-table">
      <thead>
        <tr><th>Ø§Ù„Ø¬Ù‡Ø©</th><th>Ø§Ù„Ù…Ø¬Ù…ÙˆØ¹</th><th>ÙÙˆØ²</th><th>Ø®Ø³Ø§Ø±Ø©</th><th>Ù†Ø³Ø¨Ø© %</th><th>Ø¯Ù‚Ø©</th></tr>
      </thead>
      <tbody>
        <tr><td class="player">Ù„Ø§Ø¹Ø¨</td><td id="pTotal">0</td><td id="pWin">0</td><td id="pLoss">0</td><td id="pPct">0%</td><td id="pAccuracy">0%</td></tr>
        <tr><td class="banker">Ù…ØµØ±ÙÙŠ</td><td id="bTotal">0</td><td id="bWin">0</td><td id="bLoss">0</td><td id="bPct">0%</td><td id="bAccuracy">0%</td></tr>
        <tr><td class="tie">ØªØ¹Ø§Ø¯Ù„</td><td id="tTotal">0</td><td id="tWin">0</td><td id="tLoss">0</td><td id="tPct">0%</td><td id="tAccuracy">0%</td></tr>
      </tbody>
    </table>
    <div class="pattern-info" id="patternInfo">Ù„Ø§ ØªÙˆØ¬Ø¯ Ø£Ù†Ù…Ø§Ø· Ù…ÙƒØªØ´ÙØ© Ø¨Ø¹Ø¯</div>
  </div>

  <div class="panel card">
    <div class="section-title">Ù…Ø¤Ø´Ø± Ø§Ù„Ø«Ù‚Ø©</div>
    <div class="muted small" id="confidenceLabel">Ø«Ù‚Ø© Ù…Ù†Ø®ÙØ¶Ø©</div>
    <div class="confidence-meter">
      <div class="confidence-fill" id="confidenceFill" style="width: 0%"></div>
    </div>
    <div class="pattern-info" id="modelInfo">Ø§Ù„Ù†Ù…ÙˆØ°Ø¬: Ø£Ø³Ø§Ø³ÙŠ</div>
  </div>
</aside>

<section class="right card prediction">
  <div class="pred-head">
    <div class="pred-title">ØªÙˆÙ‚Ø¹ Ø§Ù„Ø¬ÙˆÙ„Ø© Ø§Ù„Ù‚Ø§Ø¯Ù…Ø© <span id="predModel" class="model-badge badge-basic">Ø£Ø³Ø§Ø³ÙŠ</span></div>
    <div class="pred-sub">Ù†Ø¸Ø§Ù… ØªÙ†Ø¨Ø¤ Ù…ØªØ¹Ø¯Ø¯ Ø§Ù„Ù†Ù…Ø§Ø°Ø¬ Ø¨Ø¯Ø±Ø¬Ø© Ø«Ù‚Ø© Ø¹Ø§Ù„ÙŠØ©</div>
  </div>

  <div class="color-legend">
    <span style="background:linear-gradient(135deg, #3a86ff, #2667cc);">ğŸ”µ Ù„Ø§Ø¹Ø¨</span>
    <span style="background:linear-gradient(135deg, #ff006e, #cc0058);">ğŸ”´ Ù…ØµØ±ÙÙŠ</span>
    <span style="background:linear-gradient(135deg, #38b000, #2c8a00);">ğŸŸ¢ ØªØ¹Ø§Ø¯Ù„</span>
  </div>
  
  <canvas id="bigRoad" width="600" height="450"></canvas>

  <div class="prediction-cards">
    <div class="pred-card player" id="predP">
      <div>Ù„Ø§Ø¹Ø¨</div>
      <div id="predPctP">0%</div>
      <div class="muted small" id="predTrendP">â†’</div>
    </div>
    <div class="pred-card banker" id="predB">
      <div>Ù…ØµØ±ÙÙŠ</div>
      <div id="predPctB">0%</div>
      <div class="muted small" id="predTrendB">â†’</div>
    </div>
    <div class="pred-card tie" id="predT">
      <div>ØªØ¹Ø§Ø¯Ù„</div>
      <div id="predPctT">0%</div>
      <div class="muted small" id="predTrendT">â†’</div>
    </div>
  </div>

  <div class="analysis-result">
    <div class="muted">Ø§Ù„ØªÙˆÙ‚Ø¹ Ø§Ù„Ø­Ø§Ù„ÙŠ:</div>
    <div class="final" id="finalCard">â€”</div>
    <div class="muted small" id="predictionReason">Ø¨Ø§Ù†ØªØ¸Ø§Ø± Ø¨ÙŠØ§Ù†Ø§Øª ÙƒØ§ÙÙŠØ© Ù„Ù„ØªØ­Ù„ÙŠÙ„</div>
  </div>

  <!-- Ù„ÙˆØ­Ø© ØªØ­Ù„ÙŠÙ„ Ø§Ù„ÙÙŠØ¯ÙŠÙˆ Ø§Ù„Ù…Ø¶Ø§ÙØ© -->
  <div class="panel card video-panel">
    <div class="section-title">ØªØ­Ù„ÙŠÙ„ Ø§Ù„ÙÙŠØ¯ÙŠÙˆ Ø§Ù„Ù…Ø¨Ø§Ø´Ø± Ù„Ù„Ø¨Ø·Ø§Ù‚Ø§Øª</div>
    <div class="video-container">
      <video id="videoInput" class="video-preview" autoplay muted playsinline></video>
      <canvas id="canvasOverlay" class="canvas-overlay"></canvas>
    </div>
    <div class="video-controls">
      <button id="btnStartCamera" class="btn gold">ØªØ´ØºÙŠÙ„ Ø§Ù„ÙƒØ§Ù…ÙŠØ±Ø§</button>
      <button id="btnCaptureFrame" class="btn player">ØªØ­Ù„ÙŠÙ„ Ù„Ù‚Ø·Ø©</button>
      <button id="btnAutoDetect" class="btn banker">Ø§Ù„ØªÙ„Ù‚Ø§Ø¦ÙŠ</button>
    </div>
    <div id="videoStatus" class="analysis-status">Ø¬Ø§Ù‡Ø² Ù„ØªØ­Ù„ÙŠÙ„ Ø§Ù„ÙÙŠØ¯ÙŠÙˆ</div>
    
    <div class="card-detection-grid">
      <div class="card-cell player">
        <div class="card-label">Ø¨Ø·Ø§Ù‚Ø§Øª Ø§Ù„Ù„Ø§Ø¹Ø¨</div>
        <div class="card-value" id="playerCards">-</div>
      </div>
      <div class="card-cell banker">
        <div class="card-label">Ø¨Ø·Ø§Ù‚Ø§Øª Ø§Ù„Ù…ØµØ±ÙÙŠ</div>
        <div class="card-value" id="bankerCards">-</div>
      </div>
    </div>
    
    <div class="muted small">ÙŠÙ‚ÙˆÙ… Ø§Ù„Ù†Ø¸Ø§Ù… Ø¨ØªØ­Ù„ÙŠÙ„ Ø§Ù„ÙÙŠØ¯ÙŠÙˆ Ø§Ù„Ù…Ø¨Ø§Ø´Ø± Ù„Ø§ÙƒØªØ´Ø§Ù Ø§Ù„Ø¨Ø·Ø§Ù‚Ø§Øª ÙˆØªØ­Ø¯ÙŠØ¯ Ø§Ù„Ù†ØªÙŠØ¬Ø© ØªÙ„Ù‚Ø§Ø¦ÙŠØ§Ù‹</div>
  </div>

  <!-- Ù…Ù†Ø­Ù†Ù‰ Ø§Ù„ØªÙˆÙ‚Ø¹Ø§Øª Ø§Ù„Ù…Ø¶Ø§Ù -->
  <div class="panel card accuracy-panel">
    <div class="section-title">Ù…Ù†Ø­Ù†Ù‰ Ø¯Ù‚Ø© Ø§Ù„ØªÙˆÙ‚Ø¹Ø§Øª Ø§Ù„Ù…ØªÙ‚Ø¯Ù…</div>
    <div class="accuracy-stats">
      <div>
        <div class="accuracy-label">Ø§Ù„Ø¯Ù‚Ø© Ø§Ù„Ø­Ø§Ù„ÙŠØ©</div>
        <div class="accuracy-value" id="currentAccuracy">0%</div>
      </div>
      <div>
        <div class="accuracy-label">Ø£ÙØ¶Ù„ Ø¯Ù‚Ø©</div>
        <div class="accuracy-value" id="bestAccuracy">0%</div>
      </div>
      <div>
        <div class="accuracy-label">Ù…ØªÙˆØ³Ø· Ø§Ù„Ø¯Ù‚Ø©</div>
        <div class="accuracy-value" id="averageAccuracy">0%</div>
      </div>
      <div>
        <div class="accuracy-label">ÙƒÙØ§Ø¡Ø© Ø§Ù„Ù†Ù…ÙˆØ°Ø¬</div>
        <div class="accuracy-value" id="modelEfficiency">0%</div>
      </div>
    </div>
    <div class="accuracy-chart-container">
      <svg id="accuracyChart" width="100%" height="100%"></svg>
      <div id="accuracyTooltip" class="accuracy-tooltip"></div>
    </div>
    <div class="muted small">ØªØªØ¨Ø¹ Ø¯Ù‚Ø© ØªÙˆÙ‚Ø¹Ø§ØªÙƒ Ù…Ø¹ ØªØ­Ù„ÙŠÙ„ Ø£Ø¯Ø§Ø¡ Ø§Ù„Ù†Ù…Ø§Ø°Ø¬ Ø§Ù„Ù…Ø®ØªÙ„ÙØ©</div>
  </div>
</section>
</main>

<footer class="foot card">
<div>ØªØµÙ…ÙŠÙ…: Ayoub â€¢ Ø§Ù„Ù†Ø³Ø®Ø© Ø§Ù„Ù…Ø­Ø³Ù†Ø© Ù…Ø¹ ØªØ­Ù„ÙŠÙ„ Ø§Ù„ÙÙŠØ¯ÙŠÙˆ</div>
<div class="credits small">Ù†Ø¸Ø§Ù… Ù…ØªØ¹Ø¯Ø¯ Ø§Ù„Ù†Ù…Ø§Ø°Ø¬ â€¢ ØªØ­Ù„ÙŠÙ„ Ø§Ù„Ø£Ù†Ù…Ø§Ø· â€¢ ØªØ­Ù„ÙŠÙ„ Ø§Ù„ÙÙŠØ¯ÙŠÙˆ â€¢ Ù…Ø¤Ø´Ø±Ø§Øª Ù…ØªÙ‚Ø¯Ù…Ø©</div>
</footer>

<script>
// Logic.js for AYBOUB BACCARAT PRO FULL - Ø§Ù„Ù†Ø³Ø®Ø© Ø§Ù„Ù…Ø­Ø³Ù†Ø© Ù…Ø¹ ØªØ­Ù„ÙŠÙ„ Ø§Ù„ÙÙŠØ¯ÙŠÙˆ
const state = {
  rounds: [],
  windowSize: 8,
  count: { P: 0, B: 0, T: 0 },
  win: { P: 0, B: 0, T: 0 },
  loss: { P: 0, B: 0, T: 0 },
  lastPrediction: null,
  // Ø¨ÙŠØ§Ù†Ø§Øª Ù…Ù†Ø­Ù†Ù‰ Ø§Ù„ØªÙˆÙ‚Ø¹Ø§Øª
  accuracyHistory: [],
  predictionsHistory: [],
  // Ø§Ù„Ø¥Ø¹Ø¯Ø§Ø¯Ø§Øª Ø§Ù„Ù…ØªÙ‚Ø¯Ù…Ø©
  analysisMode: 'advanced',
  confidenceThreshold: 45,
  timeWeighting: 'linear',
  // ØªØªØ¨Ø¹ Ø£Ø¯Ø§Ø¡ Ø§Ù„Ù†Ù…Ø§Ø°Ø¬
  modelPerformance: { basic: 0, advanced: 0, pattern: 0 },
  previousPredictions: { P: 0, B: 0, T: 0 },
  // ØªØ­Ù„ÙŠÙ„ Ø§Ù„ÙÙŠØ¯ÙŠÙˆ
  videoStream: null,
  isVideoActive: false,
  autoDetectionInterval: null
};

const el = id => document.getElementById(id);

function init() {
  el('windowSize').value = state.windowSize;
  el('applyWindow').onclick = () => {
    const v = Number(el('windowSize').value);
    if (v < 5 || v > 15) {
      alert('Ø§Ù„Ù†Ø§ÙØ°Ø© ÙŠØ¬Ø¨ Ø£Ù† ØªÙƒÙˆÙ† Ø¨ÙŠÙ† 5 Ùˆ 15');
      return;
    }
    state.windowSize = v;
    updateAll();
  };

  // Ø¥Ø¹Ø¯Ø§Ø¯Ø§Øª Ø§Ù„ØªØ­ÙƒÙ… Ø§Ù„Ù…ØªÙ‚Ø¯Ù…
  el('analysisMode').value = state.analysisMode;
  el('analysisMode').onchange = (e) => {
    state.analysisMode = e.target.value;
    updateAll();
  };

  el('confidenceSensitivity').value = state.confidenceThreshold;
  el('confidenceSensitivity').oninput = (e) => {
    state.confidenceThreshold = Number(e.target.value);
    el('sensitivityValue').textContent = state.confidenceThreshold + '%';
    updateAll();
  };

  el('timeWeighting').value = state.timeWeighting;
  el('timeWeighting').onchange = (e) => {
    state.timeWeighting = e.target.value;
    updateAll();
  };

  el('btnP').onclick = () => pushRound('P');
  el('btnB').onclick = () => pushRound('B');
  el('btnT').onclick = () => pushRound('T');
  el('btnUndo').onclick = undoRound;
  el('btnReset').onclick = resetAll;
  
  // Ø¥Ø¹Ø¯Ø§Ø¯ ØªØ¨Ø¯ÙŠÙ„ Ø§Ù„ÙˆØ¶Ø¹ Ø§Ù„Ù„ÙŠÙ„ÙŠ/Ø§Ù„Ù†Ù‡Ø§Ø±ÙŠ
  el('themeToggle').onclick = toggleTheme;
  
  // ØªØ¹ÙŠÙŠÙ† Ø§Ù„ÙˆØ¶Ø¹ Ø§Ù„Ø§ÙØªØ±Ø§Ø¶ÙŠ (Ù„ÙŠÙ„ÙŠ)
  document.documentElement.setAttribute('data-theme', 'dark');

  // Ø¥Ø¹Ø¯Ø§Ø¯Ø§Øª ØªØ­Ù„ÙŠÙ„ Ø§Ù„ÙÙŠØ¯ÙŠÙˆ
  el('btnStartCamera').onclick = toggleCamera;
  el('btnCaptureFrame').onclick = captureAndAnalyzeFrame;
  el('btnAutoDetect').onclick = toggleAutoDetection;

  updateAll();
}

function toggleTheme() {
  const currentTheme = document.documentElement.getAttribute('data-theme');
  const newTheme = currentTheme === 'dark' ? 'light' : 'dark';
  document.documentElement.setAttribute('data-theme', newTheme);
  el('themeToggle').textContent = newTheme === 'dark' ? 'ğŸŒš' : 'ğŸŒ•';
  updateAccuracyChart();
}

// ========== Ø®ÙˆØ§Ø±Ø²Ù…ÙŠØ§Øª ØªØ­Ù„ÙŠÙ„ Ø§Ù„ÙÙŠØ¯ÙŠÙˆ ==========

async function toggleCamera() {
  if (state.isVideoActive) {
    stopCamera();
    el('btnStartCamera').textContent = 'ØªØ´ØºÙŠÙ„ Ø§Ù„ÙƒØ§Ù…ÙŠØ±Ø§';
    el('videoStatus').textContent = 'Ø§Ù„ÙƒØ§Ù…ÙŠØ±Ø§ Ù…ØªÙˆÙ‚ÙØ©';
    el('videoStatus').className = 'analysis-status';
  } else {
    try {
      state.videoStream = await navigator.mediaDevices.getUserMedia({ 
        video: { 
          width: { ideal: 640 },
          height: { ideal: 480 },
          facingMode: 'environment'
        } 
      });
      
      const video = el('videoInput');
      video.srcObject = state.videoStream;
      state.isVideoActive = true;
      
      el('btnStartCamera').textContent = 'Ø¥ÙŠÙ‚Ø§Ù Ø§Ù„ÙƒØ§Ù…ÙŠØ±Ø§';
      el('videoStatus').textContent = 'Ø§Ù„ÙƒØ§Ù…ÙŠØ±Ø§ Ù†Ø´Ø·Ø© - Ø¬Ø§Ù‡Ø² Ù„Ù„ØªØ­Ù„ÙŠÙ„';
      el('videoStatus').className = 'analysis-status status-success';
      
    } catch (error) {
      console.error('Ø®Ø·Ø£ ÙÙŠ ØªØ´ØºÙŠÙ„ Ø§Ù„ÙƒØ§Ù…ÙŠØ±Ø§:', error);
      el('videoStatus').textContent = 'Ø®Ø·Ø£ ÙÙŠ ØªØ´ØºÙŠÙ„ Ø§Ù„ÙƒØ§Ù…ÙŠØ±Ø§';
      el('videoStatus').className = 'analysis-status status-error';
    }
  }
}

function stopCamera() {
  if (state.videoStream) {
    state.videoStream.getTracks().forEach(track => track.stop());
    state.videoStream = null;
  }
  state.isVideoActive = false;
  
  if (state.autoDetectionInterval) {
    clearInterval(state.autoDetectionInterval);
    state.autoDetectionInterval = null;
  }
}

function captureAndAnalyzeFrame() {
  if (!state.isVideoActive) {
    el('videoStatus').textContent = 'ÙŠØ¬Ø¨ ØªØ´ØºÙŠÙ„ Ø§Ù„ÙƒØ§Ù…ÙŠØ±Ø§ Ø£ÙˆÙ„Ø§Ù‹';
    el('videoStatus').className = 'analysis-status status-error';
    return;
  }
  
  el('videoStatus').textContent = 'Ø¬Ø§Ø±ÙŠ ØªØ­Ù„ÙŠÙ„ Ø§Ù„Ù„Ù‚Ø·Ø©...';
  el('videoStatus').className = 'analysis-status status-processing';
  
  const video = el('videoInput');
  const canvas = el('canvasOverlay');
  const ctx = canvas.getContext('2d');
  
  // Ø¶Ø¨Ø· Ø£Ø¨Ø¹Ø§Ø¯ Ø§Ù„Ù€ canvas Ù„ØªØªÙ†Ø§Ø³Ø¨ Ù…Ø¹ Ø§Ù„ÙÙŠØ¯ÙŠÙˆ
  canvas.width = video.videoWidth;
  canvas.height = video.videoHeight;
  
  // Ø±Ø³Ù… Ø§Ù„ÙÙŠØ¯ÙŠÙˆ Ø¹Ù„Ù‰ Ø§Ù„Ù€ canvas
  ctx.drawImage(video, 0, 0, canvas.width, canvas.height);
  
  // Ù…Ø­Ø§ÙƒØ§Ø© ØªØ­Ù„ÙŠÙ„ Ø§Ù„Ø¨Ø·Ø§Ù‚Ø§Øª (ÙÙŠ Ø§Ù„ØªØ·Ø¨ÙŠÙ‚ Ø§Ù„Ø­Ù‚ÙŠÙ‚ÙŠ Ø³ÙŠØªÙ… Ø§Ø³ØªØ®Ø¯Ø§Ù… Ù…ÙƒØªØ¨Ø© Ø±Ø¤ÙŠØ© Ø­Ø§Ø³ÙˆØ¨ÙŠØ©)
  simulateCardDetection(ctx);
}

function simulateCardDetection(ctx) {
  // Ù…Ø­Ø§ÙƒØ§Ø© Ø§ÙƒØªØ´Ø§Ù Ø§Ù„Ø¨Ø·Ø§Ù‚Ø§Øª (Ù‡Ø°Ù‡ Ù…Ø­Ø§ÙƒØ§Ø©ØŒ ÙÙŠ Ø§Ù„ØªØ·Ø¨ÙŠÙ‚ Ø§Ù„Ø­Ù‚ÙŠÙ‚ÙŠ Ø³ÙŠØªÙ… Ø§Ø³ØªØ®Ø¯Ø§Ù… Ø±Ø¤ÙŠØ© Ø­Ø§Ø³ÙˆØ¨ÙŠØ© Ø­Ù‚ÙŠÙ‚ÙŠØ©)
  const detectedCards = simulateCardRecognition();
  
  // Ø±Ø³Ù… Ù…Ø±Ø¨Ø¹Ø§Øª Ø­ÙˆÙ„ Ø§Ù„Ø¨Ø·Ø§Ù‚Ø§Øª Ø§Ù„Ù…ÙƒØªØ´ÙØ©
  drawDetectionBoxes(ctx, detectedCards);
  
  // Ø¹Ø±Ø¶ Ø§Ù„Ù†ØªØ§Ø¦Ø¬
  displayCardResults(detectedCards);
  
  // ØªØ­Ø¯ÙŠØ« Ø­Ø§Ù„Ø© Ø§Ù„ØªØ­Ù„ÙŠÙ„
  el('videoStatus').textContent = 'ØªÙ… ØªØ­Ù„ÙŠÙ„ Ø§Ù„Ø¨Ø·Ø§Ù‚Ø§Øª Ø¨Ù†Ø¬Ø§Ø­';
  el('videoStatus').className = 'analysis-status status-success';
  
  // Ø¥Ø¶Ø§ÙØ© Ø§Ù„Ù†ØªÙŠØ¬Ø© ØªÙ„Ù‚Ø§Ø¦ÙŠØ§Ù‹ Ø¥Ø°Ø§ ÙƒØ§Ù†Øª ÙˆØ§Ø¶Ø­Ø©
  if (detectedCards.confidence > 70) {
    setTimeout(() => {
      pushRound(detectedCards.result);
      el('videoStatus').textContent = `ØªÙ… Ø¥Ø¶Ø§ÙØ© Ø§Ù„Ù†ØªÙŠØ¬Ø©: ${getResultName(detectedCards.result)}`;
    }, 1000);
  }
}

function simulateCardRecognition() {
  // Ù…Ø­Ø§ÙƒØ§Ø© Ø®ÙˆØ§Ø±Ø²Ù…ÙŠØ© Ø§ÙƒØªØ´Ø§Ù Ø§Ù„Ø¨Ø·Ø§Ù‚Ø§Øª
  // ÙÙŠ Ø§Ù„ØªØ·Ø¨ÙŠÙ‚ Ø§Ù„Ø­Ù‚ÙŠÙ‚ÙŠØŒ Ø³ÙŠØªÙ… Ø§Ø³ØªØ®Ø¯Ø§Ù… TensorFlow.js Ø£Ùˆ OpenCV.js
  
  const playerCards = [];
  const bankerCards = [];
  
  // Ù…Ø­Ø§ÙƒØ§Ø© Ù‚ÙŠÙ… Ø§Ù„Ø¨Ø·Ø§Ù‚Ø§Øª (Ø¹Ø´ÙˆØ§Ø¦ÙŠØ© Ù„Ø£ØºØ±Ø§Ø¶ Ø§Ù„Ø¹Ø±Ø¶)
  for (let i = 0; i < 2; i++) {
    playerCards.push(Math.floor(Math.random() * 10));
    bankerCards.push(Math.floor(Math.random() * 10));
  }
  
  // Ù…Ø­Ø§ÙƒØ§Ø© Ø¨Ø·Ø§Ù‚Ø© Ø«Ø§Ù„Ø«Ø© ÙÙŠ Ø¨Ø¹Ø¶ Ø§Ù„Ø­Ø§Ù„Ø§Øª
  if (Math.random() > 0.7) {
    playerCards.push(Math.floor(Math.random() * 10));
  }
  if (Math.random() > 0.7) {
    bankerCards.push(Math.floor(Math.random() * 10));
  }
  
  // Ø­Ø³Ø§Ø¨ Ø§Ù„Ù†Ù‚Ø§Ø·
  const playerScore = calculateBaccaratScore(playerCards);
  const bankerScore = calculateBaccaratScore(bankerCards);
  
  // ØªØ­Ø¯ÙŠØ¯ Ø§Ù„Ù†ØªÙŠØ¬Ø©
  let result;
  if (playerScore > bankerScore) result = 'P';
  else if (bankerScore > playerScore) result = 'B';
  else result = 'T';
  
  // Ù…Ø­Ø§ÙƒØ§Ø© Ù…Ø³ØªÙˆÙ‰ Ø§Ù„Ø«Ù‚Ø©
  const confidence = 60 + Math.random() * 35;
  
  return {
    playerCards,
    bankerCards,
    playerScore,
    bankerScore,
    result,
    confidence
  };
}

function calculateBaccaratScore(cards) {
  let total = 0;
  cards.forEach(card => {
    total += (card > 9 ? 0 : card); // ÙÙŠ Ø§Ù„Ø¨Ø§ÙƒØ§Ø±Ø§ØªØŒ 10 Ùˆ J Ùˆ Q Ùˆ K ØªØ³Ø§ÙˆÙŠ 0
  });
  return total % 10; // ÙÙ‚Ø· Ø§Ù„Ø±Ù‚Ù… Ø§Ù„Ø£Ø®ÙŠØ± Ù‡Ùˆ Ø§Ù„Ù…Ù‡Ù…
}

function drawDetectionBoxes(ctx, detection) {
  const { width, height } = ctx.canvas;
  
  // Ù…Ø³Ø­ Ø§Ù„Ù€ canvas Ø§Ù„Ø³Ø§Ø¨Ù‚
  ctx.clearRect(0, 0, width, height);
  
  // Ø±Ø³Ù… Ø§Ù„ÙÙŠØ¯ÙŠÙˆ Ù…Ø±Ø© Ø£Ø®Ø±Ù‰
  const video = el('videoInput');
  ctx.drawImage(video, 0, 0, width, height);
  
  // Ø±Ø³Ù… Ù…Ø±Ø¨Ø¹ Ø­ÙˆÙ„ Ù…Ù†Ø·Ù‚Ø© Ø§Ù„Ù„Ø§Ø¹Ø¨
  ctx.strokeStyle = '#3a86ff';
  ctx.lineWidth = 3;
  ctx.strokeRect(width * 0.1, height * 0.3, width * 0.35, height * 0.4);
  
  // Ø±Ø³Ù… Ù…Ø±Ø¨Ø¹ Ø­ÙˆÙ„ Ù…Ù†Ø·Ù‚Ø© Ø§Ù„Ù…ØµØ±ÙÙŠ
  ctx.strokeStyle = '#ff006e';
  ctx.lineWidth = 3;
  ctx.strokeRect(width * 0.55, height * 0.3, width * 0.35, height * 0.4);
  
  // Ø¥Ø¶Ø§ÙØ© ØªØ³Ù…ÙŠØ§Øª
  ctx.font = 'bold 20px Inter';
  ctx.fillStyle = '#3a86ff';
  ctx.fillText('Ù„Ø§Ø¹Ø¨', width * 0.1, height * 0.25);
  ctx.fillStyle = '#ff006e';
  ctx.fillText('Ù…ØµØ±ÙÙŠ', width * 0.55, height * 0.25);
  
  // Ø¥Ø¶Ø§ÙØ© Ø§Ù„Ù†ØªÙŠØ¬Ø© Ø§Ù„Ù…ÙƒØªØ´ÙØ©
  if (detection.result) {
    ctx.fillStyle = '#ffffff';
    ctx.font = 'bold 24px Inter';
    ctx.textAlign = 'center';
    ctx.fillText(`Ø§Ù„Ù†ØªÙŠØ¬Ø©: ${getResultName(detection.result)}`, width / 2, height * 0.85);
    ctx.fillText(`Ø§Ù„Ø«Ù‚Ø©: ${detection.confidence.toFixed(1)}%`, width / 2, height * 0.9);
  }
}

function displayCardResults(detection) {
  el('playerCards').textContent = detection.playerCards.join(', ');
  el('bankerCards').textContent = detection.bankerCards.join(', ');
}

function getResultName(result) {
  switch(result) {
    case 'P': return 'Ù„Ø§Ø¹Ø¨';
    case 'B': return 'Ù…ØµØ±ÙÙŠ';
    case 'T': return 'ØªØ¹Ø§Ø¯Ù„';
    default: return 'ØºÙŠØ± Ù…Ø¹Ø±ÙˆÙ';
  }
}

function toggleAutoDetection() {
  if (state.autoDetectionInterval) {
    clearInterval(state.autoDetectionInterval);
    state.autoDetectionInterval = null;
    el('btnAutoDetect').textContent = 'Ø§Ù„ØªÙ„Ù‚Ø§Ø¦ÙŠ';
    el('videoStatus').textContent = 'Ø§Ù„ÙƒØ´Ù Ø§Ù„ØªÙ„Ù‚Ø§Ø¦ÙŠ Ù…ØªÙˆÙ‚Ù';
  } else {
    if (!state.isVideoActive) {
      el('videoStatus').textContent = 'ÙŠØ¬Ø¨ ØªØ´ØºÙŠÙ„ Ø§Ù„ÙƒØ§Ù…ÙŠØ±Ø§ Ø£ÙˆÙ„Ø§Ù‹';
      el('videoStatus').className = 'analysis-status status-error';
      return;
    }
    
    state.autoDetectionInterval = setInterval(() => {
      captureAndAnalyzeFrame();
    }, 3000); // ØªØ­Ù„ÙŠÙ„ ÙƒÙ„ 3 Ø«ÙˆØ§Ù†ÙŠ
    
    el('btnAutoDetect').textContent = 'Ø¥ÙŠÙ‚Ø§Ù Ø§Ù„ØªÙ„Ù‚Ø§Ø¦ÙŠ';
    el('videoStatus').textContent = 'Ø¬Ø§Ø±ÙŠ Ø§Ù„ÙƒØ´Ù Ø§Ù„ØªÙ„Ù‚Ø§Ø¦ÙŠ...';
    el('videoStatus').className = 'analysis-status status-processing';
  }
}

// ========== Ø§Ù„Ø®ÙˆØ§Ø±Ø²Ù…ÙŠØ§Øª Ø§Ù„Ù…Ø­Ø³Ù†Ø© ==========

// 1. Ø§Ù„ØªØ­Ù„ÙŠÙ„ Ø§Ù„Ø£Ø³Ø§Ø³ÙŠ (Ø§Ù„ØªØ±Ø¯Ø¯)
function frequencyAnalysis(rounds) {
  const counts = { P: 0, B: 0, T: 0 };
  rounds.forEach(x => counts[x]++);
  
  const total = rounds.length;
  return {
    P: (counts.P / total) * 100,
    B: (counts.B / total) * 100,
    T: (counts.T / total) * 100
  };
}

// 2. ØªØ­Ù„ÙŠÙ„ Ø§Ù„Ø£Ù†Ù…Ø§Ø· Ø§Ù„Ù…ØªØ³Ù„Ø³Ù„Ø©
function patternAnalysis(rounds) {
  if (rounds.length < 3) return { P: 0, B: 0, T: 0 };

  const patterns = {};
  let totalPatterns = 0;

  // ØªØ­Ù„ÙŠÙ„ Ø£Ù†Ù…Ø§Ø· Ø·ÙˆÙ„ 2
  for (let i = 2; i < rounds.length; i++) {
    const pattern = rounds.slice(i-2, i).join('');
    const next = rounds[i];
    
    if (!patterns[pattern]) {
      patterns[pattern] = { P: 0, B: 0, T: 0, total: 0 };
    }
    
    patterns[pattern][next]++;
    patterns[pattern].total++;
    totalPatterns++;
  }

  // Ø§Ø³ØªØ®Ø¯Ø§Ù… Ø¢Ø®Ø± Ù†Ù…Ø· Ù„Ù„ØªÙ†Ø¨Ø¤
  if (rounds.length >= 2) {
    const lastPattern = rounds.slice(-2).join('');
    const patternData = patterns[lastPattern];
    
    if (patternData && patternData.total >= 1) {
      return {
        P: (patternData.P / patternData.total) * 100,
        B: (patternData.B / patternData.total) * 100,
        T: (patternData.T / patternData.total) * 100
      };
    }
  }

  return { P: 0, B: 0, T: 0 };
}

// 3. Ø§Ù„Ù…Ø±Ø¬Ø­Ø© Ø§Ù„Ø²Ù…Ù†ÙŠØ©
function applyTimeWeighting(rounds, basePrediction) {
  if (state.timeWeighting === 'none' || rounds.length < 2) {
    return basePrediction;
  }

  const weights = [];
  const n = rounds.length;
  
  for (let i = 0; i < n; i++) {
    let weight;
    if (state.timeWeighting === 'linear') {
      weight = (i + 1) / n; // ÙˆØ²Ù† Ø®Ø·ÙŠ
    } else { // exponential
      weight = Math.pow(1.5, i) / Math.pow(1.5, n-1); // ÙˆØ²Ù† Ø£Ø³ÙŠ
    }
    weights.push(weight);
  }

  // ØªØ·Ø¨ÙŠÙ‚ Ø§Ù„Ø£ÙˆØ²Ø§Ù† (Ù…Ø¨Ø³Ø· - ÙÙŠ Ø§Ù„ØªÙ†ÙÙŠØ° Ø§Ù„ÙƒØ§Ù…Ù„ ÙŠØªÙ… ØªØ·Ø¨ÙŠÙ‚Ù‡Ø§ Ø¹Ù„Ù‰ ÙƒÙ„ Ø¬ÙˆÙ„Ø©)
  const weightFactor = weights.reduce((a, b) => a + b, 0) / n;
  return {
    P: basePrediction.P * (0.8 + 0.2 * weightFactor),
    B: basePrediction.B * (0.8 + 0.2 * weightFactor),
    T: basePrediction.T * (0.8 + 0.2 * weightFactor)
  };
}

// 4. Ø­Ø³Ø§Ø¨ Ø§Ù„ØªÙ‚Ù„Ø¨ ÙˆØ§Ù„Ø§ØªØ¬Ø§Ù‡
function calculateTrend(rounds) {
  if (rounds.length < 2) return { direction: 'stable', strength: 0 };
  
  const changes = [];
  for (let i = 1; i < rounds.length; i++) {
    changes.push(rounds[i] === rounds[i-1] ? 0 : 1);
  }
  
  const changeRate = changes.reduce((a, b) => a + b, 0) / changes.length;
  return {
    direction: changeRate > 0.6 ? 'volatile' : changeRate > 0.4 ? 'mixed' : 'stable',
    strength: Math.abs(changeRate - 0.5) * 2
  };
}

// 5. Ø§Ù„Ø¯Ø§Ù„Ø© Ø§Ù„Ø±Ø¦ÙŠØ³ÙŠØ© Ø§Ù„Ù…Ø­Ø³Ù†Ø© Ù„Ù„ØªÙ†Ø¨Ø¤
function enhancedPredict() {
  const n = Math.min(state.windowSize, state.rounds.length);
  const recent = state.rounds.slice(-n);
  
  if (recent.length === 0) {
    return { 
      P: 33.3, B: 33.3, T: 33.3, 
      final: 'â€”',
      confidence: 0,
      model: 'basic'
    };
  }

  let basePrediction, patternBoost, finalPrediction;
  let modelUsed = state.analysisMode;

  // ØªØ·Ø¨ÙŠÙ‚ Ø§Ù„Ù†Ù…ÙˆØ°Ø¬ Ø§Ù„Ù…Ø®ØªØ§Ø±
  switch(state.analysisMode) {
    case 'basic':
      basePrediction = frequencyAnalysis(recent);
      finalPrediction = basePrediction;
      break;
      
    case 'advanced':
      basePrediction = frequencyAnalysis(recent);
      patternBoost = patternAnalysis(recent);
      
      // Ø¯Ù…Ø¹ Ø§Ù„Ù†ØªØ§Ø¦Ø¬ Ø¨Ù…Ø±Ø¬Ø­Ø©
      finalPrediction = {
        P: basePrediction.P * 0.7 + patternBoost.P * 0.3,
        B: basePrediction.B * 0.7 + patternBoost.B * 0.3,
        T: basePrediction.T * 0.7 + patternBoost.T * 0.3
      };
      break;
      
    case 'pattern':
      basePrediction = frequencyAnalysis(recent);
      patternBoost = patternAnalysis(recent);
      
      // ØªØ±ÙƒÙŠØ² Ø£ÙƒØ¨Ø± Ø¹Ù„Ù‰ Ø§Ù„Ø£Ù†Ù…Ø§Ø·
      finalPrediction = {
        P: basePrediction.P * 0.4 + patternBoost.P * 0.6,
        B: basePrediction.B * 0.4 + patternBoost.B * 0.6,
        T: basePrediction.T * 0.4 + patternBoost.T * 0.6
      };
      break;
  }

  // ØªØ·Ø¨ÙŠÙ‚ Ø§Ù„Ù…Ø±Ø¬Ø­Ø© Ø§Ù„Ø²Ù…Ù†ÙŠØ©
  finalPrediction = applyTimeWeighting(recent, finalPrediction);

  // ØªØ·Ø¨ÙŠØ¹ Ø§Ù„Ù†ØªØ§Ø¦Ø¬
  const sum = finalPrediction.P + finalPrediction.B + finalPrediction.T;
  finalPrediction.P = (finalPrediction.P / sum) * 100;
  finalPrediction.B = (finalPrediction.B / sum) * 100;
  finalPrediction.T = (finalPrediction.T / sum) * 100;

  // ØªØ­Ø¯ÙŠØ¯ Ø§Ù„ÙØ§Ø¦Ø² Ù…Ø¹ Ø¹ØªØ¨Ø© Ø§Ù„Ø«Ù‚Ø©
  const entries = Object.entries(finalPrediction).filter(([key]) => key !== 'final' && key !== 'confidence' && key !== 'model');
  const sorted = entries.sort((a, b) => b[1] - a[1]);
  
  const confidence = sorted[0][1] - (sorted[1] ? sorted[1][1] : 0);
  let final = sorted[0][0];
  
  // ØªØ·Ø¨ÙŠÙ‚ Ø¹ØªØ¨Ø© Ø§Ù„Ø«Ù‚Ø©
  if (sorted[0][1] < state.confidenceThreshold) {
    final = 'â€”';
  }

  return {
    P: finalPrediction.P.toFixed(1),
    B: finalPrediction.B.toFixed(1),
    T: finalPrediction.T.toFixed(1),
    final,
    confidence: Math.min(100, Math.max(0, confidence * 2)),
    model: modelUsed
  };
}

function pushRound(r) {
  // ØªØ®Ø²ÙŠÙ† Ø§Ù„ØªÙˆÙ‚Ø¹ Ù‚Ø¨Ù„ Ø¥Ø¶Ø§ÙØ© Ø§Ù„Ø¬ÙˆÙ„Ø© Ø§Ù„Ø¬Ø¯ÙŠØ¯Ø©
  const pred = enhancedPredict();
  state.lastPrediction = pred.final;
  
  // Ø¥Ø¶Ø§ÙØ© Ø§Ù„Ø¬ÙˆÙ„Ø© Ø§Ù„Ø¬Ø¯ÙŠØ¯Ø©
  state.rounds.push(r);
  state.count[r]++;
  
  // Ø­Ø³Ø§Ø¨ Ø§Ù„ÙÙˆØ²/Ø§Ù„Ø®Ø³Ø§Ø±Ø© Ø¨Ù†Ø§Ø¡Ù‹ Ø¹Ù„Ù‰ Ø§Ù„ØªÙˆÙ‚Ø¹ Ø§Ù„Ø³Ø§Ø¨Ù‚
  if (state.lastPrediction !== 'â€”' && state.lastPrediction !== null) {
    const didWin = (r === state.lastPrediction);
    
    if (didWin) {
      state.win[state.lastPrediction]++;
      // ØªØ­Ø³ÙŠÙ† Ø£Ø¯Ø§Ø¡ Ø§Ù„Ù†Ù…ÙˆØ°Ø¬ Ø§Ù„Ù…Ø³ØªØ®Ø¯Ù…
      state.modelPerformance[state.analysisMode] += 1;
    } else {
      state.loss[state.lastPrediction]++;
    }
  }
  
  // ØªØ­Ø¯ÙŠØ« Ø¨ÙŠØ§Ù†Ø§Øª Ù…Ù†Ø­Ù†Ù‰ Ø§Ù„ØªÙˆÙ‚Ø¹Ø§Øª
  updateAccuracyData(r);
  
  // ØªØ­Ø¯ÙŠØ« Ø§Ù„ØªÙˆÙ‚Ø¹ Ø§Ù„Ø¬Ø¯ÙŠØ¯
  const newPred = enhancedPredict();
  updatePredictionDisplay(newPred);
  showResult(r, newPred, state.lastPrediction === r);
  updateAll();
}

function undoRound() {
  if (state.rounds.length === 0) return;
  
  const lastRound = state.rounds.pop();
  state.count[lastRound]--;
  
  // Ø¥Ø²Ø§Ù„Ø© Ø§Ù„ÙÙˆØ²/Ø§Ù„Ø®Ø³Ø§Ø±Ø© Ø§Ù„Ø£Ø®ÙŠØ±Ø©
  if (state.rounds.length > 0) {
    const previousPrediction = enhancedPredict();
    if (lastRound === previousPrediction.final) {
      state.win[previousPrediction.final] = Math.max(0, state.win[previousPrediction.final] - 1);
      state.modelPerformance[state.analysisMode] = Math.max(0, state.modelPerformance[state.analysisMode] - 1);
    } else {
      state.loss[previousPrediction.final] = Math.max(0, state.loss[previousPrediction.final] - 1);
    }
  }
  
  // Ø¥Ø²Ø§Ù„Ø© Ø¢Ø®Ø± Ø¨ÙŠØ§Ù†Ø§Øª Ø§Ù„Ø¯Ù‚Ø©
  if (state.accuracyHistory.length > 0) {
    state.accuracyHistory.pop();
    state.predictionsHistory.pop();
  }
  
  state.lastPrediction = null;
  updateAll();
}

function resetAll() {
  state.rounds = [];
  state.count = { P: 0, B: 0, T: 0 };
  state.win = { P: 0, B: 0, T: 0 };
  state.loss = { P: 0, B: 0, T: 0 };
  state.lastPrediction = null;
  state.accuracyHistory = [];
  state.predictionsHistory = [];
  state.modelPerformance = { basic: 0, advanced: 0, pattern: 0 };
  state.previousPredictions = { P: 0, B: 0, T: 0 };
  
  // Ø¥ÙŠÙ‚Ø§Ù Ø§Ù„ÙƒØ§Ù…ÙŠØ±Ø§ Ø¥Ø°Ø§ ÙƒØ§Ù†Øª Ù†Ø´Ø·Ø©
  if (state.isVideoActive) {
    stopCamera();
    el('btnStartCamera').textContent = 'ØªØ´ØºÙŠÙ„ Ø§Ù„ÙƒØ§Ù…ÙŠØ±Ø§';
    el('videoStatus').textContent = 'Ø¬Ø§Ù‡Ø² Ù„ØªØ­Ù„ÙŠÙ„ Ø§Ù„ÙÙŠØ¯ÙŠÙˆ';
    el('videoStatus').className = 'analysis-status';
  }
  
  updateAll();
}

function updatePredictionDisplay(pred) {
  el('predPctP').textContent = pred.P + '%';
  el('predPctB').textContent = pred.B + '%';
  el('predPctT').textContent = pred.T + '%';
  
  // ØªØ­Ø¯ÙŠØ« Ù…Ø¤Ø´Ø±Ø§Øª Ø§Ù„Ø§ØªØ¬Ø§Ù‡
  updateTrendIndicators(pred);
  
  // Ø¥Ø²Ø§Ù„Ø© Ø§Ù„ØªÙ†Ø´ÙŠØ· Ù…Ù† Ø¬Ù…ÙŠØ¹ Ø§Ù„Ø¨Ø·Ø§Ù‚Ø§Øª
  ['predP', 'predB', 'predT'].forEach(id => {
    el(id).classList.remove('active');
  });
  
  // ØªÙØ¹ÙŠÙ„ Ø§Ù„Ø¨Ø·Ø§Ù‚Ø© Ø§Ù„Ù…ØªÙˆÙ‚Ø¹Ø©
  if (pred.final !== 'â€”') {
    el('pred' + pred.final).classList.add('active');
  }
  
  let finalText = 'â€”';
  if (pred.final === 'P') finalText = 'Ù„Ø§Ø¹Ø¨';
  else if (pred.final === 'B') finalText = 'Ù…ØµØ±ÙÙŠ';
  else if (pred.final === 'T') finalText = 'ØªØ¹Ø§Ø¯Ù„';
  
  el('finalCard').textContent = finalText;
  
  // ØªØ­Ø¯ÙŠØ« Ù…Ø¤Ø´Ø± Ø§Ù„Ø«Ù‚Ø©
  updateConfidenceMeter(pred.confidence);
  
  // ØªØ­Ø¯ÙŠØ« Ù…Ø¹Ù„ÙˆÙ…Ø§Øª Ø§Ù„Ù†Ù…ÙˆØ°Ø¬
  updateModelInfo(pred);
}

function updateTrendIndicators(pred) {
  const current = { P: parseFloat(pred.P), B: parseFloat(pred.B), T: parseFloat(pred.T) };
  const previous = state.previousPredictions;
  
  ['P', 'B', 'T'].forEach(type => {
    const trendEl = el('predTrend' + type);
    if (previous[type] > 0) {
      const diff = current[type] - previous[type];
      if (diff > 2) trendEl.textContent = 'â†—';
      else if (diff < -2) trendEl.textContent = 'â†˜';
      else trendEl.textContent = 'â†’';
      trendEl.style.color = diff > 0 ? '#38b000' : diff < 0 ? '#ff006e' : '#bfb7a6';
    } else {
      trendEl.textContent = 'â†’';
    }
  });
  
  state.previousPredictions = current;
}

function updateConfidenceMeter(confidence) {
  const fill = el('confidenceFill');
  const label = el('confidenceLabel');
  
  fill.style.width = confidence + '%';
  
  if (confidence >= 70) {
    fill.className = 'confidence-fill high-confidence';
    label.textContent = 'Ø«Ù‚Ø© Ø¹Ø§Ù„ÙŠØ©';
    label.style.color = '#38b000';
  } else if (confidence >= 40) {
    fill.className = 'confidence-fill medium-confidence';
    label.textContent = 'Ø«Ù‚Ø© Ù…ØªÙˆØ³Ø·Ø©';
    label.style.color = '#d4af37';
  } else {
    fill.className = 'confidence-fill';
    label.textContent = 'Ø«Ù‚Ø© Ù…Ù†Ø®ÙØ¶Ø©';
    label.style.color = '#ff006e';
  }
}

function updateModelInfo(pred) {
  const modelEl = el('predModel');
  const modelInfoEl = el('modelInfo');
  const reasonEl = el('predictionReason');
  
  let modelName, modelClass, reason;
  
  switch(pred.model) {
    case 'basic':
      modelName = 'Ø£Ø³Ø§Ø³ÙŠ';
      modelClass = 'badge-basic';
      reason = 'ÙŠØ¹ØªÙ…Ø¯ Ø¹Ù„Ù‰ ØªØ­Ù„ÙŠÙ„ Ø§Ù„ØªØ±Ø¯Ø¯ Ø§Ù„Ø£Ø³Ø§Ø³ÙŠ';
      break;
    case 'advanced':
      modelName = 'Ù…ØªÙ‚Ø¯Ù…';
      modelClass = 'badge-advanced';
      reason = 'ÙŠØ¬Ù…Ø¹ Ø¨ÙŠÙ† ØªØ­Ù„ÙŠÙ„ Ø§Ù„ØªØ±Ø¯Ø¯ ÙˆØ§Ù„Ø£Ù†Ù…Ø§Ø·';
      break;
    case 'pattern':
      modelName = 'Ø§Ù„Ø£Ù†Ù…Ø§Ø·';
      modelClass = 'badge-pattern';
      reason = 'ÙŠØ±ÙƒØ² Ø¹Ù„Ù‰ ØªØ­Ù„ÙŠÙ„ Ø§Ù„ØªØ³Ù„Ø³Ù„Ø§Øª ÙˆØ§Ù„Ø£Ù†Ù…Ø§Ø·';
      break;
  }
  
  modelEl.textContent = modelName;
  modelEl.className = 'model-badge ' + modelClass;
  modelInfoEl.textContent = `Ø§Ù„Ù†Ù…ÙˆØ°Ø¬: ${modelName} - Ø§Ù„ÙƒÙØ§Ø¡Ø©: ${calculateModelEfficiency()}%`;
  
  if (pred.final === 'â€”') {
    reasonEl.textContent = 'Ø¹Ø¯Ù… ÙƒÙØ§ÙŠØ© Ø§Ù„Ø«Ù‚Ø© Ù„Ù„ØªÙ†Ø¨Ø¤ (ØªØ­Øª ' + state.confidenceThreshold + '%)';
  } else {
    reasonEl.textContent = reason + ` - Ø§Ù„Ø«Ù‚Ø©: ${pred.confidence.toFixed(1)}%`;
  }
}

function calculateModelEfficiency() {
  const total = Object.values(state.modelPerformance).reduce((a, b) => a + b, 0);
  const current = state.modelPerformance[state.analysisMode] || 0;
  return total > 0 ? Math.round((current / total) * 100) : 0;
}

function showResult(r, pred, didWin) {
  const finalCard = el('finalCard');
  finalCard.classList.remove('win-effect', 'loss-effect');
  setTimeout(() => {
    finalCard.classList.add(didWin ? 'win-effect' : 'loss-effect');
  }, 10);
}

function updateAll() {
  renderStats();
  renderBigRoad();
  updatePredictionCounts();
  updateAccuracyStats();
  updateAccuracyChart();
  updatePatternInfo();
}

function renderStats() {
  el('pTotal').textContent = state.count.P;
  el('bTotal').textContent = state.count.B;
  el('tTotal').textContent = state.count.T;
  
  el('pWin').textContent = state.win.P;
  el('bWin').textContent = state.win.B;
  el('tWin').textContent = state.win.T;
  
  el('pLoss').textContent = state.loss.P;
  el('bLoss').textContent = state.loss.B;
  el('tLoss').textContent = state.loss.T;
  
  el('pPct').textContent = calculatePercentage(state.win.P, state.loss.P);
  el('bPct').textContent = calculatePercentage(state.win.B, state.loss.B);
  el('tPct').textContent = calculatePercentage(state.win.T, state.loss.T);
  
  // Ø¯Ù‚Ø© Ø§Ù„ØªÙ†Ø¨Ø¤ Ù„ÙƒÙ„ Ù†ÙˆØ¹
  el('pAccuracy').textContent = calculateAccuracy('P');
  el('bAccuracy').textContent = calculateAccuracy('B');
  el('tAccuracy').textContent = calculateAccuracy('T');
}

function calculatePercentage(win, loss) {
  const total = win + loss;
  return total > 0 ? ((win / total) * 100).toFixed(1) + '%' : '0%';
}

function calculateAccuracy(type) {
  const totalPredictions = state.predictionsHistory.filter(p => p.prediction === type).length;
  const correctPredictions = state.predictionsHistory.filter(p => p.prediction === type && p.correct).length;
  return totalPredictions > 0 ? ((correctPredictions / totalPredictions) * 100).toFixed(1) + '%' : '0%';
}

function renderBigRoad() {
  const canvas = el('bigRoad');
  const ctx = canvas.getContext('2d');
  ctx.clearRect(0, 0, canvas.width, canvas.height);
  
  const size = 35;
  let x = 0, y = 0;
  const maxCols = Math.floor(canvas.width / size);
  
  for (let i = 0; i < state.rounds.length; i++) {
    const r = state.rounds[i];
    
    ctx.fillStyle = r === 'P' ? '#3a86ff' : r === 'B' ? '#ff006e' : '#38b000';
    ctx.fillRect(x * size, y * size, size - 2, size - 2);
    
    ctx.fillStyle = '#ffffff';
    ctx.font = 'bold 14px Inter';
    ctx.textAlign = 'center';
    ctx.textBaseline = 'middle';
    ctx.fillText((i+1).toString(), x * size + size/2, y * size + size/2);
    
    y++;
    if (y * size >= canvas.height) {
      y = 0;
      x++;
      if (x >= maxCols) break;
    }
  }
}

function updatePredictionCounts() {
  const pred = enhancedPredict();
  updatePredictionDisplay(pred);
}

function updatePatternInfo() {
  const infoEl = el('patternInfo');
  if (state.rounds.length < 3) {
    infoEl.textContent = 'Ù„Ø§ ØªÙˆØ¬Ø¯ Ø£Ù†Ù…Ø§Ø· Ù…ÙƒØªØ´ÙØ© Ø¨Ø¹Ø¯';
    return;
  }
  
  const trend = calculateTrend(state.rounds);
  const recent = state.rounds.slice(-5);
  const pCount = recent.filter(r => r === 'P').length;
  const bCount = recent.filter(r => r === 'B').length;
  const tCount = recent.filter(r => r === 'T').length;
  
  let info = `Ø§Ù„Ø§ØªØ¬Ø§Ù‡: ${trend.direction === 'volatile' ? 'Ù…ØªÙ‚Ù„Ø¨' : trend.direction === 'mixed' ? 'Ù…Ø®ØªÙ„Ø·' : 'Ù…Ø³ØªÙ‚Ø±'}`;
  info += ` | Ø¢Ø®Ø± 5: ğŸ”µ${pCount} ğŸ”´${bCount} ğŸŸ¢${tCount}`;
  
  infoEl.textContent = info;
}

// ÙˆØ¸Ø§Ø¦Ù Ù…Ù†Ø­Ù†Ù‰ Ø§Ù„ØªÙˆÙ‚Ø¹Ø§Øª
function updateAccuracyData(actualResult) {
  if (state.lastPrediction && state.lastPrediction !== 'â€”') {
    const isCorrect = state.lastPrediction === actualResult;
    state.predictionsHistory.push({
      prediction: state.lastPrediction,
      actual: actualResult,
      correct: isCorrect,
      model: state.analysisMode
    });
    
    const correctPredictions = state.predictionsHistory.filter(p => p.correct).length;
    const totalPredictions = state.predictionsHistory.length;
    const accuracy = totalPredictions > 0 ? (correctPredictions / totalPredictions) * 100 : 0;
    
    state.accuracyHistory.push(accuracy);
  }
}

function updateAccuracyStats() {
  if (state.accuracyHistory.length === 0) {
    el('currentAccuracy').textContent = '0%';
    el('bestAccuracy').textContent = '0%';
    el('averageAccuracy').textContent = '0%';
    el('modelEfficiency').textContent = '0%';
    return;
  }
  
  const currentAccuracy = state.accuracyHistory[state.accuracyHistory.length - 1];
  const bestAccuracy = Math.max(...state.accuracyHistory);
  const averageAccuracy = state.accuracyHistory.reduce((a, b) => a + b, 0) / state.accuracyHistory.length;
  const efficiency = calculateModelEfficiency();
  
  el('currentAccuracy').textContent = currentAccuracy.toFixed(1) + '%';
  el('bestAccuracy').textContent = bestAccuracy.toFixed(1) + '%';
  el('averageAccuracy').textContent = averageAccuracy.toFixed(1) + '%';
  el('modelEfficiency').textContent = efficiency + '%';
}

function updateAccuracyChart() {
  const svg = el('accuracyChart');
  const tooltip = el('accuracyTooltip');
  svg.innerHTML = '';
  
  if (state.accuracyHistory.length < 2) return;
  
  const width = svg.clientWidth;
  const height = svg.clientHeight;
  const padding = 20;
  
  for (let i = 0; i <= 100; i += 20) {
    const y = height - padding - (i / 100) * (height - 2 * padding);
    const line = document.createElementNS('http://www.w3.org/2000/svg', 'line');
    line.setAttribute('class', 'accuracy-grid');
    line.setAttribute('x1', padding);
    line.setAttribute('y1', y);
    line.setAttribute('x2', width - padding);
    line.setAttribute('y2', y);
    svg.appendChild(line);
    
    const text = document.createElementNS('http://www.w3.org/2000/svg', 'text');
    text.setAttribute('x', padding - 5);
    text.setAttribute('y', y + 4);
    text.setAttribute('text-anchor', 'end');
    text.setAttribute('fill', 'var(--muted)');
    text.setAttribute('font-size', '10px');
    text.textContent = i + '%';
    svg.appendChild(text);
  }
  
  const path = document.createElementNS('http://www.w3.org/2000/svg', 'path');
  let pathData = '';
  
  state.accuracyHistory.forEach((accuracy, index) => {
    const x = padding + (index / (state.accuracyHistory.length - 1)) * (width - 2 * padding);
    const y = height - padding - (accuracy / 100) * (height - 2 * padding);
    
    if (index === 0) {
      pathData = `M ${x} ${y}`;
    } else {
      pathData += ` L ${x} ${y}`;
    }
    
    const point = document.createElementNS('http://www.w3.org/2000/svg', 'circle');
    point.setAttribute('class', 'accuracy-point');
    point.setAttribute('cx', x);
    point.setAttribute('cy', y);
    point.setAttribute('data-index', index);
    
    point.addEventListener('mouseover', (e) => {
      const rect = svg.getBoundingClientRect();
      tooltip.style.left = (e.clientX - rect.left + 10) + 'px';
      tooltip.style.top = (e.clientY - rect.top - 30) + 'px';
      tooltip.textContent = `Ø§Ù„Ø¬ÙˆÙ„Ø© ${index + 1}: ${accuracy.toFixed(1)}%`;
      tooltip.style.opacity = '1';
    });
    
    point.addEventListener('mouseout', () => {
      tooltip.style.opacity = '0';
    });
    
    svg.appendChild(point);
  });
  
  path.setAttribute('d', pathData);
  path.setAttribute('class', 'accuracy-line');
  svg.appendChild(path);
}

window.onload = init;
</script>
</body>
</html>
