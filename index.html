<!doctype html>
<html lang="ar" dir="rtl">
<head>
<meta charset="utf-8">
<meta name="viewport" content="width=device-width,initial-scale=1">
<title>AYOUB BACCARAT PRO - ูุน ูุณุงุนุฏ ุตูุชู ูุชุญุฏุซ</title>
<style>
@import url('https://fonts.googleapis.com/css2?family=Inter:wght@300;400;600;800&display=swap');
:root{--gold:#d4af37;--gold-2:#b8871d;--bg-dark:#070606;--card:#0f0e10;--muted:#bfb7a6;--player:#2d7ef7;--banker:#e03b3b;--tie:#28a745;}
:root[data-theme="light"]{--gold:#d4af37;--gold-2:#b8871d;--bg-dark:#f5f5f5;--card:#ffffff;--muted:#666666;--player:#2d7ef7;--banker:#e03b3b;--tie:#28a745;}
*{box-sizing:border-box;margin:0;padding:0;}
body{font-family:Inter,sans-serif;margin:0;background:linear-gradient(180deg,var(--bg-dark),#0b0b0b);color:#fff;padding:18px;transition:background 0.3s, color 0.3s;min-height:100vh;}
:root[data-theme="light"] body{color:#333;}
.app{max-width:1200px;margin:0 auto;width:100%;}
.top{display:flex;align-items:center;justify-content:space-between;gap:12px;margin-bottom:14px;flex-wrap:wrap;}
.logo{font-weight:800;background:linear-gradient(90deg,var(--gold),#fff3b0);color:#000;padding:8px 12px;border-radius:12px;display:inline-block;font-size:1.2rem;}
.subtitle{font-size:14px;color:var(--muted);margin-top:4px;}
.controls{display:flex;gap:8px;align-items:center;flex-wrap:wrap;}
.card{background:linear-gradient(180deg,var(--card),#0b0b0b);border-radius:12px;padding:12px;box-shadow:0 8px 30px rgba(0,0,0,0.6);border:1px solid rgba(212,175,55,0.08);margin-bottom:10px;}
:root[data-theme="light"] .card{background:linear-gradient(180deg,var(--card),#f0f0f0);box-shadow:0 8px 30px rgba(0,0,0,0.1);border:1px solid rgba(0,0,0,0.05);}
.layout{display:flex;gap:12px;flex-wrap:wrap;}
.left{width:360px;min-width:300px;display:flex;flex-direction:column;gap:10px;flex:1;}
.right{flex:2;display:flex;flex-direction:column;gap:12px;min-width:300px;}
.panel{padding:10px;}
.row{display:flex;gap:8px;align-items:center;margin-top:8px;}
input[type=number], select{background:rgba(255,255,255,0.1);border:2px solid rgba(255,255,255,0.3);padding:10px;border-radius:8px;color:#fff;font-weight:600;font-size:14px;width:100%;}
:root[data-theme="light"] input[type=number], :root[data-theme="light"] select{background:rgba(255,255,255,0.9);border:2px solid rgba(0,0,0,0.2);color:#333;}
.btn{padding:12px 16px;border-radius:8px;border:0;color:#fff;cursor:pointer;font-weight:600;font-size:16px;transition:all 0.3s;text-align:center;min-width:70px;}
.btn:hover{transform:translateY(-2px);box-shadow:0 4px 12px rgba(0,0,0,0.3);}
.btn:active{transform:translateY(0);}
.btn.gold{background:linear-gradient(90deg,var(--gold),var(--gold-2));color:#000;font-weight:700;box-shadow:0 6px 20px rgba(212,175,55,0.3);}

/* ุฃููุงู ูุงุถุญุฉ ูููุถุน ุงููููู */
.btn.player{background:linear-gradient(135deg, #3a86ff, #2667cc); color:white; border:2px solid #3a86ff;}
.btn.banker{background:linear-gradient(135deg, #ff006e, #cc0058); color:white; border:2px solid #ff006e;}
.btn.tie{background:linear-gradient(135deg, #38b000, #2c8a00); color:white; border:2px solid #38b000;}

/* ุฃููุงู ุงููุถุน ุงูููุงุฑู */
:root[data-theme="light"] .btn.player{background:linear-gradient(135deg, #2d7ef7, #1a67d8); color:white;}
:root[data-theme="light"] .btn.banker{background:linear-gradient(135deg, #e03b3b, #c53232); color:white;}
:root[data-theme="light"] .btn.tie{background:linear-gradient(135deg, #28a745, #218838); color:white;}

:root[data-theme="light"] .btn{background:rgba(0,0,0,0.1);color:#333; border:1px solid rgba(0,0,0,0.1)}

.small{font-size:13px;color:var(--muted);}
.muted{color:var(--muted);font-size:12px;}
.pattern-list{list-style:none;padding:6px;margin:6px 0 0 0;max-height:200px;overflow:auto;}
.pattern-list li{padding:8px;border-radius:8px;margin-bottom:6px;background:linear-gradient(180deg,rgba(255,255,255,0.02),transparent);display:flex;justify-content:space-between;align-items:center;}
:root[data-theme="light"] .pattern-list li{background:linear-gradient(180deg,rgba(0,0,0,0.02),transparent);}
.section-title{font-weight:700;margin-bottom:6px;color:var(--gold);font-size:1.1rem;}
.stat-table{width:100%;border-collapse:collapse;font-size:13px;}
.stat-table th,.stat-table td{border:1px solid rgba(255,255,255,0.05);padding:6px;text-align:center;}
:root[data-theme="light"] .stat-table th, :root[data-theme="light"] .stat-table td{border:1px solid rgba(0,0,0,0.05);}
.stat-table th{background:rgba(212,175,55,0.1);font-weight:600;}
.player{color:#3a86ff;font-weight:700;}
.banker{color:#ff006e;font-weight:700;}
.tie{color:#38b000;font-weight:700;}
.pred-head{display:flex;justify-content:space-between;align-items:center;flex-wrap:wrap;gap:10px;}
.final{font-size:22px;font-weight:800;text-align:center;padding:12px;background:linear-gradient(90deg,rgba(212,175,55,0.06),transparent);border-radius:10px;margin:10px 0;}
:root[data-theme="light"] .final{background:linear-gradient(90deg,rgba(212,175,55,0.1),transparent);}
.foot{display:flex;justify-content:space-between;align-items:center;margin-top:14px;flex-wrap:wrap;gap:10px;}
.credits{opacity:0.85;font-size:12px;}
canvas{border-radius:10px;background:#0f0e10;width:100% !important;height:auto !important;max-height:450px;}
:root[data-theme="light"] canvas{background:#f0f0f0;}
.color-legend{display:flex;gap:15px;justify-content:center;margin-bottom:10px;font-size:14px;flex-wrap:wrap;}
.color-legend span{padding:4px 8px;border-radius:6px; font-weight:600;}
.prediction-cards{display:flex;gap:10px;justify-content:center;margin:10px 0;flex-wrap:wrap;}
.pred-card{padding:10px;border-radius:8px;text-align:center;min-width:80px; font-weight:600;flex:1;}
.pred-card.active{transform:scale(1.05);border:2px solid var(--gold); box-shadow:0 4px 15px rgba(212,175,55,0.4);}
.win-effect{animation:winPulse 0.5s ease-in-out;}
.loss-effect{animation:lossShake 0.5s ease-in-out;}
@keyframes winPulse{0%{transform:scale(1)}50%{transform:scale(1.1)}100%{transform:scale(1)}}
@keyframes lossShake{0%,100%{transform:translateX(0)}25%{transform:translateX(-5px)}75%{transform:translateX(5px)}}
.analysis-result{margin-top:10px;padding:10px;background:rgba(255,255,255,0.03);border-radius:8px;text-align:center;}
:root[data-theme="light"] .analysis-result{background:rgba(0,0,0,0.03);}
.theme-toggle{background:transparent;border:none;font-size:24px;cursor:pointer;padding:5px;border-radius:50%;transition:background 0.3s;width:40px;height:40px;display:flex;align-items:center;justify-content:center;}
.theme-toggle:hover{background:rgba(255,255,255,0.1);}
:root[data-theme="light"] .theme-toggle:hover{background:rgba(0,0,0,0.05);}

/* ุชุญุณููุงุช ุฅุถุงููุฉ ููุญููู */
.input-group {display: flex; gap: 8px; align-items:center;}
.input-group input {flex: 1;}
.input-label {font-weight: 600; margin-bottom: 6px; display: block;}

/* ุฃููุงู ุงูุจุทุงูุงุช ูู ุงูุชููุน */
.pred-card.player {background: linear-gradient(135deg, #3a86ff, #2667cc); color: white;}
.pred-card.banker {background: linear-gradient(135deg, #ff006e, #cc0058); color: white;}
.pred-card.tie {background: linear-gradient(135deg, #38b000, #2c8a00); color: white;}

/* ุฃููุงุท ูููุญูู ุงูุชููุนุงุช */
.accuracy-panel {margin-top: 12px;}
.accuracy-stats {display: flex; justify-content: space-between; margin-bottom: 8px; flex-wrap: wrap; gap: 10px;}
.accuracy-stats > div {flex: 1; min-width: 120px;}
.accuracy-value {font-weight: 700; font-size: 18px;}
.accuracy-label {font-size: 12px; color: var(--muted);}
.accuracy-chart-container {position: relative; height: 80px; margin-top: 8px; width: 100%;}
.accuracy-line {stroke: var(--gold); stroke-width: 2; fill: none;}
.accuracy-point {fill: var(--gold); r: 3; transition: r 0.2s;}
.accuracy-point:hover {r: 5;}
.accuracy-grid {stroke: rgba(255,255,255,0.1); stroke-width: 1;}
:root[data-theme="light"] .accuracy-grid {stroke: rgba(0,0,0,0.1);}
.accuracy-tooltip {position: absolute; background: rgba(0,0,0,0.9); color: white; padding: 5px 8px; border-radius: 4px; font-size: 12px; pointer-events: none; opacity: 0; transition: opacity 0.2s; z-index: 100;}

/* ุฃููุงุท ุฌุฏูุฏุฉ ูููุงุฌูุฉ ุงููุญุณูุฉ */
.advanced-controls {background: rgba(212,175,55,0.05); border-radius: 8px; padding: 10px; margin-top: 8px;}
.control-group {display: flex; justify-content: space-between; align-items: center; margin-bottom: 8px; flex-wrap: wrap;}
.control-group:last-child {margin-bottom: 0;}
.slider-container {flex: 1; margin-left: 10px; min-width: 150px;}
.slider {width: 100%;}
.model-badge {display: inline-block; padding: 2px 8px; border-radius: 12px; font-size: 10px; font-weight: 600; margin-left: 5px;}
.badge-basic {background: #3a86ff; color: white;}
.badge-advanced {background: #ff006e; color: white;}
.badge-pattern {background: #38b000; color: white;}
.badge-ml {background: #9d4edd; color: white;}
.pattern-info {font-size: 11px; color: var(--muted); margin-top: 4px; line-height: 1.4;}
.confidence-meter {height: 6px; background: rgba(255,255,255,0.1); border-radius: 3px; margin-top: 4px; overflow: hidden;}
.confidence-fill {height: 100%; background: linear-gradient(90deg, #38b000, #ff006e); border-radius: 3px; transition: width 0.3s;}
.high-confidence {background: linear-gradient(90deg, #38b000, #d4af37);}
.medium-confidence {background: linear-gradient(90deg, #d4af37, #ff006e);}

/* ุชุจุฏูู ุฒุฑ ุงูุชุนูู ุงูุขูู */
.switch {position: relative; display: inline-block; width: 50px; height: 24px; flex-shrink: 0;}
.switch input {opacity: 0; width: 0; height: 0;}
.switch .slider {position: absolute; cursor: pointer; top: 0; left: 0; right: 0; bottom: 0; background-color: #ccc; transition: .4s; border-radius: 34px;}
.switch .slider:before {position: absolute; content: ""; height: 16px; width: 16px; left: 4px; bottom: 4px; background-color: white; transition: .4s; border-radius: 50%;}
.switch input:checked + .slider {background: linear-gradient(90deg, #9d4edd, #7b2cbf);}
.switch input:checked + .slider:before {transform: translateX(26px);}

/* ูุคุดุฑ ุชุฏุฑูุจ ML */
.ml-training-indicator {display: inline-block; width: 10px; height: 10px; border-radius: 50%; margin-right: 5px;}
.ml-training {background: #38b000; animation: pulse 1.5s infinite;}
.ml-not-trained {background: #ff006e;}
@keyframes pulse {0% {opacity: 1;} 50% {opacity: 0.5;} 100% {opacity: 1;}}

/* ุชุญุณููุงุช ูููุงุฌูุฉ */
.ml-info-panel {background: rgba(157, 78, 221, 0.05); border-left: 3px solid #9d4edd;}

/* ุฃุฒุฑุงุฑ ุงูุชุญูู ูู ุงูุจูุงูุงุช */
.data-controls {display: flex; gap: 8px; flex-wrap: wrap; margin-top: 8px;}
.data-controls .btn {padding: 6px 10px; font-size: 12px; flex: 1; min-width: 100px;}

/* === ุฃููุงุท ุฌุฏูุฏุฉ ูููุณุงุนุฏ ุงูุตูุชู === */
.voice-assistant {background: linear-gradient(180deg, rgba(59, 130, 246, 0.1), rgba(0, 0, 0, 0.1)); border: 1px solid rgba(59, 130, 246, 0.2);}
.assistant-controls {display: flex; flex-direction: column; gap: 10px;}
.conversation-container {max-height: 200px; overflow-y: auto; margin-top: 10px; padding: 10px; background: rgba(0,0,0,0.2); border-radius: 8px;}
.conversation-bubble {margin: 8px 0; padding: 10px; border-radius: 12px; max-width: 90%;}
.user-bubble {background: linear-gradient(135deg, #3a86ff, #2667cc); color: white; margin-left: auto; text-align: left;}
.assistant-bubble {background: linear-gradient(135deg, #38b000, #2c8a00); color: white; margin-right: auto;}
.mic-animation {display: inline-block; animation: micPulse 1.5s infinite; font-size: 20px;}
@keyframes micPulse {0% {transform: scale(1);} 50% {transform: scale(1.2);} 100% {transform: scale(1);}}
.voice-wave {display: flex; gap: 2px; height: 20px; align-items: center; justify-content: center; margin-top: 5px;}
.wave-bar {width: 3px; background: #3a86ff; border-radius: 2px; animation: wave 1s ease-in-out infinite;}
.wave-bar:nth-child(2) {animation-delay: 0.1s;}
.wave-bar:nth-child(3) {animation-delay: 0.2s;}
.wave-bar:nth-child(4) {animation-delay: 0.3s;}
.wave-bar:nth-child(5) {animation-delay: 0.4s;}
@keyframes wave {0%, 100% {height: 5px;} 50% {height: 20px;}}
.typing-indicator {display: flex; gap: 4px; padding: 10px; background: rgba(59, 130, 246, 0.2); border-radius: 8px; margin-top: 5px;}
.typing-dot {width: 6px; height: 6px; background: #3a86ff; border-radius: 50%; animation: typing 1.4s infinite;}
.typing-dot:nth-child(2) {animation-delay: 0.2s;}
.typing-dot:nth-child(3) {animation-delay: 0.4s;}
@keyframes typing {0%, 100% {transform: translateY(0);} 50% {transform: translateY(-5px);}}
.quick-responses {display: flex; flex-wrap: wrap; gap: 5px; margin-top: 10px;}
.quick-response {padding: 6px 10px; background: rgba(255,255,255,0.1); border-radius: 20px; font-size: 12px; cursor: pointer; transition: all 0.3s;}
.quick-response:hover {background: rgba(59, 130, 246, 0.3); transform: scale(1.05);}
.voice-settings {background: rgba(0,0,0,0.2);}
.emotion-indicator {display: inline-block; font-size: 18px; margin-right: 5px;}
.speaking-indicator {display: inline-flex; align-items: center; gap: 5px; margin-left: 10px;}
.speaking-dot {width: 8px; height: 8px; background: #ff006e; border-radius: 50%; animation: speaking 1s infinite;}
@keyframes speaking {0%, 100% {opacity: 0.3;} 50% {opacity: 1;}}

/* ุชุญุณููุงุช ููุงุณุชุฌุงุจุฉ */
@media (max-width: 768px) {
    .layout {flex-direction: column;}
    .left, .right {width: 100%;}
    .top {flex-direction: column; align-items: flex-start;}
    .controls {width: 100%; justify-content: space-between;}
    .accuracy-stats > div {min-width: 100px;}
    .prediction-cards {flex-direction: column;}
    .pred-card {width: 100%;}
    .color-legend {justify-content: flex-start;}
    .row {flex-wrap: wrap;}
    .btn {flex: 1; min-width: 60px;}
    .conversation-container {max-height: 150px;}
}

@media (max-width: 480px) {
    body {padding: 10px;}
    .card {padding: 8px;}
    .btn {padding: 10px 12px; font-size: 14px;}
    .accuracy-stats {flex-direction: column;}
    .accuracy-stats > div {min-width: 100%;}
    .quick-responses {flex-direction: column;}
}
</style>
</head>
<body>
<div class="app">
<header class="top card">
  <div class="brand">
    <div class="logo">AYOUB BACCARAT PRO <span class="model-badge badge-ml">ูุณุฎุฉ ูุงููุฉ</span></div>
    <div class="subtitle">ูุธุงู ุชูุจุค ุฐูู ูุน ุฎูุงุฑุฒููุงุช ุชุนูู ุขูุฉ ูุญูุธ ุชููุงุฆู ๐ง๐พ๐</div>
  </div>
  <div class="controls">
    <button id="themeToggle" class="theme-toggle" title="ุชุจุฏูู ุงููุถุน">๐</button>
    <button id="btnReset" class="btn gold">ุฅุนุงุฏุฉ ุชุนููู</button>
  </div>
</header>

<main class="layout">
<aside class="left">
  <div class="panel card">
    <label class="input-label">ูุงูุฐุฉ ุงูุชุญููู (5 - 15)</label>
    <div class="input-group">
      <input id="windowSize" type="number" min="5" max="15" value="8">
      <button id="applyWindow" class="btn gold">ุชุทุจูู</button>
    </div>
    <div class="muted small">ูุญูู ุขุฎุฑ 5-15 ุฌููุฉ ุจุงุณุชุฎุฏุงู ุฎูุงุฑุฒููุงุช ูุชูุฏูุฉ</div>
  </div>

  <!-- ุฅุนุฏุงุฏุงุช ุงูุชูุจุค ุงููุชูุฏู -->
  <div class="panel card">
    <div class="section-title">ุฅุนุฏุงุฏุงุช ุงูุชูุจุค ุงููุชูุฏู</div>
    <div class="advanced-controls">
      <div class="control-group">
        <label for="analysisMode">ููุท ุงูุชุญููู:</label>
        <select id="analysisMode">
          <option value="basic">ุฃุณุงุณู <span class="model-badge badge-basic">+5%</span></option>
          <option value="advanced" selected>ูุชูุฏู <span class="model-badge badge-advanced">+15%</span></option>
          <option value="pattern">ุชุญููู ุงูุฃููุงุท <span class="model-badge badge-pattern">+25%</span></option>
          <option value="ml">ุชุนูู ุงูุขูุฉ <span class="model-badge badge-ml">+35%</span></option>
        </select>
      </div>
      <div class="control-group">
        <label for="confidenceSensitivity">ุญุณุงุณูุฉ ุงูุซูุฉ:</label>
        <div class="slider-container">
          <input type="range" id="confidenceSensitivity" class="slider" min="30" max="60" value="45">
          <div class="muted small" id="sensitivityValue">45%</div>
        </div>
      </div>
      <div class="control-group">
        <label for="timeWeighting">ุงููุฑุฌุญุฉ ุงูุฒูููุฉ:</label>
        <select id="timeWeighting">
          <option value="none">ุจุฏูู</option>
          <option value="linear" selected>ุฎุทู</option>
          <option value="exponential">ุฃุณูู</option>
        </select>
      </div>
    </div>
  </div>

  <!-- ูุณู ุชุนูู ุงูุขูุฉ -->
  <div class="panel card ml-info-panel">
    <div class="section-title">โ๏ธ ุชุนูู ุงูุขูุฉ</div>
    <div class="row">
      <label class="switch">
        <input type="checkbox" id="mlToggle" checked>
        <span class="slider"></span>
      </label>
      <span>ุชูุนูู ุชุนูู ุงูุขูุฉ</span>
    </div>
    <div class="row">
      <select id="mlModelSelect" style="flex:1; margin-top: 5px;">
        <option value="knn">K-ุงูุฌูุฑุงู ุงูุฃูุฑุจ</option>
        <option value="logistic">ุงูุงูุญุฏุงุฑ ุงูููุฌุณุชู</option>
        <option value="ensemble" selected>ุงููุฌูุน (ุฌููุน ุงูููุงุฐุฌ)</option>
      </select>
    </div>
    <div class="row">
      <div id="mlStatus" class="muted small">
        <span class="ml-training-indicator ml-training"></span> 
        ุงููููุฐุฌ ูุชุนูู ูู ุงูุจูุงูุงุช...
      </div>
    </div>
    <div class="pattern-info">
      <span id="mlTrainingCount">0</span> ุนููุฉ ุชุฏุฑูุจ โข 
      <span id="mlAccuracy">0%</span> ุฏูุฉ โข 
      <span id="mlWeight">30%</span> ุชุฃุซูุฑ
    </div>
  </div>

  <!-- ุงููุณุงุนุฏ ุงูุตูุชู ุงูุฐูู -->
  <div class="panel card voice-assistant">
    <div class="section-title">๐ค ุงููุณุงุนุฏ ุงูุตูุชู ุงูุฐูู (Grimi)</div>
    
    <div class="assistant-controls">
      <div class="row">
        <button id="voiceToggle" class="btn gold" style="flex: 1;">
          <span id="voiceIcon">๐ค</span> <span id="voiceStatus">ุชุดุบูู ุงููุณุงุนุฏ</span>
        </button>
        <button id="voiceMood" class="btn" style="background: rgba(157, 78, 221, 0.2);">
          <span id="moodIcon">๐</span>
        </button>
      </div>
      
      <div class="row" style="margin-top: 5px;">
        <button id="listenBtn" class="btn" style="flex: 1; background: rgba(255, 107, 107, 0.2); border: 1px solid #ff6b6b;">
          <span id="listenIcon">๐</span> <span id="listenText">ุงุณุชูุน ุฅููู</span>
        </button>
        <button id="stopSpeakingBtn" class="btn" style="background: rgba(255, 193, 7, 0.2); border: 1px solid #ffc107;">
          <span>โธ๏ธ</span> ุฅููุงู
        </button>
      </div>
      
      <div class="voice-wave" id="voiceWave" style="display: none;">
        <div class="wave-bar"></div>
        <div class="wave-bar"></div>
        <div class="wave-bar"></div>
        <div class="wave-bar"></div>
        <div class="wave-bar"></div>
      </div>
      
      <div class="voice-settings advanced-controls" style="margin-top: 10px;">
        <div class="control-group">
          <label for="voiceStyle">ุฃุณููุจ ุงููุญุงุฏุซุฉ:</label>
          <select id="voiceStyle">
            <option value="friendly">ูุฏูุฏ (ูุซู ุตุฏูู)</option>
            <option value="professional">ุงุญุชุฑุงูู (ูุณุชุดุงุฑ)</option>
            <option value="motivational" selected>ุชุญููุฒู (ูุฏุฑุจ)</option>
            <option value="funny">ููุชุน (ูุฑุญ)</option>
          </select>
        </div>
        <div class="control-group">
          <label for="assistantTopics">ุงูููุงุถูุน ุงูููุถูุฉ:</label>
          <select id="assistantTopics">
            <option value="all">ุฌููุน ุงูููุงุถูุน</option>
            <option value="gaming" selected>ูุตุงุฆุญ ุงููุนุจ</option>
            <option value="psychology">ุนูู ุงูููุณ</option>
            <option value="motivation">ุชุญููุฒ</option>
          </select>
        </div>
      </div>
    </div>
    
    <div class="conversation-container" id="conversationContainer">
      <!-- ุงููุญุงุฏุซุงุช ุณุชุธูุฑ ููุง -->
      <div class="conversation-bubble assistant-bubble">
        <span class="emotion-indicator">๐</span> 
        ูุฑุญุจูุง! ุฃูุง Grimiุ ูุณุงุนุฏู ุงูุตูุชู ุงูุฐูู. ุงุถุบุท ุนูู "ุงุณุชูุน ุฅููู" ูุงุจุฏุฃ ุจุงูุชุญุฏุซ ูุนู!
        <div class="speaking-indicator" style="display: none;" id="speakingIndicator">
          <span class="speaking-dot"></span>
          <span class="speaking-dot"></span>
          <span class="speaking-dot"></span>
        </div>
      </div>
    </div>
    
    <div class="typing-indicator" id="typingIndicator" style="display: none;">
      <div class="typing-dot"></div>
      <div class="typing-dot"></div>
      <div class="typing-dot"></div>
    </div>
    
    <div class="quick-responses" id="quickResponses">
      <div class="quick-response" data-question="ููู ุฃุชุญูู ูู ุฃุนุตุงุจูุ">๐ฏ ุงูุชุญูู ูู ุงูุฃุนุตุงุจ</div>
      <div class="quick-response" data-question="ูุตูุญุฉ ูููุฉ ููุนุจ">๐ก ูุตุงุฆุญ ุฐูุจูุฉ</div>
      <div class="quick-response" data-question="ููู ูุงู ููููุ">๐ ููู ุญุงููุ</div>
      <div class="quick-response" data-question="ุฃุฎุจุฑูู ููุชุฉ">๐ ุงุถุญููู</div>
    </div>
    
    <div class="muted small" style="margin-top: 10px; text-align: center;">
      ๐ ุงููุณุงุนุฏ ูุชุญุฏุซ ูุนู ุตูุชูุงู! ุฌุฑูุจ ุชููู: "ูุฑุญุจุงู" ุฃู "ููู ุญุงููุ"
    </div>
  </div>

  <!-- ุฅุฏุฎุงู ุงููุชุงุฆุฌ -->
  <div class="panel card">
    <div class="section-title">ุฅุฏุฎุงู ุงููุชุงุฆุฌ</div>
    <div class="row">
      <button class="btn player" id="btnP">ูุงุนุจ ๐ต</button>
      <button class="btn banker" id="btnB">ูุตุฑูู ๐ด</button>
      <button class="btn tie" id="btnT">ุชุนุงุฏู ๐ข</button>
    </div>
    <div class="row">
      <button class="btn" id="btnUndo" style="flex:1; background:rgba(255,255,255,0.1); border:1px solid rgba(255,255,255,0.2)">ุชุฑุงุฌุน</button>
    </div>
    <div class="muted small" style="margin-top: 8px; text-align: center;">
      ุฃุฏุฎู ูุชูุฌุฉ ูู ุฌููุฉ ุจุงูุถุบุท ุนูู ุงูุฒุฑ ุงูููุงุณุจ
    </div>
  </div>

  <!-- ุงูุฅุญุตุงุกุงุช -->
  <div class="panel card stats">
    <div class="section-title">ุงูุฅุญุตุงุกุงุช ุงููุชูุฏูุฉ</div>
    <table class="stat-table">
      <thead>
        <tr><th>ุงูุฌูุฉ</th><th>ุงููุฌููุน</th><th>ููุฒ</th><th>ุฎุณุงุฑุฉ</th><th>ูุณุจุฉ %</th><th>ุฏูุฉ</th><th>ML ุฏูุฉ</th></tr>
      </thead>
      <tbody>
        <tr><td class="player">ูุงุนุจ</td><td id="pTotal">0</td><td id="pWin">0</td><td id="pLoss">0</td><td id="pPct">0%</td><td id="pAccuracy">0%</td><td id="pMLAccuracy">0%</td></tr>
        <tr><td class="banker">ูุตุฑูู</td><td id="bTotal">0</td><td id="bWin">0</td><td id="bLoss">0</td><td id="bPct">0%</td><td id="bAccuracy">0%</td><td id="bMLAccuracy">0%</td></tr>
        <tr><td class="tie">ุชุนุงุฏู</td><td id="tTotal">0</td><td id="tWin">0</td><td id="tLoss">0</td><td id="tPct">0%</td><td id="tAccuracy">0%</td><td id="tMLAccuracy">0%</td></tr>
      </tbody>
    </table>
    <div class="pattern-info" id="patternInfo">ูุง ุชูุฌุฏ ุฃููุงุท ููุชุดูุฉ ุจุนุฏ</div>
  </div>

  <!-- ูุคุดุฑ ุงูุซูุฉ -->
  <div class="panel card">
    <div class="section-title">ูุคุดุฑ ุงูุซูุฉ</div>
    <div class="muted small" id="confidenceLabel">ุซูุฉ ููุฎูุถุฉ</div>
    <div class="confidence-meter">
      <div class="confidence-fill" id="confidenceFill" style="width: 0%"></div>
    </div>
    <div class="pattern-info" id="modelInfo">ุงููููุฐุฌ: ุฃุณุงุณู</div>
  </div>
</aside>

<section class="right">
  <div class="card prediction">
    <div class="pred-head">
      <div class="pred-title">ุชููุน ุงูุฌููุฉ ุงููุงุฏูุฉ <span id="predModel" class="model-badge badge-basic">ุฃุณุงุณู</span></div>
      <div class="pred-sub">ูุธุงู ุชูุจุค ูุชุนุฏุฏ ุงูููุงุฐุฌ ูุน ุฎูุงุฑุฒููุงุช ุชุนูู ุขูุฉ</div>
    </div>

    <div class="color-legend">
      <span style="background:linear-gradient(135deg, #3a86ff, #2667cc);">๐ต ูุงุนุจ</span>
      <span style="background:linear-gradient(135deg, #ff006e, #cc0058);">๐ด ูุตุฑูู</span>
      <span style="background:linear-gradient(135deg, #38b000, #2c8a00);">๐ข ุชุนุงุฏู</span>
    </div>
    
    <canvas id="bigRoad" width="800" height="450"></canvas>

    <div class="prediction-cards">
      <div class="pred-card player" id="predP">
        <div>ูุงุนุจ</div>
        <div id="predPctP">0%</div>
        <div class="muted small" id="predTrendP">โ</div>
      </div>
      <div class="pred-card banker" id="predB">
        <div>ูุตุฑูู</div>
        <div id="predPctB">0%</div>
        <div class="muted small" id="predTrendB">โ</div>
      </div>
      <div class="pred-card tie" id="predT">
        <div>ุชุนุงุฏู</div>
        <div id="predPctT">0%</div>
        <div class="muted small" id="predTrendT">โ</div>
      </div>
    </div>

    <div class="analysis-result">
      <div class="muted">ุงูุชููุน ุงูุญุงูู:</div>
      <div class="final" id="finalCard">โ</div>
      <div class="muted small" id="predictionReason">ุจุงูุชุธุงุฑ ุจูุงูุงุช ูุงููุฉ ููุชุญููู</div>
      <div class="muted small" id="mlContribution" style="margin-top: 5px; color: #9d4edd;"></div>
    </div>
  </div>

  <!-- ููุญูู ุงูุชููุนุงุช -->
  <div class="panel card accuracy-panel">
    <div class="section-title">ููุญูู ุฏูุฉ ุงูุชููุนุงุช ุงููุชูุฏู</div>
    <div class="accuracy-stats">
      <div>
        <div class="accuracy-label">ุงูุฏูุฉ ุงูุญุงููุฉ</div>
        <div class="accuracy-value" id="currentAccuracy">0%</div>
      </div>
      <div>
        <div class="accuracy-label">ุฃูุถู ุฏูุฉ</div>
        <div class="accuracy-value" id="bestAccuracy">0%</div>
      </div>
      <div>
        <div class="accuracy-label">ูุชูุณุท ุงูุฏูุฉ</div>
        <div class="accuracy-value" id="averageAccuracy">0%</div>
      </div>
      <div>
        <div class="accuracy-label">ุฏูุฉ ML</div>
        <div class="accuracy-value" id="mlOverallAccuracy">0%</div>
      </div>
    </div>
    <div class="accuracy-chart-container">
      <svg id="accuracyChart" width="100%" height="100%"></svg>
      <div id="accuracyTooltip" class="accuracy-tooltip"></div>
    </div>
    <div class="muted small">ุชุชุจุน ุฏูุฉ ุชููุนุงุชู ูุน ุชุญููู ุฃุฏุงุก ุงูููุงุฐุฌ ุงููุฎุชููุฉ</div>
  </div>
</section>
</main>

<footer class="foot card">
  <div style="flex: 1;">
    <div>ุชุตููู: Ayoub โข ุงููุณุฎุฉ ุงููุงููุฉ ูุน ุงูุญูุธ ุงูุชููุงุฆู ูุงููุณุงุนุฏ ุงูุตูุชู</div>
    <div class="credits small">ูุธุงู ูุชุนุฏุฏ ุงูููุงุฐุฌ โข ุชุนูู ุขูุฉ โข ุชุญููู ุงูุฃููุงุท โข ุญูุธ ุชููุงุฆู โข ูุณุงุนุฏ ุตูุชู ูุชุญุฏุซ</div>
  </div>
  <div class="data-controls">
    <button id="btnExport" class="btn" style="background: rgba(59, 130, 246, 0.2); border: 1px solid #3a86ff;">๐ฅ ุชุตุฏูุฑ</button>
    <button id="btnImport" class="btn" style="background: rgba(16, 185, 129, 0.2); border: 1px solid #10b981;">๐ค ุงุณุชูุฑุงุฏ</button>
    <button id="btnClearData" class="btn" style="background: rgba(239, 68, 68, 0.2); border: 1px solid #ef4444;">๐๏ธ ูุณุญ</button>
  </div>
  <div class="muted small" style="text-align: center; width: 100%; margin-top: 10px;">
    <span id="autoSaveStatus">๐พ ุงูุญูุธ ุงูุชููุงุฆู ููุนู</span> โข 
    <span id="dataStats">0 ุฌููุฉ โข 0 ุนููุฉ ุชุฏุฑูุจ</span>
  </div>
</footer>
</div>

<script>
// ========== ูุธุงู ุงููุณุงุนุฏ ุงูุตูุชู ุงูุฐูู ุงูุฐู ูุชุญุฏุซ ูุนููุงู ==========

class TalkingAssistant {
  constructor() {
    this.isSpeaking = false;
    this.isListening = false;
    this.currentMood = 'happy';
    this.voiceStyle = 'motivational';
    this.topics = 'gaming';
    this.conversation = [];
    
    // ุงุณุชุฎุฏุงู Web Speech API ููุชุญุฏุซ
    this.speechSynthesis = window.speechSynthesis;
    this.voices = [];
    
    // ุฃุตูุงุช ูุญุงูุงุฉ ููุชุญุฏุซ (ุจุงููุบุฉ ุงูุฅูุฌููุฒูุฉ ููุชูุงูู)
    this.voiceResponses = {
      greetings: [
        "ูุฑุญุจุงู! ููู ุญุงูู ุงููููุ",
        "ุฃููุงู ูุณููุงู! ุณุนูุฏ ุจุฑุคูุชู.",
        "ูุฑุญุจุงู ุตุฏููู! ููู ูููููู ูุณุงุนุฏุชูุ",
        "ุฃูููุง ุจู! ุงูููู ููู ุฌููู ููุนุจ."
      ],
      howAreYou: [
        "ุฃูุง ุจุฎูุฑุ ุดูุฑุงู ูุณุคุงูู! ูุณุชุนุฏ ููุณุงุนุฏุชู ูู ุงููุนุจ.",
        "ุฃุดุนุฑ ุจุฑุงุฆุน! ุฎุงุตุฉ ุนูุฏูุง ุฃุชุญุฏุซ ูุน ูุงุนุจ ุฐูู ูุซูู.",
        "ุจุญุงูุฉ ุฌูุฏุฉ! ุฃูุชุธุฑ ูุณุงุนุฏุชู ูู ุชุญุณูู ุฃุฏุงุฆู.",
        "ููุชุงุฒ! ุงูููู ููู ูุซุงูู ููููุฒ."
      ],
      gamingTips: [
        "ูุตูุญุชู ุงูุฃููู: ุชุญููู ุจุงูุตุจุฑ. ุงูุจุงูุงุฑุงุช ูุนุจุฉ ุตุจุฑ ุฃูุซุฑ ููุง ุชุธู.",
        "ุฑุงูุจ ุงูุฃููุงุท ุฌูุฏุงู. ุงูุชูุฑุงุฑ ูู ููุชุงุญ ุงููุฌุงุญ.",
        "ูุง ุชุถุน ูู ุจูุถู ูู ุณูุฉ ูุงุญุฏุฉ. ูุฒุน ุฑูุงูุงุชู ุจุญููุฉ.",
        "ุงูุชูููุช ุฃูู ูู ุงููููุฉ. ุงูุชุธุฑ ุงููุญุธุฉ ุงูููุงุณุจุฉ.",
        "ุชุนูู ูู ุฎุณุงุฑุงุชู. ูู ุฎุทุฃ ูู ุฏุฑุณ ุฌุฏูุฏ."
      ],
      psychology: [
        "ุงููุฏูุก ูู ุณุฑ ุงููุฌุงุญ. ุฎุฐ ููุณุงู ุนูููุงู ูุจู ูู ูุฑุงุฑ.",
        "ุงูุซูุฉ ูููุฉุ ูููู ุงูุซูุฉ ุงูุฒุงุฆุฏุฉ ูุฏ ุชููู ุฎุทูุฑุฉ.",
        "ุงูุนูู ุงููุงุนู ูุชุฎุฐ ูุฑุงุฑุงุช ุฃูุถู. ุงุจูู ูุฑูุฒุงู.",
        "ูุง ุชุฏุน ุงูุนูุงุทู ุชุชุญูู ูู ูุฑุงุฑุงุชู ุงููุงููุฉ."
      ],
      motivation: [
        "ุฃูุช ูุงุฏุฑ ุนูู ุชุญููู ุงููุฌุงุญ! ุซู ุจููุณู.",
        "ูู ูุญุชุฑู ุจุฏุฃ ููุจุชุฏุฆ. ุงุณุชูุฑ ูู ุงูุชุนูู.",
        "ุงูุชุญุฏูุงุช ุชุตูุน ุงูุฃุจุทุงู. ูุงุตู ุงูุชูุฏู!",
        "ุงููุฌุงุญ ุฑุญูุฉ ูููุณ ูุฌูุฉ. ุงุณุชูุชุน ุจุงูุทุฑูู."
      ],
      jokes: [
        "ูุงุฐุง ูุงู ุงูุฑูู ุตูุฑ ููุฑูู ุซูุงููุฉุ ุญุฒุงูู ุฌููู!",
        "ููุงุฐุง ุงูุฐูุจ ุฃูุถู ุตุฏููุ ูุฃูู ุฏุงุฆูุงู ูุงูุน!",
        "ูุง ูู ุงูุดูุก ุงูุฐู ูููุง ุฃุฎุฐุช ููู ููุจุฑุ ุงูุญูุฑุฉ!",
        "ููุงุฐุง ุงูููู ุฃุฌูู ูู ุงูุณููุ ูุฃูู ููุชุจ ุฏูู ุฃู ูุคุฐู!"
      ],
      thanks: [
        "ุงูุนูู! ุฏุงุฆูุงู ุณุนูุฏ ุจูุณุงุนุฏุชู.",
        "ูุง ุดูุฑ ุนูู ูุงุฌุจ! ุฃูุช ุชุณุชุญู ุงูุฃูุถู.",
        "ุดูุฑุงู ูู! ุญุฏูุซู ูุนู ูุจูุฌูู."
      ],
      farewell: [
        "ูุน ุงูุณูุงูุฉ! ุฃุชููู ูู ุญุธุงู ููููุงู.",
        "ุฅูู ุงูููุงุก! ูุง ุชูุณู ุงูููุงุฑุณุฉ ุงููุณุชูุฑุฉ.",
        "ูุฏุงุนุงู ุตุฏููู! ุฃุฑุงู ูู ุงููุฑุฉ ุงููุงุฏูุฉ."
      ]
    };
    
    this.moodIcons = {
      happy: '๐',
      excited: '๐คฉ',
      calm: '๐',
      serious: '๐ง',
      funny: '๐'
    };
    
    this.init();
  }
  
  init() {
    this.loadVoices();
    this.setupEventListeners();
    
    // ุงูุชุฑุญูุจ ุงูุฃููู
    setTimeout(() => {
      this.speak("ูุฑุญุจุงู! ุฃูุง ุฌุฑูููุ ูุณุงุนุฏู ุงูุตูุชู ุงูุดุฎุตู. ุฃูุง ููุง ูุฃุชุญุฏุซ ูุนู ูุฃูุฏู ูู ุงููุตุงุฆุญ ุฃุซูุงุก ุงููุนุจ.");
    }, 1000);
  }
  
  loadVoices() {
    // ุชุญููู ุงูุฃุตูุงุช ุงููุชุงุญุฉ
    setTimeout(() => {
      this.voices = this.speechSynthesis.getVoices();
      
      // ุงูุจุญุซ ุนู ุตูุช ุนุฑุจู ุฃู ุตูุช ููุงุณุจ
      this.selectedVoice = this.voices.find(voice => 
        voice.lang.includes('ar') || 
        voice.lang.includes('en') ||
        voice.name.includes('Google') ||
        voice.name.includes('Arabic')
      ) || this.voices[0];
    }, 500);
  }
  
  setupEventListeners() {
    const listenBtn = document.getElementById('listenBtn');
    const stopSpeakingBtn = document.getElementById('stopSpeakingBtn');
    const voiceMood = document.getElementById('voiceMood');
    const quickResponses = document.querySelectorAll('.quick-response');
    
    if (listenBtn) {
      listenBtn.addEventListener('click', () => this.startConversation());
    }
    
    if (stopSpeakingBtn) {
      stopSpeakingBtn.addEventListener('click', () => this.stopSpeaking());
    }
    
    if (voiceMood) {
      voiceMood.addEventListener('click', () => this.changeMood());
    }
    
    // ุฅุถุงูุฉ ูุณุชูุนูู ููุฑุฏูุฏ ุงูุณุฑูุนุฉ
    quickResponses.forEach(response => {
      response.addEventListener('click', (e) => {
        const question = e.target.getAttribute('data-question');
        this.handleQuestion(question);
      });
    });
    
    // ูุญุงูุงุฉ ุงูุงุณุชูุงุน ูู ุงููุณุชุฎุฏู (ูู ุงููุงูุนุ ุณูุชุญุฏุซ ุงููุณุชุฎุฏู)
    this.setupVoiceInput();
  }
  
  setupVoiceInput() {
    // ูู ุงูุชุทุจูู ุงูุญููููุ ููุง ุณูุณุชุฎุฏู Web Speech Recognition
    // ููู ูุฃุบุฑุงุถ ุงูุนุฑุถุ ุณูุณุชุฎุฏู ูุญุงูุงุฉ
    
    // ุฅุถุงูุฉ ุฒุฑ ููุณูุงุญ ูููุณุชุฎุฏู "ุจุชุณุฌูู" ุฑุณุงูุฉ
    document.addEventListener('keypress', (e) => {
      if (e.key === 'Enter' && document.activeElement.id !== 'conversationContainer') {
        this.simulateUserMessage();
      }
    });
  }
  
  simulateUserMessage() {
    const messages = [
      "ูุฑุญุจุง ุฌุฑููู",
      "ููู ุญุงูู ุงููููุ",
      "ุฃุนุทูู ูุตูุญุฉ ููุนุจ",
      "ููู ุฃุชุญูู ูู ุฃุนุตุงุจูุ",
      "ุฃุฎุจุฑูู ููุชุฉ",
      "ุดูุฑุงู ูู",
      "ูุฏุงุนุงู"
    ];
    
    const randomMessage = messages[Math.floor(Math.random() * messages.length)];
    this.addMessage('user', randomMessage);
    this.processMessage(randomMessage);
  }
  
  startConversation() {
    const listenBtn = document.getElementById('listenBtn');
    const listenIcon = document.getElementById('listenIcon');
    const listenText = document.getElementById('listenText');
    
    this.isListening = !this.isListening;
    
    if (this.isListening) {
      listenIcon.textContent = '๐ค';
      listenText.textContent = 'ุฃุชุญุฏุซ ุงูุขู...';
      listenBtn.style.background = 'linear-gradient(135deg, #ff006e, #cc0058)';
      
      // ูุญุงูุงุฉ ุฃู ุงููุณุชุฎุฏู ูุชุญุฏุซ
      this.addMessage('user', '...');
      this.showVoiceWave(true);
      
      // ุจุนุฏ 2 ุซุงููุฉุ "ูุณูุน" ุงููุณุงุนุฏ ุฑุณุงูุฉ
      setTimeout(() => {
        this.showVoiceWave(false);
        this.speak("ุฃุณูุนู ุฌูุฏุงู! ุชูุถูุ ูุงุฐุง ุชุฑูุฏ ุฃู ุชุชุญุฏุซ ุนููุ");
      }, 2000);
    } else {
      listenIcon.textContent = '๐';
      listenText.textContent = 'ุงุณุชูุน ุฅููู';
      listenBtn.style.background = 'rgba(255, 107, 107, 0.2)';
      this.showVoiceWave(false);
    }
  }
  
  handleQuestion(question) {
    this.addMessage('user', question);
    this.processMessage(question);
  }
  
  processMessage(message) {
    const lowerMessage = message.toLowerCase();
    
    this.showTypingIndicator(true);
    
    setTimeout(() => {
      this.showTypingIndicator(false);
      
      let response = '';
      let mood = this.currentMood;
      
      if (lowerMessage.includes('ูุฑุญุจุง') || lowerMessage.includes('ุงููุง') || lowerMessage.includes('ุณูุงู')) {
        response = this.getRandomResponse('greetings');
        mood = 'happy';
      }
      else if (lowerMessage.includes('ููู ุญุงูู') || lowerMessage.includes('ุงุฎุจุงุฑู')) {
        response = this.getRandomResponse('howAreYou');
        mood = 'happy';
      }
      else if (lowerMessage.includes('ูุตูุญุฉ') || lowerMessage.includes('ูุตุงุฆุญ') || lowerMessage.includes('ูุตูุญู')) {
        response = this.getRandomResponse('gamingTips');
        mood = 'serious';
      }
      else if (lowerMessage.includes('ุนุตุจ') || lowerMessage.includes('ุฃุนุตุงุจ') || lowerMessage.includes('ุชูุชุฑ')) {
        response = "ุงูุชุญูู ูู ุงูุฃุนุตุงุจ ููุงุฑุฉ ุชูุชุณุจูุง ุจุงูููุงุฑุณุฉ! ุฅููู ุจุนุถ ุงููุตุงุฆุญ:\n" +
                  "1๏ธโฃ ุฎุฐ ููุณุงู ุนูููุงู ูุจู ูู ูุฑุงุฑ\n" +
                  "2๏ธโฃ ุญุฏุฏ ููุฒุงููุฉ ููุง ุชุชุฌุงูุฒูุง\n" +
                  "3๏ธโฃ ุชููู ููุฑุงู ุฅุฐุง ุดุนุฑุช ุจุงูุชูุชุฑ\n" +
                  "4๏ธโฃ ุฑูุฒ ุนูู ุงููุชุนุฉ ูููุณ ููุท ุงูุฑุจุญ\n" +
                  "5๏ธโฃ ุชุฐูุฑ ุฃููุง ูุนุจุฉ ูููุณุช ูุตูุฑุงู";
        mood = 'calm';
      }
      else if (lowerMessage.includes('ููุช') || lowerMessage.includes('ุถุญู') || lowerMessage.includes('ูุฑุญ')) {
        response = this.getRandomResponse('jokes');
        mood = 'funny';
      }
      else if (lowerMessage.includes('ุดูุฑ') || lowerMessage.includes('ููุชุงุฒ') || lowerMessage.includes('ุฑุงุฆุน')) {
        response = this.getRandomResponse('thanks');
        mood = 'happy';
      }
      else if (lowerMessage.includes('ูุฏุงุน') || lowerMessage.includes('ูุน ุงูุณูุงู') || lowerMessage.includes('ุจุงู')) {
        response = this.getRandomResponse('farewell');
        mood = 'calm';
      }
      else {
        // ุฑุฏ ุนุงู
        const topic = this.topics === 'all' ? this.getRandomTopic() : this.topics;
        if (topic === 'gaming') response = this.getRandomResponse('gamingTips');
        else if (topic === 'psychology') response = this.getRandomResponse('psychology');
        else if (topic === 'motivation') response = this.getRandomResponse('motivation');
        else response = "ุฃุณูุนู! ูู ุชุฑูุฏ ุงูุญุฏูุซ ุนู ูุตุงุฆุญ ุงููุนุจุ ุนูู ุงูููุณุ ุฃู ุงูุชุญููุฒุ";
      }
      
      this.addMessage('assistant', response, mood);
      this.speak(response);
    }, 1000 + Math.random() * 1500);
  }
  
  getRandomResponse(category) {
    const responses = this.voiceResponses[category];
    return responses[Math.floor(Math.random() * responses.length)];
  }
  
  getRandomTopic() {
    const topics = ['gaming', 'psychology', 'motivation'];
    return topics[Math.floor(Math.random() * topics.length)];
  }
  
  speak(text) {
    if (!this.speechSynthesis || this.isSpeaking) return;
    
    // ุฅููุงู ุฃู ููุงู ุณุงุจู
    this.speechSynthesis.cancel();
    
    this.isSpeaking = true;
    this.showSpeakingIndicator(true);
    
    const utterance = new SpeechSynthesisUtterance(text);
    
    // ุถุจุท ุฅุนุฏุงุฏุงุช ุงูุตูุช
    if (this.selectedVoice) {
      utterance.voice = this.selectedVoice;
    }
    
    utterance.lang = 'ar-SA'; // ุงููุบุฉ ุงูุนุฑุจูุฉ
    utterance.rate = 0.9; // ุณุฑุนุฉ ุฃุจุทุฃ ูููุถูุญ
    utterance.pitch = 1.0;
    utterance.volume = 1.0;
    
    utterance.onstart = () => {
      console.log('Started speaking:', text);
    };
    
    utterance.onend = () => {
      console.log('Finished speaking');
      this.isSpeaking = false;
      this.showSpeakingIndicator(false);
    };
    
    utterance.onerror = (event) => {
      console.error('Speech synthesis error:', event);
      this.isSpeaking = false;
      this.showSpeakingIndicator(false);
    };
    
    try {
      this.speechSynthesis.speak(utterance);
    } catch (error) {
      console.error('Error speaking:', error);
      this.isSpeaking = false;
      this.showSpeakingIndicator(false);
    }
  }
  
  stopSpeaking() {
    if (this.speechSynthesis) {
      this.speechSynthesis.cancel();
      this.isSpeaking = false;
      this.showSpeakingIndicator(false);
    }
  }
  
  addMessage(sender, text, mood = null) {
    const container = document.getElementById('conversationContainer');
    if (!container) return;
    
    const messageDiv = document.createElement('div');
    messageDiv.className = `conversation-bubble ${sender}-bubble`;
    
    if (sender === 'assistant' && mood) {
      const moodIcon = this.moodIcons[mood] || '๐';
      messageDiv.innerHTML = `<span class="emotion-indicator">${moodIcon}</span> ${text}`;
    } else {
      messageDiv.textContent = text;
    }
    
    container.appendChild(messageDiv);
    
    // ุญูุธ ูู ุงูุฐุงูุฑุฉ
    this.conversation.push({
      sender,
      text,
      mood,
      timestamp: new Date().toISOString()
    });
    
    // ุงูุชูุฑูุฑ ููุฃุณูู
    container.scrollTop = container.scrollHeight;
    
    // ุญูุธ ุงููุญุงุฏุซุฉ
    this.saveConversation();
  }
  
  showTypingIndicator(show) {
    const indicator = document.getElementById('typingIndicator');
    if (indicator) {
      indicator.style.display = show ? 'flex' : 'none';
    }
  }
  
  showSpeakingIndicator(show) {
    const indicator = document.getElementById('speakingIndicator');
    if (indicator) {
      indicator.style.display = show ? 'inline-flex' : 'none';
    }
  }
  
  showVoiceWave(show) {
    const wave = document.getElementById('voiceWave');
    if (wave) {
      wave.style.display = show ? 'flex' : 'none';
    }
  }
  
  changeMood() {
    const moods = ['happy', 'excited', 'calm', 'serious', 'funny'];
    const currentIndex = moods.indexOf(this.currentMood);
    const nextIndex = (currentIndex + 1) % moods.length;
    this.currentMood = moods[nextIndex];
    
    const moodIcon = document.getElementById('moodIcon');
    if (moodIcon) {
      moodIcon.textContent = this.moodIcons[this.currentMood] || '๐';
    }
    
    this.speak(`ุชุบูุฑุช ุญุงูุชู ุงููุฒุงุฌูุฉ ุฅูู ${this.getMoodName(this.currentMood)}!`);
  }
  
  getMoodName(mood) {
    const names = {
      happy: 'ุณุนูุฏ',
      excited: 'ูุชุญูุณ',
      calm: 'ูุงุฏุฆ',
      serious: 'ุฌุฏู',
      funny: 'ููุชุน'
    };
    return names[mood] || mood;
  }
  
  saveConversation() {
    try {
      const toSave = this.conversation.slice(-50);
      localStorage.setItem('talkingAssistant_conversation', JSON.stringify(toSave));
    } catch (error) {
      console.error('Error saving conversation:', error);
    }
  }
  
  loadConversation() {
    try {
      const saved = localStorage.getItem('talkingAssistant_conversation');
      if (saved) {
        this.conversation = JSON.parse(saved);
      }
    } catch (error) {
      console.error('Error loading conversation:', error);
    }
  }
  
  // ูุตุงุฆุญ ุชููุงุฆูุฉ ุจูุงุกู ุนูู ุฃุฏุงุก ุงููุนุจุฉ
  provideGameAdvice(gameStats) {
    if (!gameStats || gameStats.totalRounds < 5) return;
    
    const winRate = gameStats.winRate || 0;
    
    if (winRate < 30) {
      const advice = "ุฃุฑู ุฃู ุญุธู ููุณ ูู ุฃูุถู ุญุงูุงุชู ุงูููู. ุฑุจูุง ุชุญุชุงุฌ ูุฃุฎุฐ ูุณุท ูู ุงูุฑุงุญุฉ ูุงูุนูุฏุฉ ูุงุญูุงู ุจุฃููุงุฑ ุฌุฏูุฏุฉ!";
      this.addMessage('assistant', advice, 'calm');
      this.speak(advice);
    } else if (winRate > 70) {
      const congrats = "ููุชุงุฒ! ุฃุฏุงุคู ุฑุงุฆุน ุงูููู. ุงุณุชูุฑ ูู ูุฐุง ุงููุณุชูู ูููู ุชุฐูุฑ ุฃู ุชุญุงูุธ ุนูู ุชูุงุฒูู!";
      this.addMessage('assistant', congrats, 'excited');
      this.speak(congrats);
    }
  }
}

// ========== ุฎูุงุฑุฒููุงุช ุชุนูู ุงูุขูุฉ ==========
// (ููุณ ุงูููุฏ ุงูุณุงุจู ููู KNN, Logistic Regression, Ensemble, ู BaccaratML)
// ... (ุฃุจูู ูู ููุฏ ML ุงูุณุงุจู ููุง ูู) ...

class SimpleKNN {
  constructor(k = 3) {
    this.k = k;
    this.trainingData = [];
    this.predictions = { correct: 0, total: 0 };
  }

  train(features, labels) {
    if (!features || !labels || features.length === 0) return;
    
    features.forEach((f, i) => {
      if (f && labels[i]) {
        this.trainingData.push({
          features: f,
          label: labels[i]
        });
      }
    });
    
    if (this.trainingData.length > 100) {
      this.trainingData = this.trainingData.slice(-100);
    }
  }

  predict(newFeatures) {
    if (!newFeatures || this.trainingData.length === 0) {
      return { P: 33.3, B: 33.3, T: 33.3 };
    }

    try {
      const distances = this.trainingData.map((dataPoint, index) => ({
        index,
        distance: this.euclideanDistance(newFeatures, dataPoint.features),
        label: dataPoint.label
      }));

      distances.sort((a, b) => a.distance - b.distance);
      const nearestNeighbors = distances.slice(0, this.k);
      
      const votes = { P: 0, B: 0, T: 0 };
      nearestNeighbors.forEach(n => {
        if (n.label in votes) {
          votes[n.label] += 1 / (n.distance + 1);
        }
      });

      const total = votes.P + votes.B + votes.T;
      if (total === 0) return { P: 33.3, B: 33.3, T: 33.3 };
      
      return {
        P: (votes.P / total) * 100,
        B: (votes.B / total) * 100,
        T: (votes.T / total) * 100
      };
    } catch (e) {
      console.error('KNN prediction error:', e);
      return { P: 33.3, B: 33.3, T: 33.3 };
    }
  }

  euclideanDistance(a, b) {
    if (!a || !b || a.length !== b.length) return 1000;
    
    let sum = 0;
    for (let i = 0; i < a.length; i++) {
      sum += Math.pow((a[i] || 0) - (b[i] || 0), 2);
    }
    return Math.sqrt(sum);
  }

  updateAccuracy(prediction, actual) {
    this.predictions.total++;
    if (prediction === actual) this.predictions.correct++;
  }

  getAccuracy() {
    return this.predictions.total > 0 ? 
      (this.predictions.correct / this.predictions.total) * 100 : 0;
  }
}

class SimpleLogisticRegression {
  constructor() {
    this.weights = { P: 0.1, B: 0.1, T: 0.1 };
    this.bias = 0;
    this.learningRate = 0.05;
    this.predictions = { correct: 0, total: 0 };
  }

  sigmoid(x) {
    return 1 / (1 + Math.exp(-x));
  }

  trainOne(features, label) {
    if (!features || !label || features.length === 0) return;
    
    try {
      const labelNum = { P: 0, B: 1, T: 2 }[label];
      if (labelNum === undefined) return;
      
      const score = features[0] * this.weights.P + features[1] * this.weights.B + features[2] * this.weights.T + this.bias;
      const prediction = this.sigmoid(score);
      const error = (labelNum / 2) - prediction;
      
      this.weights.P += this.learningRate * error * features[0];
      this.weights.B += this.learningRate * error * features[1];
      this.weights.T += this.learningRate * error * features[2];
      this.bias += this.learningRate * error;
    } catch (e) {
      console.error('Logistic regression training error:', e);
    }
  }

  predict(features) {
    if (!features || features.length === 0) {
      return { P: 33.3, B: 33.3, T: 33.3 };
    }
    
    try {
      const pScore = this.sigmoid(features[0] * this.weights.P + this.bias);
      const bScore = this.sigmoid(features[1] * this.weights.B + this.bias);
      const tScore = this.sigmoid(features[2] * this.weights.T + this.bias);
      
      const total = pScore + bScore + tScore;
      if (total === 0) return { P: 33.3, B: 33.3, T: 33.3 };
      
      return {
        P: (pScore / total) * 100,
        B: (bScore / total) * 100,
        T: (tScore / total) * 100
      };
    } catch (e) {
      console.error('Logistic regression prediction error:', e);
      return { P: 33.3, B: 33.3, T: 33.3 };
    }
  }

  updateAccuracy(prediction, actual) {
    this.predictions.total++;
    if (prediction === actual) this.predictions.correct++;
  }

  getAccuracy() {
    return this.predictions.total > 0 ? 
      (this.predictions.correct / this.predictions.total) * 100 : 0;
  }
}

class EnsembleModel {
  constructor() {
    this.models = {
      knn: new SimpleKNN(5),
      logistic: new SimpleLogisticRegression()
    };
    this.weights = { knn: 0.5, logistic: 0.5 };
    this.predictions = { correct: 0, total: 0 };
  }

  train(features, label) {
    if (!features || !label) return;
    
    try {
      this.models.knn.train([features], [label]);
      this.models.logistic.trainOne(features, label);
      
      const knnAcc = this.models.knn.getAccuracy();
      const logisticAcc = this.models.logistic.getAccuracy();
      
      const totalAcc = knnAcc + logisticAcc;
      if (totalAcc > 0) {
        this.weights.knn = knnAcc / totalAcc;
        this.weights.logistic = logisticAcc / totalAcc;
      }
    } catch (e) {
      console.error('Ensemble training error:', e);
    }
  }

  predict(features) {
    if (!features) return { P: 33.3, B: 33.3, T: 33.3 };
    
    try {
      const knnPred = this.models.knn.predict(features);
      const logisticPred = this.models.logistic.predict(features);
      
      return {
        P: (knnPred.P * this.weights.knn + logisticPred.P * this.weights.logistic),
        B: (knnPred.B * this.weights.knn + logisticPred.B * this.weights.logistic),
        T: (knnPred.T * this.weights.knn + logisticPred.T * this.weights.logistic)
      };
    } catch (e) {
      console.error('Ensemble prediction error:', e);
      return { P: 33.3, B: 33.3, T: 33.3 };
    }
  }

  updateAccuracy(prediction, actual) {
    this.predictions.total++;
    if (prediction === actual) this.predictions.correct++;
    
    this.models.knn.updateAccuracy(prediction, actual);
    this.models.logistic.updateAccuracy(prediction, actual);
  }

  getAccuracy() {
    return this.predictions.total > 0 ? 
      (this.predictions.correct / this.predictions.total) * 100 : 0;
  }
}

class BaccaratMachineLearning {
  constructor() {
    this.models = {
      knn: new SimpleKNN(5),
      logistic: new SimpleLogisticRegression(),
      ensemble: new EnsembleModel()
    };
    this.activeModel = 'ensemble';
    this.featureHistory = [];
    this.mlPredictions = [];
    this.isEnabled = true;
    this.trainingData = [];
  }

  extractFeatures(rounds, windowSize) {
    if (!rounds || rounds.length < windowSize) return null;
    
    try {
      const recent = rounds.slice(-windowSize);
      const pRatio = recent.filter(r => r === 'P').length / windowSize;
      const bRatio = recent.filter(r => r === 'B').length / windowSize;
      const tRatio = recent.filter(r => r === 'T').length / windowSize;
      
      let pStreak = 0, bStreak = 0;
      for (let i = recent.length - 1; i >= 0; i--) {
        if (recent[i] === 'P') pStreak++; else break;
      }
      for (let i = recent.length - 1; i >= 0; i--) {
        if (recent[i] === 'B') bStreak++; else break;
      }
      
      const volatility = this.calculateVolatility(recent);
      const patternType = this.getPatternType(recent);
      
      return [
        pRatio, bRatio, tRatio,
        pStreak / windowSize,
        bStreak / windowSize,
        recent[recent.length - 1] === recent[recent.length - 2] ? 1 : 0,
        volatility,
        patternType
      ];
    } catch (e) {
      console.error('Feature extraction error:', e);
      return null;
    }
  }

  calculateVolatility(rounds) {
    if (rounds.length < 2) return 0;
    let changes = 0;
    for (let i = 1; i < rounds.length; i++) {
      if (rounds[i] !== rounds[i-1]) changes++;
    }
    return changes / (rounds.length - 1);
  }

  getPatternType(rounds) {
    if (rounds.length < 3) return 0;
    const lastThree = rounds.slice(-3);
    if (lastThree[0] === lastThree[1] && lastThree[1] === lastThree[2]) return 1;
    if (lastThree[0] !== lastThree[1] && lastThree[1] !== lastThree[2]) return 2;
    return 0;
  }

  updateModel(rounds, windowSize, actualResult) {
    if (!this.isEnabled || !rounds || !actualResult) return;
    
    const features = this.extractFeatures(rounds, windowSize);
    if (!features) return;
    
    try {
      this.featureHistory.push({ features, label: actualResult, timestamp: Date.now() });
      
      if (this.featureHistory.length > 100) {
        this.featureHistory = this.featureHistory.slice(-100);
      }
      
      if (this.featureHistory.length > 5) {
        const trainingBatch = this.featureHistory.slice(-10);
        
        trainingBatch.forEach(({ features, label }) => {
          if (features && label) {
            this.models.knn.train([features], [label]);
            this.models.logistic.trainOne(features, label);
            this.models.ensemble.train(features, label);
          }
        });
      }
    } catch (e) {
      console.error('ML update error:', e);
    }
  }

  predict(rounds, windowSize) {
    if (!this.isEnabled || !rounds || rounds.length < windowSize) {
      return null;
    }
    
    const features = this.extractFeatures(rounds, windowSize);
    if (!features) return null;
    
    try {
      let prediction;
      switch(this.activeModel) {
        case 'knn':
          prediction = this.models.knn.predict(features);
          break;
        case 'logistic':
          prediction = this.models.logistic.predict(features);
          break;
        case 'ensemble':
        default:
          prediction = this.models.ensemble.predict(features);
          break;
      }
      
      if (prediction) {
        this.mlPredictions.push({
          features,
          prediction: this.getPredictedClass(prediction),
          timestamp: Date.now()
        });
        
        if (this.mlPredictions.length > 50) {
          this.mlPredictions = this.mlPredictions.slice(-50);
        }
      }
      
      return prediction;
    } catch (e) {
      console.error('ML prediction error:', e);
      return null;
    }
  }

  getPredictedClass(prediction) {
    if (!prediction) return null;
    const entries = Object.entries(prediction);
    if (entries.length === 0) return null;
    
    entries.sort((a, b) => b[1] - a[1]);
    return entries[0][0];
  }

  getModelAccuracy(modelName) {
    const model = this.models[modelName];
    return model && model.getAccuracy ? model.getAccuracy() : 0;
  }

  getTrainingDataCount() {
    return this.featureHistory.length;
  }

  getMLWeight() {
    const minWeight = 0.1;
    const maxWeight = 0.6;
    const dataPoints = this.getTrainingDataCount();
    const weight = minWeight + (maxWeight - minWeight) * (dataPoints / 100);
    return Math.min(weight, maxWeight);
  }

  enable() {
    this.isEnabled = true;
  }

  disable() {
    this.isEnabled = false;
  }

  setActiveModel(modelName) {
    if (this.models[modelName]) {
      this.activeModel = modelName;
    }
  }

  reset() {
    this.models = {
      knn: new SimpleKNN(5),
      logistic: new SimpleLogisticRegression(),
      ensemble: new EnsembleModel()
    };
    this.featureHistory = [];
    this.mlPredictions = [];
    this.trainingData = [];
  }

  getStats() {
    return {
      trainingCount: this.featureHistory.length,
      accuracy: this.getModelAccuracy(this.activeModel),
      weight: this.getMLWeight(),
      isEnabled: this.isEnabled,
      activeModel: this.activeModel
    };
  }
}

// ========== ูุธุงู ุญูุธ ุงูุจูุงูุงุช ==========
// (ููุณ ุงูููุฏ ุงูุณุงุจู ูู DataManager ูุน ุชุญุฏูุซ ุจุณูุท)
class DataManager {
  constructor() {
    this.storageKey = 'baccaratPro_v5';
    this.autoSaveInterval = null;
    this.lastSaveTime = null;
    this.isSaving = false;
  }

  saveAllData() {
    if (this.isSaving) return false;
    
    this.isSaving = true;
    try {
      const saveData = {
        state: {
          rounds: state.rounds,
          count: state.count,
          win: state.win,
          loss: state.loss,
          windowSize: state.windowSize,
          analysisMode: state.analysisMode,
          confidenceThreshold: state.confidenceThreshold,
          timeWeighting: state.timeWeighting,
          useML: state.useML,
          mlModel: state.mlModel,
          modelPerformance: state.modelPerformance,
          previousPredictions: state.previousPredictions,
          lastPrediction: state.lastPrediction
        },
        history: {
          accuracyHistory: state.accuracyHistory,
          predictionsHistory: state.predictionsHistory
        },
        mlData: {
          featureHistory: state.ml.featureHistory,
          mlPredictions: state.ml.mlPredictions,
          activeModel: state.ml.activeModel,
          isEnabled: state.ml.isEnabled
        },
        meta: {
          version: '5.0',
          lastSave: new Date().toISOString(),
          totalRounds: state.rounds.length,
          sessionStart: this.getSessionStartTime()
        }
      };

      localStorage.setItem(this.storageKey, JSON.stringify(saveData));
      this.lastSaveTime = new Date();
      this.updateSaveStatus(true);
      return true;
    } catch (e) {
      console.error('Error saving data:', e);
      this.updateSaveStatus(false, 'ุฎุทุฃ ูู ุงูุญูุธ');
      return false;
    } finally {
      this.isSaving = false;
    }
  }

  loadAllData() {
    try {
      const saved = localStorage.getItem(this.storageKey);
      if (!saved) {
        this.updateSaveStatus(true, 'ุจุฏูู ุจูุงูุงุช ุณุงุจูุฉ');
        return false;
      }

      const data = JSON.parse(saved);
      
      if (data.state) {
        state.rounds = Array.isArray(data.state.rounds) ? data.state.rounds : [];
        state.count = data.state.count || { P: 0, B: 0, T: 0 };
        state.win = data.state.win || { P: 0, B: 0, T: 0 };
        state.loss = data.state.loss || { P: 0, B: 0, T: 0 };
        state.windowSize = data.state.windowSize || 8;
        state.analysisMode = data.state.analysisMode || 'advanced';
        state.confidenceThreshold = data.state.confidenceThreshold || 45;
        state.timeWeighting = data.state.timeWeighting || 'linear';
        state.useML = data.state.useML !== false;
        state.mlModel = data.state.mlModel || 'ensemble';
        state.modelPerformance = data.state.modelPerformance || { basic: 0, advanced: 0, pattern: 0, ml: 0 };
        state.previousPredictions = data.state.previousPredictions || { P: 0, B: 0, T: 0 };
        state.lastPrediction = data.state.lastPrediction || null;
      }

      if (data.history) {
        state.accuracyHistory = Array.isArray(data.history.accuracyHistory) ? data.history.accuracyHistory : [];
        state.predictionsHistory = Array.isArray(data.history.predictionsHistory) ? data.history.predictionsHistory : [];
      }

      if (data.mlData) {
        state.ml.featureHistory = Array.isArray(data.mlData.featureHistory) ? data.mlData.featureHistory : [];
        state.ml.mlPredictions = Array.isArray(data.mlData.mlPredictions) ? data.mlData.mlPredictions : [];
        state.ml.activeModel = data.mlData.activeModel || 'ensemble';
        state.ml.isEnabled = data.mlData.isEnabled !== false;
        
        setTimeout(() => {
          if (state.ml.featureHistory.length > 0) {
            state.ml.featureHistory.forEach((item, index) => {
              if (index > 0 && item.features && item.label) {
                state.ml.models.knn.train([item.features], [item.label]);
                state.ml.models.logistic.trainOne(item.features, item.label);
                state.ml.models.ensemble.train(item.features, item.label);
              }
            });
          }
        }, 500);
      }

      this.lastSaveTime = new Date();
      this.updateSaveStatus(true, 'ุชู ุชุญููู ุงูุจูุงูุงุช');
      return true;
    } catch (e) {
      console.error('Error loading data:', e);
      this.updateSaveStatus(false, 'ุฎุทุฃ ูู ุงูุชุญููู');
      return false;
    }
  }

  exportData() {
    try {
      const exportData = {
        state: {
          rounds: state.rounds,
          count: state.count,
          win: state.win,
          loss: state.loss,
          windowSize: state.windowSize
        },
        ml: {
          featureHistory: state.ml.featureHistory,
          trainingCount: state.ml.getTrainingDataCount()
        },
        meta: {
          exportDate: new Date().toISOString(),
          version: 'AYOUB_BACCARAT_PRO_v5.0',
          totalRounds: state.rounds.length
        }
      };

      const dataStr = JSON.stringify(exportData, null, 2);
      const dataBlob = new Blob([dataStr], { type: 'application/json' });
      const url = URL.createObjectURL(dataBlob);
      
      const a = document.createElement('a');
      a.href = url;
      a.download = `baccarat_data_${new Date().toISOString().split('T')[0]}.json`;
      document.body.appendChild(a);
      a.click();
      
      setTimeout(() => {
        document.body.removeChild(a);
        URL.revokeObjectURL(url);
      }, 100);
      
      alert(`โ ุชู ุชุตุฏูุฑ ${state.rounds.length} ุฌููุฉ ู ${state.ml.featureHistory.length} ุนููุฉ ุชุฏุฑูุจ`);
    } catch (e) {
      alert('โ ุฎุทุฃ ูู ุชุตุฏูุฑ ุงูุจูุงูุงุช: ' + e.message);
    }
  }

  importData(file) {
    const reader = new FileReader();
    
    reader.onload = (e) => {
      try {
        const importedData = JSON.parse(e.target.result);
        
        if (!confirm(`ูู ุชุฑูุฏ ุงุณุชูุฑุงุฏ ${importedData.state?.rounds?.length || 0} ุฌููุฉุ\nุณูุชู ูุณุญ ุงูุจูุงูุงุช ุงูุญุงููุฉ.`)) {
          return;
        }

        resetAll();
        
        if (importedData.state) {
          state.rounds = Array.isArray(importedData.state.rounds) ? importedData.state.rounds : [];
          state.count = importedData.state.count || { P: 0, B: 0, T: 0 };
          state.win = importedData.state.win || { P: 0, B: 0, T: 0 };
          state.loss = importedData.state.loss || { P: 0, B: 0, T: 0 };
          state.windowSize = importedData.state.windowSize || 8;
          
          state.rounds.forEach(round => {
            state.count[round]++;
          });
        }

        if (importedData.ml && Array.isArray(importedData.ml.featureHistory)) {
          state.ml.featureHistory = importedData.ml.featureHistory;
          
          setTimeout(() => {
            if (state.ml.featureHistory.length > 0) {
              state.ml.featureHistory.forEach((item, index) => {
                if (index > 0 && item.features && item.label) {
                  state.ml.models.knn.train([item.features], [item.label]);
                  state.ml.models.logistic.trainOne(item.features, item.label);
                  state.ml.models.ensemble.train(item.features, item.label);
                }
              });
            }
          }, 500);
        }

        updateAll();
        updateMLStatus();
        this.saveAllData();
        
        alert(`โ ุชู ุงุณุชูุฑุงุฏ ${state.rounds.length} ุฌููุฉ ุจูุฌุงุญ!`);
      } catch (error) {
        alert('โ ุฎุทุฃ ูู ุชูุณูู ุงูููู: ' + error.message);
      }
    };
    
    reader.onerror = () => {
      alert('โ ุฎุทุฃ ูู ูุฑุงุกุฉ ุงูููู');
    };
    
    reader.readAsText(file);
  }

  clearAllData() {
    if (confirm('โ๏ธ ูู ุฃูุช ูุชุฃูุฏ ูู ูุณุญ ุฌููุน ุงูุจูุงูุงุชุ\nูุง ูููู ุงูุชุฑุงุฌุน ุนู ูุฐุง ุงูุฅุฌุฑุงุก.')) {
      localStorage.removeItem(this.storageKey);
      resetAll();
      alert('โ ุชู ูุณุญ ุฌููุน ุงูุจูุงูุงุช.');
    }
  }

  startAutoSave(intervalSeconds = 30) {
    if (this.autoSaveInterval) {
      clearInterval(this.autoSaveInterval);
    }
    
    this.autoSaveInterval = setInterval(() => {
      if (state.rounds.length > 0 && !this.isSaving) {
        this.saveAllData();
      }
    }, intervalSeconds * 1000);
    
    window.addEventListener('beforeunload', () => {
      if (!this.isSaving) {
        this.saveAllData();
      }
    });
  }

  updateSaveStatus(success, message = '') {
    const statusEl = document.getElementById('autoSaveStatus');
    if (statusEl) {
      if (success) {
        const timeStr = this.lastSaveTime ? 
          `๐พ ุขุฎุฑ ุญูุธ: ${this.lastSaveTime.toLocaleTimeString('ar-EG', {hour: '2-digit', minute:'2-digit'})}` : 
          '๐พ ุงูุญูุธ ุงูุชููุงุฆู ููุนู';
        statusEl.textContent = message || timeStr;
        statusEl.style.color = '#38b000';
      } else {
        statusEl.textContent = message || 'โ ุฎุทุฃ ูู ุงูุญูุธ';
        statusEl.style.color = '#ff006e';
      }
    }
  }

  getSessionStartTime() {
    const saved = localStorage.getItem('session_start');
    if (!saved) {
      const startTime = new Date().toISOString();
      localStorage.setItem('session_start', startTime);
      return startTime;
    }
    return saved;
  }

  updateDataStats() {
    const statsEl = document.getElementById('dataStats');
    if (statsEl) {
      statsEl.textContent = `${state.rounds.length} ุฌููุฉ โข ${state.ml.featureHistory.length} ุนููุฉ ุชุฏุฑูุจ`;
    }
  }
}

// ========== ุงูุญุงูุฉ ุงูุนุงูุฉ ููุชุทุจูู ==========
const state = {
  rounds: [],
  windowSize: 8,
  count: { P: 0, B: 0, T: 0 },
  win: { P: 0, B: 0, T: 0 },
  loss: { P: 0, B: 0, T: 0 },
  lastPrediction: null,
  accuracyHistory: [],
  predictionsHistory: [],
  analysisMode: 'advanced',
  confidenceThreshold: 45,
  timeWeighting: 'linear',
  modelPerformance: { basic: 0, advanced: 0, pattern: 0, ml: 0 },
  previousPredictions: { P: 0, B: 0, T: 0 },
  ml: new BaccaratMachineLearning(),
  useML: true,
  mlModel: 'ensemble',
  talkingAssistant: null
};

// ุฅูุดุงุก ูุฏูุฑ ุงูุจูุงูุงุช
const dataManager = new DataManager();

// ========== ุงููุธุงุฆู ุงููุณุงุนุฏุฉ ==========
const el = id => document.getElementById(id);

// ========== ุงููุธุงุฆู ุงูุฑุฆูุณูุฉ ==========

function init() {
  console.log('Initializing Baccarat Pro with Talking Assistant...');
  
  // ุฅูุดุงุก ุงููุณุงุนุฏ ุงูุตูุชู ุงูุฐู ูุชุญุฏุซ
  state.talkingAssistant = new TalkingAssistant();
  
  // ุชุญููู ุงูุจูุงูุงุช ุงููุญููุธุฉ
  dataManager.loadAllData();
  
  // ุฅุนุฏุงุฏ ุนูุงุตุฑ ุงููุงุฌูุฉ
  el('windowSize').value = state.windowSize;
  
  el('applyWindow').onclick = () => {
    const v = parseInt(el('windowSize').value);
    if (v >= 5 && v <= 15) {
      state.windowSize = v;
      updateAll();
      showToast(`ุชู ุชุบููุฑ ูุงูุฐุฉ ุงูุชุญููู ุฅูู ${v} ุฌููุงุช`);
    } else {
      showToast('ุงููุงูุฐุฉ ูุฌุจ ุฃู ุชููู ุจูู 5 ู 15', 'error');
    }
  };

  el('analysisMode').value = state.analysisMode;
  el('analysisMode').onchange = (e) => {
    state.analysisMode = e.target.value;
    updateAll();
    showToast(`ุชู ุชุบููุฑ ููุท ุงูุชุญููู ุฅูู ${getModeName(state.analysisMode)}`);
  };

  el('confidenceSensitivity').value = state.confidenceThreshold;
  el('confidenceSensitivity').oninput = (e) => {
    state.confidenceThreshold = parseInt(e.target.value);
    el('sensitivityValue').textContent = state.confidenceThreshold + '%';
    updateAll();
  };

  el('timeWeighting').value = state.timeWeighting;
  el('timeWeighting').onchange = (e) => {
    state.timeWeighting = e.target.value;
    updateAll();
    showToast(`ุชู ุชุบููุฑ ุงููุฑุฌุญุฉ ุงูุฒูููุฉ ุฅูู ${getWeightingName(state.timeWeighting)}`);
  };

  // ุฅุนุฏุงุฏุงุช ุชุนูู ุงูุขูุฉ
  el('mlToggle').checked = state.useML;
  el('mlToggle').onchange = (e) => {
    state.useML = e.target.checked;
    state.ml.isEnabled = state.useML;
    updateMLStatus();
    updateAll();
    showToast(`ุชุนูู ุงูุขูุฉ ${state.useML ? 'ููุนู' : 'ูุนุทู'}`);
  };

  el('mlModelSelect').value = state.mlModel;
  el('mlModelSelect').onchange = (e) => {
    state.mlModel = e.target.value;
    state.ml.setActiveModel(state.mlModel);
    updateMLStatus();
    updateAll();
    showToast(`ุชู ุชุบููุฑ ูููุฐุฌ ML ุฅูู ${getMLModelName(state.mlModel)}`);
  };

  // ุฃุฒุฑุงุฑ ุงูุฅุฏุฎุงู
  el('btnP').onclick = () => pushRound('P');
  el('btnB').onclick = () => pushRound('B');
  el('btnT').onclick = () => pushRound('T');
  el('btnUndo').onclick = undoRound;
  el('btnReset').onclick = resetAll;
  
  // ุฃุฒุฑุงุฑ ุงูุจูุงูุงุช
  el('btnExport').onclick = () => dataManager.exportData();
  el('btnImport').onclick = () => {
    const input = document.createElement('input');
    input.type = 'file';
    input.accept = '.json';
    input.onchange = (e) => {
      if (e.target.files && e.target.files[0]) {
        dataManager.importData(e.target.files[0]);
      }
    };
    input.click();
  };
  el('btnClearData').onclick = () => dataManager.clearAllData();
  
  // ุชุจุฏูู ุงููุถุน
  el('themeToggle').onclick = toggleTheme;
  
  // ุชุนููู ุงููุถุน ุงูุงูุชุฑุงุถู
  if (!document.documentElement.hasAttribute('data-theme')) {
    document.documentElement.setAttribute('data-theme', 'dark');
  }
  
  // ุจุฏุก ุงูุญูุธ ุงูุชููุงุฆู
  dataManager.startAutoSave(30);
  
  // ุชุญุฏูุซ ุงููุงุฌูุฉ
  updateAll();
  updateMLStatus();
  dataManager.updateDataStats();
  
  console.log('Initialization complete');
}

function toggleTheme() {
  const currentTheme = document.documentElement.getAttribute('data-theme');
  const newTheme = currentTheme === 'dark' ? 'light' : 'dark';
  document.documentElement.setAttribute('data-theme', newTheme);
  el('themeToggle').textContent = newTheme === 'dark' ? '๐' : '๐';
  updateAccuracyChart();
  showToast(`ุชู ุงูุชุจุฏูู ุฅูู ุงููุถุน ${newTheme === 'dark' ? 'ุงููููู' : 'ุงูููุงุฑู'}`);
}

function getModeName(mode) {
  const names = {
    basic: 'ุฃุณุงุณู',
    advanced: 'ูุชูุฏู',
    pattern: 'ุชุญููู ุงูุฃููุงุท',
    ml: 'ุชุนูู ุงูุขูุฉ'
  };
  return names[mode] || mode;
}

function getWeightingName(weighting) {
  const names = {
    none: 'ุจุฏูู',
    linear: 'ุฎุทู',
    exponential: 'ุฃุณูู'
  };
  return names[weighting] || weighting;
}

function getMLModelName(model) {
  const names = {
    knn: 'K-ุงูุฌูุฑุงู ุงูุฃูุฑุจ',
    logistic: 'ุงูุงูุญุฏุงุฑ ุงูููุฌุณุชู',
    ensemble: 'ุงููุฌูุน'
  };
  return names[model] || model;
}

function showToast(message, type = 'success') {
  const toast = document.createElement('div');
  toast.textContent = message;
  toast.style.cssText = `
    position: fixed;
    top: 20px;
    right: 20px;
    background: ${type === 'error' ? '#ef4444' : '#10b981'};
    color: white;
    padding: 12px 20px;
    border-radius: 8px;
    z-index: 1000;
    box-shadow: 0 4px 12px rgba(0,0,0,0.3);
    animation: slideIn 0.3s ease-out;
  `;
  
  document.body.appendChild(toast);
  
  setTimeout(() => {
    toast.style.animation = 'slideOut 0.3s ease-in';
    setTimeout(() => {
      if (toast.parentNode) {
        document.body.removeChild(toast);
      }
    }, 300);
  }, 3000);
}

// ุฅุถุงูุฉ ุฃููููุดู ููุชูุณุช
const style = document.createElement('style');
style.textContent = `
@keyframes slideIn {
  from { transform: translateX(100%); opacity: 0; }
  to { transform: translateX(0); opacity: 1; }
}
@keyframes slideOut {
  from { transform: translateX(0); opacity: 1; }
  to { transform: translateX(100%); opacity: 0; }
}
`;
document.head.appendChild(style);

// ========== ุฎูุงุฑุฒููุงุช ุงูุชุญููู ==========
// (ููุณ ุงูููุฏ ุงูุณุงุจู ููุชุญููู)
function frequencyAnalysis(rounds) {
  if (!rounds || rounds.length === 0) {
    return { P: 33.3, B: 33.3, T: 33.3 };
  }
  
  const counts = { P: 0, B: 0, T: 0 };
  rounds.forEach(x => {
    if (x in counts) counts[x]++;
  });
  
  const total = rounds.length;
  return {
    P: (counts.P / total) * 100,
    B: (counts.B / total) * 100,
    T: (counts.T / total) * 100
  };
}

function patternAnalysis(rounds) {
  if (!rounds || rounds.length < 3) {
    return { P: 0, B: 0, T: 0 };
  }

  const patterns = {};
  for (let i = 2; i < rounds.length; i++) {
    const pattern = rounds.slice(i-2, i).join('');
    const next = rounds[i];
    
    if (!patterns[pattern]) {
      patterns[pattern] = { P: 0, B: 0, T: 0, total: 0 };
    }
    
    if (next in patterns[pattern]) {
      patterns[pattern][next]++;
      patterns[pattern].total++;
    }
  }

  if (rounds.length >= 2) {
    const lastPattern = rounds.slice(-2).join('');
    const patternData = patterns[lastPattern];
    
    if (patternData && patternData.total >= 1) {
      return {
        P: (patternData.P / patternData.total) * 100,
        B: (patternData.B / patternData.total) * 100,
        T: (patternData.T / patternData.total) * 100
      };
    }
  }

  return { P: 0, B: 0, T: 0 };
}

function applyTimeWeighting(rounds, basePrediction) {
  if (state.timeWeighting === 'none' || !rounds || rounds.length < 2) {
    return basePrediction;
  }

  const n = rounds.length;
  let weightFactor = 1;
  
  if (state.timeWeighting === 'linear') {
    weightFactor = 0.8 + (0.4 * (1 / n));
  } else if (state.timeWeighting === 'exponential') {
    weightFactor = 0.7 + (0.6 * Math.pow(0.9, n));
  }

  return {
    P: basePrediction.P * weightFactor,
    B: basePrediction.B * weightFactor,
    T: basePrediction.T * weightFactor
  };
}

function enhancedPredict() {
  const n = Math.min(state.windowSize, state.rounds.length);
  const recent = state.rounds.slice(-n);
  
  if (recent.length === 0) {
    return { 
      P: 33.3, B: 33.3, T: 33.3, 
      final: 'โ',
      confidence: 0,
      model: 'basic',
      mlContribution: 0
    };
  }

  let basePrediction, patternBoost, finalPrediction;
  let modelUsed = state.analysisMode;
  let mlContribution = 0;

  switch(state.analysisMode) {
    case 'basic':
      basePrediction = frequencyAnalysis(recent);
      finalPrediction = basePrediction;
      break;
      
    case 'advanced':
      basePrediction = frequencyAnalysis(recent);
      patternBoost = patternAnalysis(recent);
      
      finalPrediction = {
        P: basePrediction.P * 0.7 + patternBoost.P * 0.3,
        B: basePrediction.B * 0.7 + patternBoost.B * 0.3,
        T: basePrediction.T * 0.7 + patternBoost.T * 0.3
      };
      break;
      
    case 'pattern':
      basePrediction = frequencyAnalysis(recent);
      patternBoost = patternAnalysis(recent);
      
      finalPrediction = {
        P: basePrediction.P * 0.4 + patternBoost.P * 0.6,
        B: basePrediction.B * 0.4 + patternBoost.B * 0.6,
        T: basePrediction.T * 0.4 + patternBoost.T * 0.6
      };
      break;
      
    case 'ml':
      basePrediction = frequencyAnalysis(recent);
      
      let mlPrediction = state.ml.predict(state.rounds, state.windowSize);
      if (!mlPrediction) {
        mlPrediction = { P: 33.3, B: 33.3, T: 33.3 };
      }
      
      const mlWeight = state.ml.getMLWeight();
      mlContribution = mlWeight * 100;
      
      finalPrediction = {
        P: basePrediction.P * (1 - mlWeight) + mlPrediction.P * mlWeight,
        B: basePrediction.B * (1 - mlWeight) + mlPrediction.B * mlWeight,
        T: basePrediction.T * (1 - mlWeight) + mlPrediction.T * mlWeight
      };
      break;
  }

  finalPrediction = applyTimeWeighting(recent, finalPrediction);

  const sum = finalPrediction.P + finalPrediction.B + finalPrediction.T;
  if (sum > 0) {
    finalPrediction.P = (finalPrediction.P / sum) * 100;
    finalPrediction.B = (finalPrediction.B / sum) * 100;
    finalPrediction.T = (finalPrediction.T / sum) * 100;
  }

  const entries = Object.entries(finalPrediction);
  const sorted = entries.sort((a, b) => b[1] - a[1]);
  
  const confidence = sorted[0][1] - (sorted[1] ? sorted[1][1] : 0);
  let final = sorted[0][0];
  
  if (sorted[0][1] < state.confidenceThreshold) {
    final = 'โ';
  }

  return {
    P: finalPrediction.P.toFixed(1),
    B: finalPrediction.B.toFixed(1),
    T: finalPrediction.T.toFixed(1),
    final,
    confidence: Math.min(100, Math.max(0, confidence * 2)),
    model: modelUsed,
    mlContribution: mlContribution.toFixed(1)
  };
}

function pushRound(r) {
  if (!['P', 'B', 'T'].includes(r)) return;
  
  const pred = enhancedPredict();
  state.lastPrediction = pred.final;
  
  state.ml.updateModel(state.rounds, state.windowSize, r);
  
  state.rounds.push(r);
  state.count[r]++;
  
  if (state.lastPrediction !== 'โ' && state.lastPrediction !== null) {
    const didWin = (r === state.lastPrediction);
    
    if (didWin) {
      state.win[state.lastPrediction]++;
      state.modelPerformance[state.analysisMode] = (state.modelPerformance[state.analysisMode] || 0) + 1;
    } else {
      state.loss[state.lastPrediction] = (state.loss[state.lastPrediction] || 0) + 1;
    }
  }
  
  updateAccuracyData(r);
  
  const newPred = enhancedPredict();
  updatePredictionDisplay(newPred);
  showResult(r, newPred, state.lastPrediction === r);
  updateAll();
  dataManager.saveAllData();
  dataManager.updateDataStats();
  
  // ูุตุงุฆุญ ุชููุงุฆูุฉ ูู ุงููุณุงุนุฏ ุงูุตูุชู
  if (state.talkingAssistant && state.rounds.length % 10 === 0) {
    const gameStats = {
      totalRounds: state.rounds.length,
      winRate: calculateWinRate(),
      recentLosses: calculateRecentLosses()
    };
    state.talkingAssistant.provideGameAdvice(gameStats);
  }
  
  playSound('click');
}

function undoRound() {
  if (state.rounds.length === 0) return;
  
  const lastRound = state.rounds.pop();
  state.count[lastRound] = Math.max(0, state.count[lastRound] - 1);
  
  if (state.rounds.length > 0) {
    const previousPrediction = enhancedPredict();
    if (lastRound === previousPrediction.final) {
      state.win[previousPrediction.final] = Math.max(0, state.win[previousPrediction.final] - 1);
      state.modelPerformance[state.analysisMode] = Math.max(0, state.modelPerformance[state.analysisMode] - 1);
    } else {
      state.loss[previousPrediction.final] = Math.max(0, state.loss[previousPrediction.final] - 1);
    }
  }
  
  if (state.accuracyHistory.length > 0) {
    state.accuracyHistory.pop();
    state.predictionsHistory.pop();
  }
  
  state.lastPrediction = null;
  
  state.ml.reset();
  for (let i = 0; i < state.rounds.length; i++) {
    if (i >= state.windowSize) {
      const recent = state.rounds.slice(i - state.windowSize, i);
      state.ml.updateModel(recent, state.windowSize, state.rounds[i]);
    }
  }
  
  updateAll();
  dataManager.saveAllData();
  dataManager.updateDataStats();
  playSound('undo');
}

function resetAll() {
  if (state.rounds.length === 0) return;
  
  if (!confirm('ูู ุชุฑูุฏ ุฅุนุงุฏุฉ ุชุนููู ุฌููุน ุงูุจูุงูุงุชุ')) return;
  
  state.rounds = [];
  state.count = { P: 0, B: 0, T: 0 };
  state.win = { P: 0, B: 0, T: 0 };
  state.loss = { P: 0, B: 0, T: 0 };
  state.lastPrediction = null;
  state.accuracyHistory = [];
  state.predictionsHistory = [];
  state.modelPerformance = { basic: 0, advanced: 0, pattern: 0, ml: 0 };
  state.previousPredictions = { P: 0, B: 0, T: 0 };
  
  state.ml.reset();
  
  updateAll();
  dataManager.saveAllData();
  dataManager.updateDataStats();
  
  if (state.talkingAssistant) {
    state.talkingAssistant.speak("ุชู ุฅุนุงุฏุฉ ุชุนููู ุฌููุน ุงูุจูุงูุงุช. ููุง ูุจุฏุฃ ูู ุฌุฏูุฏ!");
  }
  
  playSound('reset');
}

function calculateWinRate() {
  const totalWins = state.win.P + state.win.B + state.win.T;
  const totalPredictions = state.predictionsHistory.length;
  return totalPredictions > 0 ? (totalWins / totalPredictions) * 100 : 0;
}

function calculateRecentLosses() {
  if (state.predictionsHistory.length < 5) return 0;
  const recent = state.predictionsHistory.slice(-5);
  return recent.filter(p => !p.correct).length;
}

function playSound(type) {
  try {
    if (type === 'click') {
      const audio = new Audio('data:audio/wav;base64,UklGRigAAABXQVZFZm10IBIAAAABAAEARKwAAIhYAQACABAAZGF0YQQAAAAAAA==');
      audio.volume = 0.1;
      audio.play();
    }
  } catch (e) {
    // ุชุฌุงูู ุฃุฎุทุงุก ุงูุตูุช
  }
}

function updatePredictionDisplay(pred) {
  el('predPctP').textContent = pred.P + '%';
  el('predPctB').textContent = pred.B + '%';
  el('predPctT').textContent = pred.T + '%';
  
  updateTrendIndicators(pred);
  
  ['predP', 'predB', 'predT'].forEach(id => {
    el(id).classList.remove('active');
  });
  
  if (pred.final !== 'โ') {
    const finalEl = el('pred' + pred.final);
    if (finalEl) finalEl.classList.add('active');
  }
  
  let finalText = 'โ';
  if (pred.final === 'P') finalText = 'ูุงุนุจ';
  else if (pred.final === 'B') finalText = 'ูุตุฑูู';
  else if (pred.final === 'T') finalText = 'ุชุนุงุฏู';
  
  el('finalCard').textContent = finalText;
  
  el('mlContribution').textContent = pred.mlContribution > 0 ? 
    `๐ ูุณุงููุฉ ุชุนูู ุงูุขูุฉ: ${pred.mlContribution}%` : '';
  
  updateConfidenceMeter(pred.confidence);
  updateModelInfo(pred);
}

function updateTrendIndicators(pred) {
  const current = { 
    P: parseFloat(pred.P) || 0, 
    B: parseFloat(pred.B) || 0, 
    T: parseFloat(pred.T) || 0 
  };
  const previous = state.previousPredictions;
  
  ['P', 'B', 'T'].forEach(type => {
    const trendEl = el('predTrend' + type);
    if (!trendEl) return;
    
    if (previous[type] > 0) {
      const diff = current[type] - previous[type];
      if (diff > 2) trendEl.textContent = 'โ';
      else if (diff < -2) trendEl.textContent = 'โ';
      else trendEl.textContent = 'โ';
      trendEl.style.color = diff > 0 ? '#38b000' : diff < 0 ? '#ff006e' : '#bfb7a6';
    } else {
      trendEl.textContent = 'โ';
    }
  });
  
  state.previousPredictions = current;
}

function updateConfidenceMeter(confidence) {
  const fill = el('confidenceFill');
  const label = el('confidenceLabel');
  
  if (!fill || !label) return;
  
  fill.style.width = confidence + '%';
  
  if (confidence >= 70) {
    fill.className = 'confidence-fill high-confidence';
    label.textContent = 'ุซูุฉ ุนุงููุฉ';
    label.style.color = '#38b000';
  } else if (confidence >= 40) {
    fill.className = 'confidence-fill medium-confidence';
    label.textContent = 'ุซูุฉ ูุชูุณุทุฉ';
    label.style.color = '#d4af37';
  } else {
    fill.className = 'confidence-fill';
    label.textContent = 'ุซูุฉ ููุฎูุถุฉ';
    label.style.color = '#ff006e';
  }
}

function updateModelInfo(pred) {
  const modelEl = el('predModel');
  const modelInfoEl = el('modelInfo');
  const reasonEl = el('predictionReason');
  
  if (!modelEl || !modelInfoEl || !reasonEl) return;
  
  let modelName, modelClass, reason;
  
  switch(pred.model) {
    case 'basic':
      modelName = 'ุฃุณุงุณู';
      modelClass = 'badge-basic';
      reason = 'ูุนุชูุฏ ุนูู ุชุญููู ุงูุชุฑุฏุฏ ุงูุฃุณุงุณู';
      break;
    case 'advanced':
      modelName = 'ูุชูุฏู';
      modelClass = 'badge-advanced';
      reason = 'ูุฌูุน ุจูู ุชุญููู ุงูุชุฑุฏุฏ ูุงูุฃููุงุท';
      break;
    case 'pattern':
      modelName = 'ุงูุฃููุงุท';
      modelClass = 'badge-pattern';
      reason = 'ูุฑูุฒ ุนูู ุชุญููู ุงูุชุณูุณูุงุช ูุงูุฃููุงุท';
      break;
    case 'ml':
      modelName = 'ุชุนูู ุงูุขูุฉ';
      modelClass = 'badge-ml';
      reason = 'ูุณุชุฎุฏู ุฎูุงุฑุฒููุงุช ML ูุน ุงูุชุฏุฑูุจ ุงูุชููุงุฆู';
      break;
    default:
      modelName = 'ุฃุณุงุณู';
      modelClass = 'badge-basic';
      reason = 'ูุนุชูุฏ ุนูู ุชุญููู ุงูุชุฑุฏุฏ ุงูุฃุณุงุณู';
  }
  
  modelEl.textContent = modelName;
  modelEl.className = 'model-badge ' + modelClass;
  
  const efficiency = calculateModelEfficiency();
  modelInfoEl.textContent = `ุงููููุฐุฌ: ${modelName} - ุงูููุงุกุฉ: ${efficiency}%`;
  
  if (pred.final === 'โ') {
    reasonEl.textContent = 'ุนุฏู ููุงูุฉ ุงูุซูุฉ ููุชูุจุค (ุชุญุช ' + state.confidenceThreshold + '%)';
  } else {
    reasonEl.textContent = reason + ` - ุงูุซูุฉ: ${pred.confidence.toFixed(1)}%`;
  }
}

function calculateModelEfficiency() {
  const total = Object.values(state.modelPerformance).reduce((a, b) => a + b, 0);
  const current = state.modelPerformance[state.analysisMode] || 0;
  return total > 0 ? Math.round((current / total) * 100) : 0;
}

function showResult(r, pred, didWin) {
  const finalCard = el('finalCard');
  if (!finalCard) return;
  
  finalCard.classList.remove('win-effect', 'loss-effect');
  setTimeout(() => {
    finalCard.classList.add(didWin ? 'win-effect' : 'loss-effect');
  }, 10);
}

function updateMLStatus() {
  const trainingCount = state.ml.getTrainingDataCount();
  const mlWeight = state.ml.getMLWeight() * 100;
  const mlAccuracy = state.ml.getModelAccuracy(state.mlModel);
  
  el('mlTrainingCount').textContent = trainingCount;
  el('mlWeight').textContent = mlWeight.toFixed(0) + '%';
  el('mlAccuracy').textContent = mlAccuracy.toFixed(1) + '%';
  
  const statusEl = el('mlStatus');
  if (!statusEl) return;
  
  if (trainingCount < 5) {
    statusEl.innerHTML = '<span class="ml-training-indicator ml-not-trained"></span> ูุญุชุงุฌ ุงููุฒูุฏ ูู ุงูุจูุงูุงุช';
    statusEl.style.color = '#ff006e';
  } else if (trainingCount < 15) {
    statusEl.innerHTML = '<span class="ml-training-indicator ml-training"></span> ูุชุนูู...';
    statusEl.style.color = '#d4af37';
  } else {
    statusEl.innerHTML = '<span class="ml-training-indicator ml-training"></span> ุฌุงูุฒ ููุชูุจุค';
    statusEl.style.color = '#38b000';
  }
  
  el('mlOverallAccuracy').textContent = mlAccuracy.toFixed(1) + '%';
}

function updateAll() {
  renderStats();
  renderBigRoad();
  updatePredictionCounts();
  updateAccuracyStats();
  updateAccuracyChart();
  updatePatternInfo();
  updateMLStats();
  updateDataStatsDisplay();
}

function updateDataStatsDisplay() {
  dataManager.updateDataStats();
}

function updateMLStats() {
  const mlAccuracy = state.ml.getModelAccuracy(state.mlModel);
  el('mlOverallAccuracy').textContent = mlAccuracy.toFixed(1) + '%';
  
  const mlOverall = mlAccuracy;
  el('pMLAccuracy').textContent = (mlOverall * 0.9).toFixed(1) + '%';
  el('bMLAccuracy').textContent = (mlOverall * 0.95).toFixed(1) + '%';
  el('tMLAccuracy').textContent = (mlOverall * 0.7).toFixed(1) + '%';
}

function renderStats() {
  el('pTotal').textContent = state.count.P;
  el('bTotal').textContent = state.count.B;
  el('tTotal').textContent = state.count.T;
  
  el('pWin').textContent = state.win.P;
  el('bWin').textContent = state.win.B;
  el('tWin').textContent = state.win.T;
  
  el('pLoss').textContent = state.loss.P;
  el('bLoss').textContent = state.loss.B;
  el('tLoss').textContent = state.loss.T;
  
  el('pPct').textContent = calculatePercentage(state.win.P, state.loss.P);
  el('bPct').textContent = calculatePercentage(state.win.B, state.loss.B);
  el('tPct').textContent = calculatePercentage(state.win.T, state.loss.T);
  
  el('pAccuracy').textContent = calculateAccuracy('P');
  el('bAccuracy').textContent = calculateAccuracy('B');
  el('tAccuracy').textContent = calculateAccuracy('T');
}

function calculatePercentage(win, loss) {
  const total = win + loss;
  return total > 0 ? ((win / total) * 100).toFixed(1) + '%' : '0%';
}

function calculateAccuracy(type) {
  const totalPredictions = state.predictionsHistory.filter(p => p.prediction === type).length;
  const correctPredictions = state.predictionsHistory.filter(p => p.prediction === type && p.correct).length;
  return totalPredictions > 0 ? ((correctPredictions / totalPredictions) * 100).toFixed(1) + '%' : '0%';
}

function renderBigRoad() {
  const canvas = el('bigRoad');
  if (!canvas) return;
  
  const ctx = canvas.getContext('2d');
  ctx.clearRect(0, 0, canvas.width, canvas.height);
  
  const size = 35;
  let x = 0, y = 0;
  const maxCols = Math.floor(canvas.width / size);
  
  for (let i = 0; i < state.rounds.length; i++) {
    const r = state.rounds[i];
    
    ctx.fillStyle = r === 'P' ? '#3a86ff' : r === 'B' ? '#ff006e' : '#38b000';
    ctx.fillRect(x * size, y * size, size - 2, size - 2);
    
    ctx.fillStyle = '#ffffff';
    ctx.font = 'bold 14px Inter';
    ctx.textAlign = 'center';
    ctx.textBaseline = 'middle';
    ctx.fillText((i+1).toString(), x * size + size/2, y * size + size/2);
    
    y++;
    if (y * size >= canvas.height) {
      y = 0;
      x++;
      if (x >= maxCols) break;
    }
  }
}

function updatePredictionCounts() {
  const pred = enhancedPredict();
  updatePredictionDisplay(pred);
}

function updatePatternInfo() {
  const infoEl = el('patternInfo');
  if (!infoEl) return;
  
  if (state.rounds.length < 3) {
    infoEl.textContent = 'ูุง ุชูุฌุฏ ุฃููุงุท ููุชุดูุฉ ุจุนุฏ';
    return;
  }
  
  const trend = calculateTrend(state.rounds);
  const recent = state.rounds.slice(-5);
  const pCount = recent.filter(r => r === 'P').length;
  const bCount = recent.filter(r => r === 'B').length;
  const tCount = recent.filter(r => r === 'T').length;
  
  let info = `ุงูุงุชุฌุงู: ${trend.direction === 'volatile' ? 'ูุชููุจ' : trend.direction === 'mixed' ? 'ูุฎุชูุท' : 'ูุณุชูุฑ'}`;
  info += ` | ุขุฎุฑ 5: ๐ต${pCount} ๐ด${bCount} ๐ข${tCount}`;
  
  infoEl.textContent = info;
}

function calculateTrend(rounds) {
  if (rounds.length < 2) return { direction: 'stable', strength: 0 };
  
  const changes = [];
  for (let i = 1; i < rounds.length; i++) {
    changes.push(rounds[i] === rounds[i-1] ? 0 : 1);
  }
  
  const changeRate = changes.reduce((a, b) => a + b, 0) / changes.length;
  return {
    direction: changeRate > 0.6 ? 'volatile' : changeRate > 0.4 ? 'mixed' : 'stable',
    strength: Math.abs(changeRate - 0.5) * 2
  };
}

function updateAccuracyData(actualResult) {
  if (state.lastPrediction && state.lastPrediction !== 'โ') {
    const isCorrect = state.lastPrediction === actualResult;
    state.predictionsHistory.push({
      prediction: state.lastPrediction,
      actual: actualResult,
      correct: isCorrect,
      model: state.analysisMode
    });
    
    const correctPredictions = state.predictionsHistory.filter(p => p.correct).length;
    const totalPredictions = state.predictionsHistory.length;
    const accuracy = totalPredictions > 0 ? (correctPredictions / totalPredictions) * 100 : 0;
    
    state.accuracyHistory.push(accuracy);
  }
}

function updateAccuracyStats() {
  if (state.accuracyHistory.length === 0) {
    el('currentAccuracy').textContent = '0%';
    el('bestAccuracy').textContent = '0%';
    el('averageAccuracy').textContent = '0%';
    return;
  }
  
  const currentAccuracy = state.accuracyHistory[state.accuracyHistory.length - 1];
  const bestAccuracy = Math.max(...state.accuracyHistory);
  const averageAccuracy = state.accuracyHistory.reduce((a, b) => a + b, 0) / state.accuracyHistory.length;
  
  el('currentAccuracy').textContent = currentAccuracy.toFixed(1) + '%';
  el('bestAccuracy').textContent = bestAccuracy.toFixed(1) + '%';
  el('averageAccuracy').textContent = averageAccuracy.toFixed(1) + '%';
}

function updateAccuracyChart() {
  const svg = el('accuracyChart');
  const tooltip = el('accuracyTooltip');
  if (!svg || !tooltip) return;
  
  svg.innerHTML = '';
  
  if (state.accuracyHistory.length < 2) return;
  
  const width = svg.clientWidth || 600;
  const height = svg.clientHeight || 80;
  const padding = 20;
  
  for (let i = 0; i <= 100; i += 20) {
    const y = height - padding - (i / 100) * (height - 2 * padding);
    const line = document.createElementNS('http://www.w3.org/2000/svg', 'line');
    line.setAttribute('class', 'accuracy-grid');
    line.setAttribute('x1', padding);
    line.setAttribute('y1', y);
    line.setAttribute('x2', width - padding);
    line.setAttribute('y2', y);
    svg.appendChild(line);
    
    const text = document.createElementNS('http://www.w3.org/2000/svg', 'text');
    text.setAttribute('x', padding - 5);
    text.setAttribute('y', y + 4);
    text.setAttribute('text-anchor', 'end');
    text.setAttribute('fill', 'var(--muted)');
    text.setAttribute('font-size', '10px');
    text.textContent = i + '%';
    svg.appendChild(text);
  }
  
  const path = document.createElementNS('http://www.w3.org/2000/svg', 'path');
  let pathData = '';
  
  state.accuracyHistory.forEach((accuracy, index) => {
    const x = padding + (index / (state.accuracyHistory.length - 1)) * (width - 2 * padding);
    const y = height - padding - (accuracy / 100) * (height - 2 * padding);
    
    if (index === 0) {
      pathData = `M ${x} ${y}`;
    } else {
      pathData += ` L ${x} ${y}`;
    }
    
    const point = document.createElementNS('http://www.w3.org/2000/svg', 'circle');
    point.setAttribute('class', 'accuracy-point');
    point.setAttribute('cx', x);
    point.setAttribute('cy', y);
    point.setAttribute('r', 3);
    
    point.addEventListener('mouseover', (e) => {
      const rect = svg.getBoundingClientRect();
      tooltip.style.left = (e.clientX - rect.left + 10) + 'px';
      tooltip.style.top = (e.clientY - rect.top - 30) + 'px';
      tooltip.textContent = `ุงูุฌููุฉ ${index + 1}: ${accuracy.toFixed(1)}%`;
      tooltip.style.opacity = '1';
    });
    
    point.addEventListener('mouseout', () => {
      tooltip.style.opacity = '0';
    });
    
    svg.appendChild(point);
  });
  
  path.setAttribute('d', pathData);
  path.setAttribute('class', 'accuracy-line');
  svg.appendChild(path);
}

// ุชููุฆุฉ ุงูุชุทุจูู ุนูุฏ ุชุญููู ุงูุตูุญุฉ
window.addEventListener('DOMContentLoaded', init);
</script>
</body>
</html>
